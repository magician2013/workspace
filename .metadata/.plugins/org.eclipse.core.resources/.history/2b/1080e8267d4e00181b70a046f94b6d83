/*
 * rfft_256.c
 *
 *  Created on: 2015¦~7¤ë20¤é
 *      Author: ych
 */
#include <errno.h>
#include "type_def.h"
#include "basic_op.h"
#include "hd_aec.h"
#include "howling_ctrl.h"
#include "resample_441_480.h"
#include "rfft_256.h"
#include "sprd_tab.h"
#include "webrtc_lib/include/ring_buffer.h"

#define hL 128
#define F_UPPER 256
#define F_LOWER 20
#define N_ORDER 9

extern FILE *pFiles;

static Word16 ALIGN4_BEGIN position_table[48] ALIGN4_END = { 0, 1, 2, 4, 5, 6,
		8, 9, 10, 12, 13, 14, 16, 17, 18, 20, 21, 22, 24, 25, 26, 28, 29, 30,
		32, 33, 34, 36, 37, 38, 40, 41, 42, 44, 45, 46, 48, 49, 50, 52, 53, 54,
		56, 57, 58, 60, 61, 62 };

static Word16 ALIGN4_BEGIN Position_Table[80] ALIGN4_END = { 0, 1, 3, 4, 6, 8,
		9, 11, 12, 14, 16, 17, 19, 20, 22, 24, 25, 27, 28, 30, 32, 33, 35, 36,
		38, 40, 41, 43, 44, 46, 48, 49, 51, 52, 54, 56, 57, 59, 60, 62, 64, 65,
		67, 68, 70, 72, 73, 75, 76, 78, 80, 81, 83, 84, 86, 88, 89, 91, 92, 94,
		96, 97, 99, 100, 102, 104, 105, 107, 108, 110, 112, 113, 115, 116, 118,
		120, 121, 123, 124, 126 };

static Word16 ALIGN4_BEGIN coeff[3][hL] ALIGN4_END = { { -1, -118, 168, -121, 0,
		125, -180, 129, 0, -135, 193, -140, 0, 144, -209, 150, -1, -157, 226,
		-164, 0, 171, -249, 179, -1, -190, 274, -200, 0, 210, -307, 223, -1,
		-238, 347, -255, -1, 273, -402, 295, -1, -321, 474, -352, 0, 388, -580,
		433, -1, -492, 745, -568, 0, 670, -1044, 819, -1, -1054, 1738, -1476, 0,
		2458, -5216, 7375, 24575, 7375, -5216, 2458, 0, -1476, 1738, -1054, -1,
		819, -1044, 670, 0, -568, 745, -492, -1, 433, -580, 388, 0, -352, 474,
		-321, -1, 295, -402, 273, -1, -255, 347, -238, -1, 223, -307, 210, 0,
		-200, 274, -190, -1, 179, -249, 171, 0, -164, 226, -157, -1, 150, -209,
		144, 0, -140, 193, -135, 0, 129, -180, 125, 0, -121, 168, -118 }, { 114,
		-165, 118, -1, -123, 175, -127, 0, 130, -189, 135, -1, -141, 203, -147,
		0, 152, -221, 159, 0, -167, 240, -175, 0, 182, -266, 192, -1, -203, 295,
		-215, -1, 228, -333, 243, -1, -261, 381, -281, 0, 303, -448, 330, -1,
		-363, 539, -403, -1, 451, -681, 514, -1, -598, 920, -714, 0, 885, -1423,
		1164, -1, -1702, 3129, -3161, 0, 22125, 15645, -4426, -1, 2011, -2236,
		1301, 0, -962, 1203, -763, -1, 632, -824, 539, 0, -471, 625, -418, -1,
		375, -505, 340, -1, -312, 422, -288, -1, 266, -364, 248, 0, -233, 319,
		-220, 0, 206, -285, 195, -1, -186, 256, -178, -1, 168, -234, 161, 0,
		-155, 214, -149, -1, 142, -199, 137, 0, -133, 184, -128, -1, 123, -172,
		119, -1 }, { 161, -116, -1, 119, -172, 123, -1, -128, 184, -133, 0, 137,
		-199, 142, -1, -149, 214, -155, 0, 161, -234, 168, -1, -178, 256, -186,
		-1, 195, -285, 206, 0, -220, 319, -233, 0, 248, -364, 266, -1, -288,
		422, -312, -1, 340, -505, 375, -1, -418, 625, -471, 0, 539, -824, 632,
		-1, -763, 1203, -962, 0, 1301, -2236, 2011, -1, -4426, 15645, 22125, 0,
		-3161, 3129, -1702, -1, 1164, -1423, 885, 0, -714, 920, -598, -1, 514,
		-681, 451, -1, -403, 539, -363, -1, 330, -448, 303, 0, -281, 381, -261,
		-1, 243, -333, 228, -1, -215, 295, -203, -1, 192, -266, 182, 0, -175,
		240, -167, 0, 159, -221, 152, 0, -147, 203, -141, -1, 135, -189, 130, 0,
		-127, 175, -123, -1, 118 } };

static Word16 ALIGN4_BEGIN Coeff[5][hL] ALIGN4_END = { { -1, -153, 118, 65,
		-174, 67, 127, -170, 0, 175, -137, -76, 200, -79, -148, 196, -1, -206,
		160, 88, -238, 92, 175, -236, -1, 247, -195, -108, 289, -115, -217, 292,
		-1, -311, 245, 137, -373, 147, 283, -386, 0, 418, -336, -191, 521, -211,
		-410, 566, -1, -643, 526, 307, -870, 362, 737, -1071, 0, 1376, -1230,
		-799, 2607, -1331, -3688, 9636, 20479, 9636, -3688, -1331, 2607, -799,
		-1230, 1376, 0, -1071, 737, 362, -870, 307, 526, -643, -1, 566, -410,
		-211, 521, -191, -336, 418, 0, -386, 283, 147, -373, 137, 245, -311, -1,
		292, -217, -115, 289, -108, -195, 247, -1, -236, 175, 92, -238, 88, 160,
		-206, -1, 196, -148, -79, 200, -76, -137, 175, 0, -170, 127, 67, -174,
		65, 118, -153 }, { 149, -116, -64, 169, -66, -124, 164, -1, -171, 132,
		73, -195, 75, 142, -191, 0, 198, -155, -86, 228, -90, -170, 226, 0,
		-238, 186, 103, -278, 109, 207, -279, -1, 295, -234, -131, 352, -140,
		-268, 362, -1, -392, 312, 176, -483, 193, 376, -519, 0, 580, -473, -274,
		766, -317, -636, 909, -1, -1121, 970, 604, -1863, 867, 2048, -3707, 0,
		16060, 18437, 2851, -4346, 1173, 1676, -1785, -1, 1302, -878, -425,
		1002, -351, -595, 719, 0, -626, 449, 229, -567, 205, 361, -451, -1, 411,
		-303, -158, 395, -146, -260, 327, 0, -307, 227, 119, -304, 112, 202,
		-258, -1, 244, -183, -97, 245, -92, -167, 212, -1, -204, 152, 80, -207,
		77, 140, -181, 0, 173, -131, -70, 178, -68, -123, 156, 0 }, { 62, -166,
		64, 120, -161, 0, 165, -129, -72, 188, -74, -139, 184, -1, -192, 149,
		82, -221, 86, 163, -219, 0, 228, -180, -100, 266, -105, -199, 266, -1,
		-282, 222, 123, -335, 132, 252, -342, -1, 367, -293, -165, 449, -180,
		-348, 477, -1, -530, 428, 246, -687, 281, 558, -790, 0, 944, -802, -487,
		1448, -644, -1419, 2294, -1, -4381, 6145, 19957, 13037, -2218, -2634,
		2535, 0, -1662, 1084, 511, -1186, 407, 682, -817, -1, 698, -499, -253,
		620, -225, -393, 486, -1, -443, 323, 167, -421, 154, 275, -347, -1, 323,
		-240, -126, 317, -119, -212, 269, 0, -255, 190, 100, -256, 95, 172,
		-221, -1, 210, -158, -84, 213, -81, -146, 186, 0, -180, 134, 71, -184,
		69, 125, -162, -1, 155, -118 },
		{ 160, -63, -118, 155, -1, -162, 125, 69, -184, 71, 134, -180, 0, 186,
				-146, -81, 213, -84, -158, 210, -1, -221, 172, 95, -256, 100,
				190, -255, 0, 269, -212, -119, 317, -126, -240, 323, -1, -347,
				275, 154, -421, 167, 323, -443, -1, 486, -393, -225, 620, -253,
				-499, 698, -1, -817, 682, 407, -1186, 511, 1084, -1662, 0, 2535,
				-2634, -2218, 13037, 19957, 6145, -4381, -1, 2294, -1419, -644,
				1448, -487, -802, 944, 0, -790, 558, 281, -687, 246, 428, -530,
				-1, 477, -348, -180, 449, -165, -293, 367, -1, -342, 252, 132,
				-335, 123, 222, -282, -1, 266, -199, -105, 266, -100, -180, 228,
				0, -219, 163, 86, -221, 82, 149, -192, -1, 184, -139, -74, 188,
				-72, -129, 165, 0, -161, 120, 64 }, { 114, -152, 0, 156, -123,
				-68, 178, -70, -131, 173, 0, -181, 140, 77, -207, 80, 152, -204,
				-1, 212, -167, -92, 245, -97, -183, 244, -1, -258, 202, 112,
				-304, 119, 227, -307, 0, 327, -260, -146, 395, -158, -303, 411,
				-1, -451, 361, 205, -567, 229, 449, -626, 0, 719, -595, -351,
				1002, -425, -878, 1302, -1, -1785, 1676, 1173, -4346, 2851,
				18437, 16060, 0, -3707, 2048, 867, -1863, 604, 970, -1121, -1,
				909, -636, -317, 766, -274, -473, 580, 0, -519, 376, 193, -483,
				176, 312, -392, -1, 362, -268, -140, 352, -131, -234, 295, -1,
				-279, 207, 109, -278, 103, 186, -238, 0, 226, -170, -90, 228,
				-86, -155, 198, 0, -191, 142, 75, -195, 73, 132, -171, -1, 164,
				-124, -66, 169, -64 } };

Word16 ALIGN4_BEGIN hann1024[512] ALIGN4_END = { 71, 142, 213, 284, 355, 426,
		497, 568, 639, 710, 781, 852, 923, 993, 1064, 1135, 1206, 1277, 1348,
		1419, 1490, 1560, 1631, 1702, 1773, 1844, 1914, 1985, 2056, 2126, 2197,
		2268, 2338, 2409, 2480, 2550, 2621, 2691, 2762, 2832, 2903, 2973, 3043,
		3114, 3184, 3254, 3325, 3395, 3465, 3535, 3605, 3675, 3746, 3816, 3886,
		3956, 4025, 4095, 4165, 4235, 4305, 4374, 4444, 4514, 4583, 4653, 4722,
		4792, 4861, 4931, 5000, 5069, 5139, 5208, 5277, 5346, 5415, 5484, 5553,
		5622, 5691, 5759, 5828, 5897, 5965, 6034, 6103, 6171, 6239, 6308, 6376,
		6444, 6512, 6580, 6648, 6716, 6784, 6852, 6920, 6988, 7055, 7123, 7190,
		7258, 7325, 7392, 7460, 7527, 7594, 7661, 7728, 7795, 7862, 7928, 7995,
		8062, 8128, 8194, 8261, 8327, 8393, 8459, 8525, 8591, 8657, 8723, 8789,
		8854, 8920, 8985, 9051, 9116, 9181, 9246, 9311, 9376, 9441, 9506, 9571,
		9635, 9700, 9764, 9829, 9893, 9957, 10021, 10085, 10149, 10213, 10276,
		10340, 10403, 10467, 10530, 10593, 10656, 10719, 10782, 10845, 10907,
		10970, 11032, 11095, 11157, 11219, 11281, 11343, 11405, 11467, 11528,
		11590, 11651, 11713, 11774, 11835, 11896, 11957, 12017, 12078, 12138,
		12199, 12259, 12319, 12379, 12439, 12499, 12559, 12618, 12678, 12737,
		12796, 12855, 12914, 12973, 13032, 13091, 13149, 13208, 13266, 13324,
		13382, 13440, 13498, 13555, 13613, 13670, 13727, 13784, 13841, 13898,
		13955, 14011, 14068, 14124, 14180, 14236, 14292, 14348, 14404, 14459,
		14515, 14570, 14625, 14680, 14735, 14790, 14844, 14899, 14953, 15007,
		15061, 15115, 15168, 15222, 15275, 15329, 15382, 15435, 15488, 15540,
		15593, 15645, 15698, 15750, 15802, 15854, 15905, 15957, 16008, 16059,
		16110, 16161, 16212, 16263, 16313, 16363, 16414, 16464, 16513, 16563,
		16613, 16662, 16711, 16760, 16809, 16858, 16907, 16955, 17003, 17051,
		17099, 17147, 17195, 17242, 17290, 17337, 17384, 17430, 17477, 17524,
		17570, 17616, 17662, 17708, 17754, 17799, 17844, 17890, 17935, 17979,
		18024, 18069, 18113, 18157, 18201, 18245, 18288, 18332, 18375, 18418,
		18461, 18504, 18547, 18589, 18631, 18673, 18715, 18757, 18799, 18840,
		18881, 18922, 18963, 19004, 19044, 19084, 19125, 19164, 19204, 19244,
		19283, 19322, 19361, 19400, 19439, 19477, 19516, 19554, 19592, 19630,
		19667, 19705, 19742, 19779, 19816, 19852, 19889, 19925, 19961, 19997,
		20033, 20068, 20104, 20139, 20174, 20208, 20243, 20277, 20312, 20346,
		20379, 20413, 20446, 20480, 20513, 20546, 20578, 20611, 20643, 20675,
		20707, 20739, 20770, 20801, 20833, 20863, 20894, 20925, 20955, 20985,
		21015, 21045, 21074, 21104, 21133, 21162, 21191, 21219, 21247, 21276,
		21303, 21331, 21359, 21386, 21413, 21440, 21467, 21493, 21520, 21546,
		21572, 21598, 21623, 21648, 21674, 21698, 21723, 21748, 21772, 21796,
		21820, 21844, 21867, 21890, 21913, 21936, 21959, 21981, 22004, 22026,
		22048, 22069, 22091, 22112, 22133, 22154, 22174, 22195, 22215, 22235,
		22254, 22274, 22293, 22312, 22331, 22350, 22369, 22387, 22405, 22423,
		22440, 22458, 22475, 22492, 22509, 22525, 22542, 22558, 22574, 22590,
		22605, 22621, 22636, 22651, 22665, 22680, 22694, 22708, 22722, 22736,
		22749, 22762, 22775, 22788, 22800, 22813, 22825, 22837, 22849, 22860,
		22871, 22882, 22893, 22904, 22914, 22924, 22934, 22944, 22954, 22963,
		22972, 22981, 22990, 22998, 23006, 23014, 23022, 23030, 23037, 23044,
		23051, 23058, 23065, 23071, 23077, 23083, 23088, 23094, 23099, 23104,
		23109, 23113, 23118, 23122, 23126, 23130, 23133, 23136, 23139, 23142,
		23145, 23147, 23149, 23151, 23153, 23155, 23156, 23157, 23158, 23158,
		23159, 23159 };

Word16 ALIGN4_BEGIN hann512[256] ALIGN4_END = { 200, 401, 601, 802, 1002, 1203,
		1403, 1603, 1803, 2003, 2203, 2403, 2603, 2803, 3003, 3202, 3402, 3601,
		3800, 3999, 4198, 4397, 4596, 4794, 4992, 5190, 5388, 5586, 5783, 5980,
		6177, 6374, 6571, 6767, 6963, 7159, 7354, 7549, 7744, 7939, 8133, 8327,
		8521, 8714, 8907, 9100, 9292, 9484, 9676, 9868, 10058, 10249, 10439,
		10629, 10818, 11007, 11196, 11384, 11572, 11759, 11946, 12133, 12319,
		12504, 12689, 12874, 13058, 13241, 13424, 13607, 13789, 13971, 14152,
		14332, 14512, 14691, 14870, 15049, 15226, 15404, 15580, 15756, 15932,
		16106, 16281, 16454, 16627, 16800, 16971, 17142, 17313, 17483, 17652,
		17820, 17988, 18155, 18322, 18488, 18653, 18817, 18981, 19144, 19306,
		19468, 19628, 19788, 19948, 20106, 20264, 20421, 20577, 20733, 20888,
		21042, 21195, 21347, 21499, 21650, 21800, 21949, 22097, 22244, 22391,
		22537, 22682, 22826, 22969, 23112, 23253, 23394, 23534, 23673, 23811,
		23948, 24084, 24219, 24354, 24487, 24620, 24751, 24882, 25012, 25141,
		25269, 25396, 25522, 25647, 25771, 25894, 26016, 26137, 26258, 26377,
		26495, 26612, 26728, 26844, 26958, 27071, 27183, 27295, 27405, 27514,
		27622, 27729, 27835, 27940, 28044, 28147, 28249, 28349, 28449, 28548,
		28645, 28742, 28837, 28932, 29025, 29117, 29208, 29298, 29387, 29475,
		29561, 29647, 29731, 29815, 29897, 29978, 30058, 30137, 30214, 30291,
		30366, 30441, 30514, 30586, 30657, 30726, 30795, 30862, 30929, 30994,
		31058, 31120, 31182, 31242, 31302, 31360, 31417, 31472, 31527, 31580,
		31633, 31684, 31733, 31782, 31829, 31876, 31921, 31965, 32007, 32049,
		32089, 32128, 32166, 32202, 32238, 32272, 32305, 32337, 32367, 32397,
		32425, 32452, 32477, 32502, 32525, 32547, 32568, 32588, 32606, 32623,
		32639, 32654, 32667, 32680, 32691, 32701, 32709, 32716, 32723, 32728,
		32731, 32734, 32735 };

static const Word16 ALIGN4_BEGIN kSinTable1024[] ALIGN4_END = { 0, 201, 402,
		603, 804, 1005, 1206, 1406, 1607, 1808, 2009, 2209, 2410, 2610, 2811,
		3011, 3211, 3411, 3611, 3811, 4011, 4210, 4409, 4608, 4807, 5006, 5205,
		5403, 5601, 5799, 5997, 6195, 6392, 6589, 6786, 6982, 7179, 7375, 7571,
		7766, 7961, 8156, 8351, 8545, 8739, 8932, 9126, 9319, 9511, 9703, 9895,
		10087, 10278, 10469, 10659, 10849, 11038, 11227, 11416, 11604, 11792,
		11980, 12166, 12353, 12539, 12724, 12909, 13094, 13278, 13462, 13645,
		13827, 14009, 14191, 14372, 14552, 14732, 14911, 15090, 15268, 15446,
		15623, 15799, 15975, 16150, 16325, 16499, 16672, 16845, 17017, 17189,
		17360, 17530, 17699, 17868, 18036, 18204, 18371, 18537, 18702, 18867,
		19031, 19194, 19357, 19519, 19680, 19840, 20000, 20159, 20317, 20474,
		20631, 20787, 20942, 21096, 21249, 21402, 21554, 21705, 21855, 22004,
		22153, 22301, 22448, 22594, 22739, 22883, 23027, 23169, 23311, 23452,
		23592, 23731, 23869, 24006, 24143, 24278, 24413, 24546, 24679, 24811,
		24942, 25072, 25201, 25329, 25456, 25582, 25707, 25831, 25954, 26077,
		26198, 26318, 26437, 26556, 26673, 26789, 26905, 27019, 27132, 27244,
		27355, 27466, 27575, 27683, 27790, 27896, 28001, 28105, 28208, 28309,
		28410, 28510, 28608, 28706, 28802, 28897, 28992, 29085, 29177, 29268,
		29358, 29446, 29534, 29621, 29706, 29790, 29873, 29955, 30036, 30116,
		30195, 30272, 30349, 30424, 30498, 30571, 30643, 30713, 30783, 30851,
		30918, 30984, 31049, 31113, 31175, 31236, 31297, 31356, 31413, 31470,
		31525, 31580, 31633, 31684, 31735, 31785, 31833, 31880, 31926, 31970,
		32014, 32056, 32097, 32137, 32176, 32213, 32249, 32284, 32318, 32350,
		32382, 32412, 32441, 32468, 32495, 32520, 32544, 32567, 32588, 32609,
		32628, 32646, 32662, 32678, 32692, 32705, 32717, 32727, 32736, 32744,
		32751, 32757, 32761, 32764, 32766, 32767, 32766, 32764, 32761, 32757,
		32751, 32744, 32736, 32727, 32717, 32705, 32692, 32678, 32662, 32646,
		32628, 32609, 32588, 32567, 32544, 32520, 32495, 32468, 32441, 32412,
		32382, 32350, 32318, 32284, 32249, 32213, 32176, 32137, 32097, 32056,
		32014, 31970, 31926, 31880, 31833, 31785, 31735, 31684, 31633, 31580,
		31525, 31470, 31413, 31356, 31297, 31236, 31175, 31113, 31049, 30984,
		30918, 30851, 30783, 30713, 30643, 30571, 30498, 30424, 30349, 30272,
		30195, 30116, 30036, 29955, 29873, 29790, 29706, 29621, 29534, 29446,
		29358, 29268, 29177, 29085, 28992, 28897, 28802, 28706, 28608, 28510,
		28410, 28309, 28208, 28105, 28001, 27896, 27790, 27683, 27575, 27466,
		27355, 27244, 27132, 27019, 26905, 26789, 26673, 26556, 26437, 26318,
		26198, 26077, 25954, 25831, 25707, 25582, 25456, 25329, 25201, 25072,
		24942, 24811, 24679, 24546, 24413, 24278, 24143, 24006, 23869, 23731,
		23592, 23452, 23311, 23169, 23027, 22883, 22739, 22594, 22448, 22301,
		22153, 22004, 21855, 21705, 21554, 21402, 21249, 21096, 20942, 20787,
		20631, 20474, 20317, 20159, 20000, 19840, 19680, 19519, 19357, 19194,
		19031, 18867, 18702, 18537, 18371, 18204, 18036, 17868, 17699, 17530,
		17360, 17189, 17017, 16845, 16672, 16499, 16325, 16150, 15975, 15799,
		15623, 15446, 15268, 15090, 14911, 14732, 14552, 14372, 14191, 14009,
		13827, 13645, 13462, 13278, 13094, 12909, 12724, 12539, 12353, 12166,
		11980, 11792, 11604, 11416, 11227, 11038, 10849, 10659, 10469, 10278,
		10087, 9895, 9703, 9511, 9319, 9126, 8932, 8739, 8545, 8351, 8156, 7961,
		7766, 7571, 7375, 7179, 6982, 6786, 6589, 6392, 6195, 5997, 5799, 5601,
		5403, 5205, 5006, 4807, 4608, 4409, 4210, 4011, 3811, 3611, 3411, 3211,
		3011, 2811, 2610, 2410, 2209, 2009, 1808, 1607, 1406, 1206, 1005, 804,
		603, 402, 201, 0, -202, -403, -604, -805, -1006, -1207, -1407, -1608,
		-1809, -2010, -2210, -2411, -2611, -2812, -3012, -3212, -3412, -3612,
		-3812, -4012, -4211, -4410, -4609, -4808, -5007, -5206, -5404, -5602,
		-5800, -5998, -6196, -6393, -6590, -6787, -6983, -7180, -7376, -7572,
		-7767, -7962, -8157, -8352, -8546, -8740, -8933, -9127, -9320, -9512,
		-9704, -9896, -10088, -10279, -10470, -10660, -10850, -11039, -11228,
		-11417, -11605, -11793, -11981, -12167, -12354, -12540, -12725, -12910,
		-13095, -13279, -13463, -13646, -13828, -14010, -14192, -14373, -14553,
		-14733, -14912, -15091, -15269, -15447, -15624, -15800, -15976, -16151,
		-16326, -16500, -16673, -16846, -17018, -17190, -17361, -17531, -17700,
		-17869, -18037, -18205, -18372, -18538, -18703, -18868, -19032, -19195,
		-19358, -19520, -19681, -19841, -20001, -20160, -20318, -20475, -20632,
		-20788, -20943, -21097, -21250, -21403, -21555, -21706, -21856, -22005,
		-22154, -22302, -22449, -22595, -22740, -22884, -23028, -23170, -23312,
		-23453, -23593, -23732, -23870, -24007, -24144, -24279, -24414, -24547,
		-24680, -24812, -24943, -25073, -25202, -25330, -25457, -25583, -25708,
		-25832, -25955, -26078, -26199, -26319, -26438, -26557, -26674, -26790,
		-26906, -27020, -27133, -27245, -27356, -27467, -27576, -27684, -27791,
		-27897, -28002, -28106, -28209, -28310, -28411, -28511, -28609, -28707,
		-28803, -28898, -28993, -29086, -29178, -29269, -29359, -29447, -29535,
		-29622, -29707, -29791, -29874, -29956, -30037, -30117, -30196, -30273,
		-30350, -30425, -30499, -30572, -30644, -30714, -30784, -30852, -30919,
		-30985, -31050, -31114, -31176, -31237, -31298, -31357, -31414, -31471,
		-31526, -31581, -31634, -31685, -31736, -31786, -31834, -31881, -31927,
		-31971, -32015, -32057, -32098, -32138, -32177, -32214, -32250, -32285,
		-32319, -32351, -32383, -32413, -32442, -32469, -32496, -32521, -32545,
		-32568, -32589, -32610, -32629, -32647, -32663, -32679, -32693, -32706,
		-32718, -32728, -32737, -32745, -32752, -32758, -32762, -32765, -32767,
		-32767, -32767, -32765, -32762, -32758, -32752, -32745, -32737, -32728,
		-32718, -32706, -32693, -32679, -32663, -32647, -32629, -32610, -32589,
		-32568, -32545, -32521, -32496, -32469, -32442, -32413, -32383, -32351,
		-32319, -32285, -32250, -32214, -32177, -32138, -32098, -32057, -32015,
		-31971, -31927, -31881, -31834, -31786, -31736, -31685, -31634, -31581,
		-31526, -31471, -31414, -31357, -31298, -31237, -31176, -31114, -31050,
		-30985, -30919, -30852, -30784, -30714, -30644, -30572, -30499, -30425,
		-30350, -30273, -30196, -30117, -30037, -29956, -29874, -29791, -29707,
		-29622, -29535, -29447, -29359, -29269, -29178, -29086, -28993, -28898,
		-28803, -28707, -28609, -28511, -28411, -28310, -28209, -28106, -28002,
		-27897, -27791, -27684, -27576, -27467, -27356, -27245, -27133, -27020,
		-26906, -26790, -26674, -26557, -26438, -26319, -26199, -26078, -25955,
		-25832, -25708, -25583, -25457, -25330, -25202, -25073, -24943, -24812,
		-24680, -24547, -24414, -24279, -24144, -24007, -23870, -23732, -23593,
		-23453, -23312, -23170, -23028, -22884, -22740, -22595, -22449, -22302,
		-22154, -22005, -21856, -21706, -21555, -21403, -21250, -21097, -20943,
		-20788, -20632, -20475, -20318, -20160, -20001, -19841, -19681, -19520,
		-19358, -19195, -19032, -18868, -18703, -18538, -18372, -18205, -18037,
		-17869, -17700, -17531, -17361, -17190, -17018, -16846, -16673, -16500,
		-16326, -16151, -15976, -15800, -15624, -15447, -15269, -15091, -14912,
		-14733, -14553, -14373, -14192, -14010, -13828, -13646, -13463, -13279,
		-13095, -12910, -12725, -12540, -12354, -12167, -11981, -11793, -11605,
		-11417, -11228, -11039, -10850, -10660, -10470, -10279, -10088, -9896,
		-9704, -9512, -9320, -9127, -8933, -8740, -8546, -8352, -8157, -7962,
		-7767, -7572, -7376, -7180, -6983, -6787, -6590, -6393, -6196, -5998,
		-5800, -5602, -5404, -5206, -5007, -4808, -4609, -4410, -4211, -4012,
		-3812, -3612, -3412, -3212, -3012, -2812, -2611, -2411, -2210, -2010,
		-1809, -1608, -1407, -1207, -1006, -805, -604, -403, -202 };

Word32 ALIGN4_BEGIN CB_FREQ_INDICES_256[PartLen1] ALIGN4_END = { 0, 0, 0, 0, 1,
		1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7,
		7, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 11, 11,
		11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13,
		13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
		14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16,
		16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17,
		17, 17, 17, 17, 17, 17, 17 };

Word32 ALIGN4_BEGIN CB_OFST[18] ALIGN4_END = { 11, 13, 14, 16, 18, 20, 22, 25,
		28, 32, 35, 40, 45, 50, 56, 63, 71, 79 }; // alpha.*(14.5+j)+5.5*(1-alpha)

nr_state anr_config[CHANNEL_NUM];
sound_stretch sndstrh_config[CHANNEL_NUM];
#if !defined(_MSC_VER)
ica_state ica_config[CHANNEL_NUM]__attribute__((section("bss")));
#endif

void NR_Create(nr_state *st, Word32 mode) {
	Word32 i;

	st->nrStartup = 0;
	st->cntr = 0;
	st->mode = mode;
	st->beta = 22291;
	memset(st->bufferGamma[0], 0, sizeof(Word32) * PartLen1);
	memset(st->bufferGamma[1], 0, sizeof(Word32) * PartLen1);
	memset(st->bufferGamma[2], 0, sizeof(Word32) * PartLen1);

	for (i = 0; i < PartLen1; i += 1) {
		st->mEdge[i] = 0;
		st->mOnSet[i] = 0;
		st->mInterFere[i] = 0;
	}
}

Word32 Complex_FFT(ComplexInt16 *frfi, Word32 stages) {
	Word32 i, j, k, m, n, SignBase;
	Word32 s = 0;
	Word32 Blk_Exponent = 0;
	Word32 R = 1, S;
	ComplexInt16 *a, *b, *c, *d; //upper-half
	ComplexInt16 *w, *x, *y, *z; //lower-half
	ComplexInt16 wrwi, xrxi, yryi, zrzi; //Twiddle-Factors

	n = 1 << stages; //N=2^stages
	assert(n <= 1024);
	k = 10 - stages; //W(s*m,N/(2^K))=W((2^K*s)*m,N)

	if (stages & 1) {
		S = n >> 1; //N/2
		a = frfi; //x[0*N/2+s],y[n*R+m],sqrt(2)
		b = frfi + S; //x[1*N/2+s],k=nR+m,v(s=[0:S-1],m=[0:R-1]),v(s*R+m)
		SignBase = -2; //sum_{s}((sum_{r}(x[r*S+s]*W(rm,R))*W(sm,N))=v(s*R+m))*W(s*n,N)
		i = 0; //possibly 2-bit growth
		do {
			SignBase = exp_adj((Word16) (a + i)->real, SignBase);
			SignBase = exp_adj((Word16) (a + i)->imag, SignBase);
			SignBase = exp_adj((Word16) (b + i)->real, SignBase);
			SignBase = exp_adj((Word16) (b + i)->imag, SignBase);
		} while (++i < S);
		i = 0;
		do {
			switch (SignBase) { //sqrt(2)*2~=4
			case 0:
				frfi[i].real = L_add(frfi[i].real * 8192, 0x4000) >> 15;
				frfi[i].imag = L_add(frfi[i].imag * 8192, 0x4000) >> 15;
				break;
			case -1:
				frfi[i].real = L_add(frfi[i].real * 16384, 0x4000) >> 15;
				frfi[i].imag = L_add(frfi[i].imag * 16384, 0x4000) >> 15;
				break;
			default:
				assert(SignBase < -1);
				break;
			}
		} while (++i < n);
		Blk_Exponent += (SignBase + 2);
		SignBase = -3; //3-bit growth
		i = 0;
		do { //W(i*1,N)=cos(2*pi*i*1/N)-j*sin(2*pi*(i*2^k)*1/(1024)),sin(2*pi*(i*2^k)*1/(1024)+pi/2)
			 //sin(2*pi*k/1024),k=256,sin(pi/2)
			s = i << k; //2^K
			wrwi.real = kSinTable1024[(256 + s) & 0x3ff]; //W(m=1*s,N=n)
			wrwi.imag = -kSinTable1024[s]; //W(s*m,N)
			btr_fly_r2(a + i, b + i); //GCC-Inputs-Wide,Return-Narrow
			SignBase = exp_adj((a + i)->real, SignBase); //ARMCC-pass arguments narrow, return values narrow
			SignBase = exp_adj((a + i)->imag, SignBase);
			*(b + i) = complex_mul(*(b + i), wrwi); //max=sqrt(2)*4
			SignBase = exp_adj(b[i].real, SignBase);
			SignBase = exp_adj(b[i].imag, SignBase);

		} while (++i < S);
		i = 0;
		do {
			switch (SignBase) {
			case 0:
				frfi[i].real = L_add(frfi[i].real * 4096, 0x4000) >> 15;
				frfi[i].imag = L_add(frfi[i].imag * 4096, 0x4000) >> 15;
				break;
			case -1:
				frfi[i].real = L_add(frfi[i].real * 8192, 0x4000) >> 15;
				frfi[i].imag = L_add(frfi[i].imag * 8192, 0x4000) >> 15;
				break;
			case -2:
				frfi[i].real = L_add(frfi[i].real * 16384, 0x4000) >> 15;
				frfi[i].imag = L_add(frfi[i].imag * 16384, 0x4000) >> 15;
				break;
			default:
				assert(SignBase < -2);
				break;
			}

		} while (++i < n);
		Blk_Exponent += (SignBase + 3);
		stages -= 1; //2^(stages-1)
		S = n >> 1; //(N/2)/4,first-stage
		k += 1; //k=10-(stages-1)=k+1
		m = 0;
		do { //Stage-Loops
			i = 0;
			SignBase = -3;
			do {
				s = i << k;
				a = frfi + i; //x[0*S+s]
				b = a + S / 4; //x[1*S+s]
				c = b + S / 4; //x[2*S+s]
				d = c + S / 4; //x[3*S+s]
				w = frfi + (n >> 1) + i; //x_tilt[0*S+s]
				x = w + S / 4; //x_tilt[1*S+s]
				y = x + S / 4; //x_tilt[2*S+s]
				z = y + S / 4; //x_tilt[3*S+s]
				xrxi.real = kSinTable1024[(256 + 2 * s * R) & 0x3ff]; //W(s*2,N)
				xrxi.imag = -kSinTable1024[2 * s * R];
				yryi.real = kSinTable1024[(256 + s * R) & 0x3ff]; //W(s*1,N)
				yryi.imag = -kSinTable1024[s * R];
				zrzi.real = kSinTable1024[(256 + 3 * s * R) & 0x3ff]; //W(s*3,N)
				zrzi.imag = -kSinTable1024[3 * s * R];
				j = 0; //Groups-Loops
				do {
					SignBase = btr_fly_r4(a, b, c, d, SignBase);
					b[0] = complex_mul(b[0], xrxi);
					c[0] = complex_mul(c[0], yryi);
					d[0] = complex_mul(d[0], zrzi);
					SignBase = exp_adj(b->real, SignBase);
					SignBase = exp_adj(b->imag, SignBase);
					SignBase = exp_adj(c->real, SignBase);
					SignBase = exp_adj(c->imag, SignBase);
					SignBase = exp_adj(d->real, SignBase);
					SignBase = exp_adj(d->imag, SignBase);
					a += S;
					b += S;
					c += S;
					d += S; //Upper-N/2

					SignBase = btr_fly_r4(w, x, y, z, SignBase);
					x[0] = complex_mul(x[0], xrxi);
					y[0] = complex_mul(y[0], yryi);
					z[0] = complex_mul(z[0], zrzi);
					SignBase = exp_adj(x->real, SignBase);
					SignBase = exp_adj(x->imag, SignBase);
					SignBase = exp_adj(y->real, SignBase);
					SignBase = exp_adj(y->imag, SignBase);
					SignBase = exp_adj(z->real, SignBase);
					SignBase = exp_adj(z->imag, SignBase);
					w += S;
					x += S;
					y += S;
					z += S; //Lower-N/2

				} while (++j < R);
			} while (++i < S / 4);
			S /= 4;
			R *= 4;
			if (m != stages / 2 - 1) { //last-stage?
				i = 0; //y[n*R+m]=x[r*S+s]*W((n*R+m)*(r*S+s))=(u(s,m)=sum_{r}x[(r=[0:R-1])*S+s]*W(r*m,R))
				do {
					switch (SignBase) { //u(s=[0:S-1],m=[0:R-1]),u(m*S+s),u(s*R+m)*W(s*m,N)=v(s,m)*W(s*n,S)
					case 0:
						frfi[i].real = L_add(frfi[i].real * 4096, 0x4000) >> 15;
						frfi[i].imag = L_add(frfi[i].imag * 4096, 0x4000) >> 15;
						break;
					case -1:
						frfi[i].real = L_add(frfi[i].real * 8192, 0x4000) >> 15;
						frfi[i].imag = L_add(frfi[i].imag * 8192, 0x4000) >> 15;
						break;
					case -2:
						frfi[i].real = L_add(frfi[i].real * 16384, 0x4000)
								>> 15;
						frfi[i].imag = L_add(frfi[i].imag * 16384, 0x4000)
								>> 15;
						break;
					default:
						assert(SignBase < -2);
						break;
					}

				} while (++i < n);
				Blk_Exponent += (SignBase + 3);
			}
		} while (++m < stages / 2);
		stages += 1;

	} else {
		S = n;
		i = 0;
		SignBase = -3;
		do {
			SignBase = exp_adj((frfi + i)->real, SignBase);
			SignBase = exp_adj((frfi + i)->imag, SignBase);
		} while (++i < S);
		i = 0;
		do {
			switch (SignBase) {
			case 0:
				frfi[i].real = L_add(frfi[i].real * 4096, 0x4000) >> 15;
				frfi[i].imag = L_add(frfi[i].imag * 4096, 0x4000) >> 15;
				break;
			case -1:
				frfi[i].real = L_add(frfi[i].real * 8192, 0x4000) >> 15;
				frfi[i].imag = L_add(frfi[i].imag * 8192, 0x4000) >> 15;
				break;
			case -2:
				frfi[i].real = L_add(frfi[i].real * 16384, 0x4000) >> 15;
				frfi[i].imag = L_add(frfi[i].imag * 16384, 0x4000) >> 15;
				break;
			default:
				assert(SignBase < -2);
				break;
			}
		} while (++i < S);
		Blk_Exponent += SignBase + 3;
		m = 0;
		do {
			i = 0; //s=0:N/4-1
			SignBase = -3;
			do {
				s = i << k;
				a = frfi + i;
				b = a + S / 4;
				c = b + S / 4;
				d = c + S / 4;
				xrxi.real = kSinTable1024[(256 + 2 * s * R) & 0x3ff];
				xrxi.imag = -kSinTable1024[2 * s * R];
				yryi.real = kSinTable1024[(256 + s * R) & 0x3ff];
				yryi.imag = -kSinTable1024[s * R];
				zrzi.real = kSinTable1024[(256 + 3 * s * R) & 0x3ff];
				zrzi.imag = -kSinTable1024[3 * s * R];
				j = 0;
				do {
					SignBase = btr_fly_r4(a, b, c, d, SignBase);
					b[0] = complex_mul(b[0], xrxi);
					c[0] = complex_mul(c[0], yryi);
					d[0] = complex_mul(d[0], zrzi);
					SignBase = exp_adj(b->real, SignBase);
					SignBase = exp_adj(b->imag, SignBase);
					SignBase = exp_adj(c->real, SignBase);
					SignBase = exp_adj(c->imag, SignBase);
					SignBase = exp_adj(d->real, SignBase);
					SignBase = exp_adj(d->imag, SignBase);
					a += S;
					b += S;
					c += S;
					d += S;
				} while (++j < R);
			} while (++i < S / 4);

			if (m != stages / 2 - 1) {
				i = 0;
				do {
					switch (SignBase) {
					case 0:
						frfi[i].real = L_add(frfi[i].real * 4096, 0x4000) >> 15;
						frfi[i].imag = L_add(frfi[i].imag * 4096, 0x4000) >> 15;
						break;
					case -1:
						frfi[i].real = L_add(frfi[i].real * 8192, 0x4000) >> 15;
						frfi[i].imag = L_add(frfi[i].imag * 8192, 0x4000) >> 15;
						break;
					case -2:
						frfi[i].real = L_add(frfi[i].real * 16384, 0x4000)
								>> 15;
						frfi[i].imag = L_add(frfi[i].imag * 16384, 0x4000)
								>> 15;
						break;
					default:
						assert(SignBase < -2);
						break;
					}
				} while (++i < n);
				Blk_Exponent += SignBase + 3;
			}
			R *= 4;
			S /= 4;
		} while (++m < stages / 2);
	}
	for (i = 0; i < n; i += 1) {
		UWord32 register s = i;
		s = permutate(s, 0);
		s = permutate(s, 1);
		s = permutate(s, 2);
		s = permutate(s, 3);
		s = permutate(s, 4);
		s >>= (32 - stages);
		if (s > i)
			swap_data(&frfi[i], &frfi[s]);
	}

	return (Blk_Exponent);
}

Word32 Real_FFT(ComplexInt16 *RealDataIn, Word32 Order) {
	Word32 Blk_Exponent;
	Word32 N = 1 << (Order - 1); //x[r*S+s]*W((r*S+s)*k,N)=x[r*S+s]*W(r*k,R)*W(s*k,N)
	Word32 i, k; //sum_{r=[0:1:N/2-1]}x[r*(S=2)+s]*W(r*k,R)=sum_{s=[0:1]}u(s,k)*W(s*k,N)
#if defined(__GNUC__)
	ComplexInt16 *buffer = __builtin_alloca_with_align(N * sizeof(ComplexInt16),
			32);
#else
	ComplexInt16 buffer[1<<(kMaxFFTOrder-1)];
#endif
	ComplexInt16 a, b;
	ComplexInt16 wrwi;

	k = 10 - Order;
	i = 0;
	do {
		(buffer + i)->real = L_add(RealDataIn[i].real * 16384, 0x4000) >> 15;
		(buffer + i)->imag = L_add(RealDataIn[i].imag * 16384, 0x4000) >> 15;
	} while (++i < N);

	Blk_Exponent = Complex_FFT(buffer, Order - 1);
	i = 0;
	do {
		Word32 register L_var_out;
		Word32 register s = i << k;
		a = complex_add(buffer[i], complex_conj(buffer[(N - i) & (N - 1)]));
		b = complex_swap(
				complex_sub(buffer[i],
						complex_conj(buffer[(N - i) & (N - 1)])));
		a = complex_asr(a, 1);
		b = complex_asr(b, 1);

		if (i) {
			wrwi.real = kSinTable1024[(256 + s) & 0x3ff];
			wrwi.imag = -kSinTable1024[s];
			RealDataIn[i] = complex_add(a, complex_mul(b, wrwi));
		} else {
			L_var_out = L_sub(a.real << 16, b.real << 16);
			RealDataIn->imag = L_var_out >> 16;
			L_var_out = L_add(a.real << 16, b.real << 16);
			RealDataIn->real = L_var_out >> 16;
		}
	} while (++i < N);

	return (Blk_Exponent + 1);
}

void HS_IFFT(ComplexInt16 *complex_data_in, Word16 *real_data_out, Word32 Order) {
	Word32 Blk_Exponent;
	Word32 i, k, s;
	Word32 N = 1 << (Order - 1);
	ComplexInt16 wrwi;
#if defined(__GNUC__)
	ComplexInt16 *Zk = __builtin_alloca_with_align(N * sizeof(ComplexInt16),
			32);
#else
	ComplexInt16 Zk[1<<(kMaxFFTOrder-1)];
#endif

	k = 10 - Order;
	i = N - 1;
	do {
		ComplexInt16 a, b;
		if (i) {
			s = i << k;
			a = complex_add(complex_asr(complex_data_in[i], 1),
					complex_conj(complex_asr(complex_data_in[N - i], 1)));
			b = complex_sub(complex_asr(complex_data_in[i], 1),
					complex_conj(complex_asr(complex_data_in[N - i], 1)));
			wrwi.real = kSinTable1024[(256 + s) & 0x3ff];
			wrwi.imag = kSinTable1024[s];
			b = complex_mul(b, wrwi);
		} else {
			Word32 register L_var_out;
			L_var_out = L_add(complex_data_in->real << 15,
					complex_data_in->imag << 15);
			a.real = L_var_out >> 16;
			a.imag = 0;
			L_var_out = L_sub(complex_data_in->real << 15,
					complex_data_in->imag << 15);
			b.real = L_var_out >> 16;
			b.imag = 0;
		}
		Zk[i] = complex_conj(
				complex_sub(complex_asr(a, 1),
						complex_asr(complex_swap(b), 1)));

	} while (--i >= 0);

	Blk_Exponent = Complex_FFT(Zk, Order - 1);
	i = N - 1;
	do {
		Zk[i] = complex_asr(complex_conj(Zk[i]), Order - 2 - Blk_Exponent);
	} while (--i >= 0);
	memmove(real_data_out, Zk, sizeof(Word16) * (1 << Order));
}

void NoiseSuppression(nr_state *Inst, ComplexInt16 *Sin, Word32 blk_exponent) {
	static Word16 qDomainOld[PartLen1] = { 0 };
	static Word16 qDomainSmin[PartLen1] = { 0 };
	static Word16 qDomainSminSw[PartLen1] = { 0 };
	static Word16 qDomainStilt[PartLen1] = { 0 };
	static Word16 qDomainStiltMin[PartLen1] = { 0 };
	static Word16 qDomainStiltMinSw[PartLen1] = { 0 };
	static Word16 qDomainLambda[PartLen1] = { 0 };

	Word16 SPLSubBandCntroids;
	Word16 Idx[PartLen1] = { 0 };
	Word16 q[PartLen1] = { 0 };
	Word16 *ptrdfaClean;

	void *Out = Sin;
	Word32 supGain = 1;
	Word32 const kAlpha = 32256; // Wind Noise Reduced
	Word32 const kxi_min = 1036;
	Word32 const kalpha_s = 3277;
	Word32 const kbeta = 24084;
	Word32 const kBmin = 19739;
	Word32 const kzeta0 = 54723;
	Word32 const kgamma1 = 98304;
	Word32 const kgamma1MinusOne = 16384;
	Word32 const kalpha_d = 27853;
	Word32 const kalphaMin = 819;
	Word32 const kalphaMax = 31949;

	Word32 i;
	Word32 tmp32no1;
	Word32 tmp32no2;
	Word32 tmp32no3;
	Word32 zeros32 = 0;
	Word32 sobel[PartLen1] = { 0 };

	Word64 tmp64no1;
	Word64 tmp64no2;
	Word64 tmp64no3;
	Word64 ps[PartLen1];
	Word64 xpros[PartLen1] = { 0 };
	Word64 auditory_mask[PartLen1] = { 0 };

	if (Wind_Mode == Inst->mode) {
		memmove(Inst->bufferGamma[0], Inst->bufferGamma[1],
				sizeof(Word32) * PartLen1);
		memmove(Inst->bufferGamma[1], Inst->bufferGamma[2],
				sizeof(Word32) * PartLen1);
	}
	tmp32no1 = lsl(Sin->real, blk_exponent);

	for (i = 1; i < PartLen; i += 1) {
		Word32 register gamma; // posteriori SNR

		tmp64no1 = SMULL((Sin + i)->real, (Sin + i)->real);
		tmp64no1 = SMLAL(tmp64no1, (Sin + i)->imag, (Sin + i)->imag);
		ps[i] = tmp64no1 <<= 2 * blk_exponent;
		tmp32no1 = lsl(Sin[i].real, blk_exponent);
		tmp32no2 = lsl(Sin[i].imag, blk_exponent);

		if (Inst->nrStartup) {
			tmp32no1 = CLZ64(tmp64no1); // norm(|Y(n,k)|.^2)
			tmp32no2 = CLZ64(tmp64no2 = max(Inst->lambda[i], 1uLL));
			if (tmp32no1 < 15) { // |Y(n,k)|.^2/beta
				tmp64no1 >>= 15;
				tmp64no1 *= Inst->beta;
			} else {
				tmp64no1 *= Inst->beta;
				tmp64no1 >>= 15;
			}
			tmp32no1 = CLZ64(tmp64no1);
			tmp32no1 = (tmp32no1 > 0) ? tmp32no1 - 1 : 0;
			tmp32no2 = (tmp32no2 > 0) ? tmp32no2 - 1 : 0;
			tmp64no1 <<= tmp32no1;
			tmp64no2 <<= tmp32no2;
			if (tmp64no1 > tmp64no2) {
				tmp64no1 -= tmp64no2;
				gamma = udiv_128_64(tmp64no2, tmp64no1);
				gamma += 32767;
			} else {
				gamma = udiv_128_64(tmp64no2, tmp64no1);
			}
			if (Inst->mode != Wind_Mode) {
				gamma = min(asr(gamma, tmp32no1 - tmp32no2 - qDomainLambda[i]),
						0x400000uL);
			} else {
				gamma = asr(gamma, tmp32no1 - tmp32no2 - qDomainLambda[i]);
			}

		} else {
			gamma = 32767; //@q15
			Inst->lambda[i] = tmp64no1;
		}

		Inst->bufferGamma[2][i] = gamma;

		tmp32no1 = L_mult(Inst->Gh1[i], Inst->Gh1[i]) >> 16;
		tmp64no1 = (Word64) Inst->gamma_prev[i] * tmp32no1 >> 15;
		tmp32no2 = CLZ64(tmp64no1); //aa*Gh1.^2.*|Y(n,k)|.^2./lambda(n,k)
		if (tmp32no2 < 15) {
			tmp64no1 >>= 15;
			tmp64no1 *= kAlpha;
		} else {
			tmp64no1 *= kAlpha;
			tmp64no1 >>= 15;
		}
		tmp64no3 = tmp64no2 = max(gamma - 32767, 0); // max(post-snr(n,k)-1,0)
		tmp32no2 = CLZ64(tmp64no2);
		if (tmp32no2 < 15) {
			tmp64no2 >>= 15;
			tmp64no2 *= kAlpha;
		} else {
			tmp64no2 *= kAlpha;
			tmp64no2 >>= 15;
		}
		tmp64no3 -= tmp64no2;
		tmp64no1 += tmp64no3; // Decision Directive a-priori SNR
		tmp64no1 = Inst->xi[i] = max(tmp64no1, kxi_min); //@q15
		Inst->gamma_prev[i] = gamma;
		tmp32no1 = CLZ64(tmp64no1);
		tmp32no2 = CLZ64(tmp64no2 = tmp64no1 + 32768);
		tmp32no1 = (tmp32no1 > 0) ? tmp32no1 - 1 : 0;
		tmp32no2 = (tmp32no2 > 0) ? tmp32no2 - 1 : 0;
		tmp64no1 <<= tmp32no1;
		tmp64no2 <<= tmp32no2;
		tmp64no1 = udiv_128_64(tmp64no2, tmp64no1);
		Inst->Gh1[i] = tmp64no1 = asr(tmp64no1, tmp32no1 - tmp32no2);
	}
	tmp64no1 = SMULL(Sin->real, Sin->real);
	ps[0] = tmp64no1 << 2 * blk_exponent;
	tmp64no1 = SMULL(Sin->imag, Sin->imag);
	ps[PartLen] = tmp64no1 << 2 * blk_exponent;
	tmp32no1 = lsl(Sin->imag, blk_exponent);

	for (i = 1; i < PartLen; i += 1) {
		Word32 register qDomainDiff;
		Word32 register qDomain;

		tmp64no1 = ps[i - 1] >> 2;
		tmp64no1 += ps[i] >> 1;
		tmp64no1 += ps[i + 1] >> 2;
		if (Inst->nrStartup) {
			tmp32no1 = CLZ64(tmp64no1);
			tmp32no1 = (tmp32no1 > 0) ? tmp32no1 - 1 : 0;
			tmp32no2 = qDomainOld[i];
			if (tmp32no2 < tmp32no1) {
				tmp64no1 <<= tmp32no2;
				tmp32no3 = CLZ64(
						llabs(tmp64no3 = (tmp64no2 = Inst->S[i]) - tmp64no1));
				if (tmp32no3 < 12) {
					tmp64no3 >>= 15;
					tmp64no3 *= kalpha_s;
				} else {
					tmp64no3 *= kalpha_s;
					tmp64no3 >>= 15;
				}
				qDomain = tmp32no2;
				tmp64no2 -= tmp64no3;

			} else {
				qDomainDiff = tmp32no2 - tmp32no1;
				tmp64no2 = Inst->S[i];
				tmp64no1 <<= tmp32no1;
				tmp64no2 >>= qDomainDiff;
				tmp32no3 = CLZ64(llabs(tmp64no3 = tmp64no2 - tmp64no1));
				if (tmp32no3 < 12) {
					tmp64no3 >>= 15;
					tmp64no3 *= kalpha_s;
				} else {
					tmp64no3 *= kalpha_s;
					tmp64no3 >>= 15;
				}
				qDomain = tmp32no1;
				tmp64no2 -= tmp64no3;
			}
			tmp32no1 = CLZ64(tmp64no2);
			tmp32no1 = (tmp32no1 > 0) ? tmp32no1 - 1 : 0;
			tmp64no2 <<= tmp32no1;
			qDomainOld[i] = qDomain + tmp32no1;

			Inst->S[i] = tmp64no2;
			if ((Inst->Smin[i] >> qDomainSmin[i])
					> (Inst->S[i] >> qDomainOld[i])) {
				Inst->Smin[i] = Inst->S[i];
				qDomainSmin[i] = qDomainOld[i];
			}

			if ((Inst->Smin_sw[i] >> qDomainSminSw[i])
					> (Inst->S[i] >> qDomainOld[i])) {
				Inst->Smin_sw[i] = Inst->S[i];
				qDomainSminSw[i] = qDomainOld[i];
			}

		} else {
			Inst->S[i] = tmp64no1;
			Inst->Smin[i] = tmp64no1;
			Inst->Smin_sw[i] = tmp64no1;
			qDomainOld[i] = 0;
			qDomainSmin[i] = 0;
			qDomainSminSw[i] = 0;
		}
		//tmp64no1 = ps[i];
	}
	for (i = 1; i < PartLen; i += 1) {
		Word32 gamma_min;
		Word32 zeta_min;

		tmp32no1 = CLZ64(tmp64no1 = ps[i]);
		tmp32no2 = CLZ64(tmp64no2 = max(1uLL, Inst->Smin[i]));
		if (tmp32no1 < 15) {
			tmp64no1 >>= 15;
			tmp64no1 *= kBmin;
		} else {
			tmp64no1 *= kBmin;
			tmp64no1 >>= 15;
		}
		tmp32no1 = CLZ64(tmp64no1);
		tmp32no1 = (tmp32no1 > 0) ? tmp32no1 - 1 : 0;
		tmp32no2 = (tmp32no2 > 0) ? tmp32no2 - 1 : 0;
		tmp64no1 <<= tmp32no1;
		tmp64no2 <<= tmp32no2;
		if (tmp64no1 > tmp64no2) {
			tmp64no1 -= tmp64no2;
			tmp64no1 = udiv_128_64(tmp64no2, tmp64no1);
			tmp64no1 += 32767;
		} else {
			tmp64no1 = udiv_128_64(tmp64no2, tmp64no1);
		}
		gamma_min = asr(tmp64no1, tmp32no1 - tmp32no2 - qDomainSmin[i]);

		tmp32no1 = CLZ64(tmp64no1 = Inst->S[i]);
		if (tmp32no1 < 15) {
			tmp64no1 >>= 15;
			tmp64no1 *= kBmin;
		} else {
			tmp64no1 *= kBmin;
			tmp64no1 >>= 15;
		}
		tmp32no1 = CLZ64(tmp64no1);
		tmp32no1 = (tmp32no1 > 0) ? tmp32no1 - 1 : 0;
		tmp64no1 <<= tmp32no1;
		if (tmp64no1 > tmp64no2) {
			tmp64no1 -= tmp64no2;
			tmp64no1 = udiv_128_64(tmp64no2, tmp64no1);
			tmp64no1 += 32767;
		} else {
			tmp64no1 = udiv_128_64(tmp64no2, tmp64no1);
		}
		zeta_min = asr(tmp64no1,
				qDomainOld[i] + tmp32no1 - tmp32no2 - qDomainSmin[i]);

		Idx[i] = (gamma_min < 150733 && zeta_min < 54723) ? 1 : 0;
	}
	for (i = 1; i < PartLen; i += 1) {
		Word32 register qDomainDiff;
		Word32 register qDomain;

		tmp32no1 = (Idx[i - 1]) ? 8192 : 0;
		tmp32no1 += (Idx[i]) ? 16384 : 0;
		tmp32no1 += (Idx[i + 1]) ? 8192 : 0;
		if (Inst->nrStartup) {
			if (tmp32no1) { // Idx[i]~=0
				tmp64no1 = (Idx[i - 1]) ? ps[i - 1] >> 2 : 0;
				tmp64no1 += (Idx[i]) ? ps[i] >> 1 : 0;
				tmp64no1 += (Idx[i + 1]) ? ps[i + 1] >> 2 : 0;
				/*S_tilt[k]=alpha*S_tilt[k]+(1-alpha)*(Sf_tilt[k]/(0.25*Idx[k-1]+0.5*Idx[k]+0.25*Idx[k+1]))*/

				switch (tmp32no1) {
				case 8192: // *4
					tmp64no1 <<= 2;
					break;
				case 16384: // *2
					tmp64no1 <<= 1;
					break;
				case 24576: // *1/(0.75)
					tmp64no1 *= 21845;
					tmp64no1 >>= 14;
					break;
				}
				tmp32no1 = CLZ64(tmp64no1); // Sf_tilt
				tmp32no1 = (tmp32no1 > 0) ? tmp32no1 - 1 : 0;
				tmp32no2 = qDomainStilt[i];
				tmp64no2 = Inst->S_tilt[i];
				if (tmp32no1 < tmp32no2) {
					qDomainDiff = tmp32no2 - tmp32no1;
					tmp64no1 <<= tmp32no1;
					tmp64no2 >>= qDomainDiff;
					tmp32no3 = CLZ64(llabs(tmp64no3 = tmp64no2 - tmp64no1));
					if (tmp32no3 < 12) {
						tmp64no3 >>= 15;
						tmp64no3 *= kalpha_s;
					} else {
						tmp64no3 *= kalpha_s;
						tmp64no3 >>= 15;
					}
					qDomain = tmp32no1;
				} else {
					tmp64no1 <<= tmp32no2;
					tmp32no3 = CLZ64(llabs(tmp64no3 = tmp64no2 - tmp64no1));
					if (tmp32no3 < 12) {
						tmp64no3 >>= 15;
						tmp64no3 *= kalpha_s;
					} else {
						tmp64no3 *= kalpha_s;
						tmp64no3 >>= 15;
					}
					qDomain = tmp32no2;
				}
				tmp64no2 -= tmp64no3;
				tmp32no1 = CLZ64(tmp64no2);
				tmp32no1 = (tmp32no1 > 0) ? tmp32no1 - 1 : 0;
				Inst->S_tilt[i] = tmp64no2 <<= tmp32no1;
				qDomainStilt[i] = qDomain + tmp32no1;
				if ((tmp64no1 = Inst->S_tilt[i]) >> qDomainStilt[i]
						< Inst->Smin_tilt[i] >> qDomainStiltMin[i]) {
					Inst->Smin_tilt[i] = tmp64no1;
					qDomainStiltMin[i] = qDomainStilt[i];
				}

				if (tmp64no1 >> qDomainStilt[i]
						< Inst->Smin_sw_tilt[i] >> qDomainStiltMinSw[i]) {
					Inst->Smin_sw_tilt[i] = tmp64no1;
					qDomainStiltMinSw[i] = qDomainStilt[i];
				}
			}
		} else {
			Inst->S_tilt[i] = Inst->S[i];
			Inst->Smin_tilt[i] = Inst->S[i];
			Inst->Smin_sw_tilt[i] = Inst->S[i];
			qDomainStilt[i] = 0;
			qDomainStiltMin[i] = 0;
			qDomainStiltMinSw[i] = 0;
		}

		//tmp64no1 = Inst->S_tilt[i] >> qDomainStilt[i];
		//tmp64no1 = Inst->Smin_tilt[i] >> qDomainStiltMin[i];
		//tmp64no1 = Inst->Smin_sw_tilt[i] >> qDomainStiltMinSw[i];
	}

	for (i = 1; i < PartLen; i += 1) {
		Word32 register gammaMin;
		Word32 register zetaMin;

		tmp32no1 = CLZ64(tmp64no1 = ps[i]);
		if (tmp32no1 < 15) {
			tmp64no1 >>= 15;
			tmp64no1 *= kBmin;
		} else {
			tmp64no1 *= kBmin;
			tmp64no1 >>= 15;
		}
		tmp32no1 = CLZ64(tmp64no1);
		tmp32no1 = (tmp32no1 > 0) ? tmp32no1 - 1 : 0;
		tmp32no2 = CLZ64(tmp64no2 = max(Inst->Smin_tilt[i], 1uLL));
		tmp32no2 = (tmp32no2 > 0) ? tmp32no2 - 1 : 0;
		tmp64no1 <<= tmp32no1;
		tmp64no2 <<= tmp32no2;
		if (tmp64no1 > tmp64no2) {
			tmp64no1 -= tmp64no2;
			tmp64no1 = udiv_128_64(tmp64no2, tmp64no1);
			tmp64no1 += 32767;
		} else {
			tmp64no1 = udiv_128_64(tmp64no2, tmp64no1);
		}
		tmp64no1 = gammaMin = asr(tmp64no1,
				tmp32no1 - tmp32no2 - qDomainStiltMin[i]);

		tmp32no1 = CLZ64(tmp64no1 = Inst->S[i]);
		if (tmp32no1 < 15) {
			tmp64no1 >>= 15;
			tmp64no1 *= kBmin;
		} else {
			tmp64no1 *= kBmin;
			tmp64no1 >>= 15;
		}
		tmp32no1 = CLZ64(tmp64no1);
		tmp32no1 = (tmp32no1 > 0) ? tmp32no1 - 1 : 0;
		tmp64no1 <<= tmp32no1;
		if (tmp64no1 > tmp64no2) {
			tmp64no1 -= tmp64no2;
			tmp64no1 = udiv_128_64(tmp64no2, tmp64no1);
			tmp64no1 += 32767;
		} else {
			tmp64no1 = udiv_128_64(tmp64no2, tmp64no1);
		}
		tmp64no1 = zetaMin = asr(tmp64no1,
				qDomainOld[i] + tmp32no1 - tmp32no2 - qDomainStiltMin[i]);
		if (zetaMin < kzeta0) {
			if (gammaMin <= 32768) {
				q[i] = 32767;
			} else if (gammaMin < kgamma1) {
				tmp32no1 = kgamma1 - gammaMin; // r1-r(k,l)
				q[i] = SMULL(tmp32no1, kgamma1MinusOne) >> 15;
			}
		}
	}

	for (i = 1; i < PartLen; i += 1) {
		Word32 register hnl;
		Word32 register p; // posterior,p(H1|Y(n,k))
		Word32 register qDomain;
		Word32 register qDomainDiff;
		Word32 register kalphaD;
		Word32 register zeros16;
		//float TmpFloatNo1;

		p = tmp32no1 = 32767 - q[i]; // p,simplified
		tmp32no2 = q[i] * kalpha_d >> 15;
		kalphaD = tmp32no1 += tmp32no2; // p+(1-p)*alpha
		zeros16 = CLZ(kalphaD);
		tmp32no2 = qDomainLambda[i]; // q2
		tmp32no1 = CLZ64(tmp64no1 = ps[i]);
		tmp32no1 = (tmp32no1 > 0) ? tmp32no1 - 1 : 0; // q1
		tmp64no3 = Inst->lambda[i]; // 2^q2
#if 1
		if (tmp32no1 > tmp32no2) {
			tmp64no1 <<= tmp32no2; // ps[i]*2^q2
			tmp32no3 = CLZ64(llabs(tmp64no2 = tmp64no3 - tmp64no1));

			if (zeros16 + tmp32no3 < 31) {
				tmp64no2 >>= 15;
				tmp64no2 *= kalphaD;
			} else {
				tmp64no2 *= kalphaD;
				tmp64no2 >>= 15;
			}
			tmp64no1 += tmp64no2;
			qDomain = tmp32no2;
		} else {
			tmp64no1 <<= tmp32no1;
			qDomainDiff = tmp32no2 - tmp32no1;
			tmp64no3 >>= qDomainDiff;
			tmp32no3 = CLZ64(llabs(tmp64no2 = tmp64no3 - tmp64no1));
			if (zeros16 + tmp32no3 < 31) {
				tmp64no2 >>= 15;
				tmp64no2 *= kalphaD;
			} else {
				tmp64no2 *= kalphaD;
				tmp64no2 >>= 15;
			}
			tmp64no1 += tmp64no2;
			qDomain = tmp32no1;
		}

		tmp32no1 = CLZ64(tmp64no1);
		tmp32no1 = (tmp32no1 > 0) ? tmp32no1 - 1 : 0;
		tmp64no1 <<= tmp32no1;
		Inst->lambda[i] = tmp64no1;
		tmp64no1 >>= qDomainLambda[i] = tmp32no1 + qDomain;
#else
		TmpFloatNo1 = tmp64no3 * kalphaD;
		TmpFloatNo1 += (32768.f - kalphaD) * ps[i];
		TmpFloatNo1 /= 32768.f;
		Inst->lambda[i] = TmpFloatNo1;

#endif
		hnl = (Word64) Inst->Gh1[i] * p >> 15; // with hypothesis
		tmp32no2 = L_mult(hnl, Sin[i].real) >> 16;
		tmp32no3 = L_mult(hnl, Sin[i].imag) >> 16;
		if (Wind_Mode == Inst->mode) {
			((ComplexInt16*) Out + i)->real = tmp32no2;
			((ComplexInt16*) Out + i)->imag = tmp32no3;
		}
		tmp64no1 = SMULL(tmp32no2, tmp32no2);
		tmp64no1 = SMLAL(tmp64no1, tmp32no3, tmp32no3);
		xpros[i] = tmp64no1 << 2 * blk_exponent;
	}
	xpros[0] = 0;
	xpros[PartLen] = 0;

	MaskThresholds(xpros, auditory_mask, NFFT, CB_FREQ_INDICES_256);

	for (i = 1; i < PartLen; i += 1) {
		Word32 register hnl; // Hnl[n,k]=sqrt(Mask/Lambda)
		tmp32no1 = CLZ64(tmp64no1 = auditory_mask[i]);
		tmp32no1 = (tmp32no1 > 0) ? tmp32no1 - 1 : 0;
		tmp32no2 = CLZ64(tmp64no2 = max(Inst->lambda[i], 1uLL));
		tmp32no2 = (tmp32no2 > 0) ? tmp32no2 - 1 : 0;
		tmp64no1 <<= tmp32no1;
		tmp64no2 <<= tmp32no2;
		if (tmp64no1 > tmp64no2) {
			tmp64no1 -= tmp64no2;
			tmp64no1 = udiv_128_64(tmp64no2, tmp64no1);
			tmp64no1 += 32767;
		} else {
			tmp64no1 = udiv_128_64(tmp64no2, tmp64no1);
		}
		tmp32no1 = asr(tmp64no1, tmp32no1 - tmp32no2 - qDomainLambda[i]); //@q15
		hnl = min(usqrt((UWord32 )tmp32no1 << 1), 255);
		if (Inst->mode != Wind_Mode) {
			((ComplexInt16*) Out + i)->real = hnl * (Sin + i)->real >> 8;
			((ComplexInt16*) Out + i)->imag = hnl * (Sin + i)->imag >> 8;
		}
	}

	if (Wind_Mode == Inst->mode) {
		ptrdfaClean = (Word16*) ((char*) Out + 4); //dc,nyquists
		for (i = 1; i < PartLen; i += 1) {
			tmp32no1 = Inst->bufferGamma[2][i - 1] >> 2;
			tmp32no1 += Inst->bufferGamma[2][i] >> 1;
			tmp32no1 += Inst->bufferGamma[2][i + 1] >> 2;
			tmp32no1 -= Inst->bufferGamma[0][i - 1] >> 2;
			tmp32no1 -= Inst->bufferGamma[0][i] >> 1;
			sobel[i] = tmp32no1 -= Inst->bufferGamma[0][i + 1] >> 2; //Difference
			tmp32no1 = L_mult(ptrdfaClean[0], ptrdfaClean[0]);
			tmp32no1 = L_mac(tmp32no1, ptrdfaClean[1], ptrdfaClean[1]);
			tmp64no1 = (Word64) tmp32no1 << 2 * blk_exponent;
			Inst->Sxx[i] = tmp64no1 >>= 1;
			tmp64no2 = Inst->lambda[i] >> qDomainLambda[i];
			tmp32no1 = CLZ64(tmp64no2);
			if (tmp32no1 > 15) {
				tmp64no2 *= kbeta;
				tmp64no2 >>= 14;
			} else {
				tmp64no2 >>= 14;
				tmp64no2 *= kbeta;
			}
			tmp64no1 = max(1uLL, tmp64no1);
			tmp64no2 = max(1uLL, tmp64no2);

			Inst->mEdge[i] = (sobel[i] > 0) ? 1 : 0;
			ptrdfaClean += 2;
		}

		for (i = 1; i < PartLen; i += 1) {
			Inst->mOnSet[i] = Inst->mEdge[i]
					& ((Inst->mOnSet[i - 1]) || (Inst->mOnSet[i]) || (i < 8));
		}

		for (i = 1; i < PartLen; i += 1) {
			Inst->mInterFere[i] = Inst->mOnSet[i]
					& ((Inst->mInterFere[i - 1]) || (i < 8));
		}

		for (i = 1; i < PartLen; i += 1) {
			Inst->Nxx[i] =
					(Inst->mInterFere[i]) ?
							Inst->Sxx[i] : min(Inst->Nxx[i], Inst->Sxx[i]);
		}

#if 0
		tmp64no1 = 0;
		tmp64no2 = 0;
		for (i = 1; i < 97; i += 1) { // Spectral Subband Centroids, 0-3000Hz
			tmp64no1 += Inst->Sxx[i] * i;
			tmp64no2 += Inst->Sxx[i];
		}

		tmp32no1 = CLZ64(tmp64no1);
		tmp32no1 = (tmp32no1 > 0) ? tmp32no1 - 1 : 0;
		tmp32no2 = CLZ64(tmp64no2 = max(tmp64no2, 1uLL));
		tmp32no2 = (tmp32no2 > 0) ? tmp32no2 - 1 : 0;
		tmp64no1 <<= tmp32no1;
		tmp64no2 <<= tmp32no2;
		if (tmp64no1 > tmp64no2) {
			tmp64no1 -= tmp64no2;
			tmp64no1 = udiv_128_64(tmp64no2, tmp64no1);
			tmp64no1 += 32767;
		} else {
			tmp64no1 = udiv_128_64(tmp64no2, tmp64no1);
		}
		tmp64no1 = asr(tmp64no1, tmp32no1 - tmp32no2);
		tmp64no1 *= 8000; // *Fs/256
		SPLSubBandCntroids = tmp64no1 >>= 23;

		for (i = 1; i < PartLen; i += 1) {
			if (SPLSubBandCntroids < 200) { // Likely pure WindNoise
				tmp64no3 = (tmp64no2 = Inst->Nxx[i]) - ps[i];
				tmp32no1 = CLZ64(llabs(tmp64no3));
				if (tmp32no1 < 16) {
					tmp64no3 >>= 15;
					tmp64no3 *= kalphaMax;
				} else {
					tmp64no3 *= kalphaMax;
					tmp64no3 >>= 15;
				}
				Inst->Nxx[i] = tmp64no2 -= tmp64no3;
				supGain = 2;
			} else if (SPLSubBandCntroids > 600) { // Likely pure Speech
				tmp64no3 = (tmp64no2 = Inst->Nxx[i]);
				tmp32no1 = CLZ64(llabs(tmp64no3));
				if (tmp32no1 < 11) {
					tmp64no3 >>= 15;
					tmp64no3 *= kalphaMin;
				} else {
					tmp64no3 *= kalphaMin;
					tmp64no3 >>= 15;
				}
				Inst->Nxx[i] = tmp64no2 -= tmp64no3;
				supGain = 0;
			} else {
				supGain = 1;
			}
		}
#endif
		for (i = 1; i < PartLen; i += 1) {

			tmp64no1 = usqrt_ll(Inst->Nxx[i]);
			tmp64no2 = usqrt_ll(Inst->Sxx[i]);
			tmp32no1 = CLZ64(tmp64no1 *= supGain);
			tmp32no2 = CLZ64(tmp64no2 = max(1uLL, tmp64no2));
			tmp32no1 = (tmp32no1 > 0) ? tmp32no1 - 1 : 0;
			tmp32no2 = (tmp32no2 > 0) ? tmp32no2 - 1 : 0;
			tmp64no1 <<= tmp32no1;
			tmp64no2 <<= tmp32no2;
			if (tmp64no1 > tmp64no2) {
				tmp64no1 -= tmp64no2;
				tmp32no3 = udiv_128_64(tmp64no2, tmp64no1);
				tmp32no3 += 32767;
			} else {
				tmp32no3 = udiv_128_64(tmp64no2, tmp64no1);
			}
			tmp32no3 = asr(tmp32no3, tmp32no1 - tmp32no2);
			tmp32no3 = max(0x3f, 32767 - tmp32no3); //max(0,1-supGain*Nxx(n,k)/Sxx(n,k))
			/*((ComplexInt16*) Out + i)->real = L_mult(Sin[i].real, tmp32no3)
			 >> 16;
			 ((ComplexInt16*) Out + i)->imag = L_mult(Sin[i].imag, tmp32no3)
			 >> 16;*/
		}
	}

	if (!Inst->cntr) { // 2 blocks of Minimum
		for (i = 1; i < PartLen; i += 1) {
			Inst->Smin[i] = Inst->Smin_sw[i];
			qDomainSmin[i] = qDomainSminSw[i];
			Inst->Smin_sw[i] = Inst->S[i];
			qDomainSminSw[i] = qDomainOld[i];
			Inst->Smin_tilt[i] = Inst->Smin_sw_tilt[i];
			qDomainStiltMin[i] = qDomainStiltMinSw[i];
			Inst->Smin_sw_tilt[i] = Inst->S_tilt[i];
			qDomainStiltMinSw[i] = qDomainStilt[i];
		}
	}

	Inst->nrStartup |= 1;
	Inst->cntr += 1;
	Inst->cntr &= (V_Size - 1);
}

#if !defined(__arm__)||defined(_MSC_VER)
void MaskThresholds(Word64 *ps, Word64 * const mask, Word32 N, Word32 *idx) {
	UWord64 bark_power[18] = { 0 }; // 18 bark bands, N linear frequency bins
	Word64 T[18] = { 0 }; // 0dB-phony thresholds @ bark scale
	Word32 i, j;

	memset(bark_power, 0, sizeof(Word64) * 18);

	for (i = 0; i < 18; i += 1) { // spread func(i, j)
		j = N / 2 - 1; // excludes nyquists, dc
		do {
			UWRD128 temp;
			UWord64 a0, a1;
			temp = umul_64_128(ps[j], sprd_table[i][idx[j]]); //@q31
			a0 = temp.a0 + ((UWord64) temp.a1 << 32);
			a1 = temp.a2 + ((UWord64) temp.a3 << 32);
			a0 >>= 31;
			a0 ^= (a1 & 0x7fffffff) << 33;
			bark_power[i] += a0;
		} while (--j != 0); // linear to bark spread spectrum
	}

	for (i = 0; i < 18; i += 1) {
		UWRD128 temp;
		UWord64 a1, a0;
		Word64 p;

		p = udiv_64_64(CB_OFST[i], bark_power[i]);
		temp = umul_64_128(p, dc_gain[i]);
		a1 = temp.a2 + ((UWord64) temp.a3 << 32);
		a0 = temp.a0 + ((UWord64) temp.a1 << 32);
		a0 >>= 15;
		a0 ^= (a1 & 0x7fff) << 49;
		T[i] = a0;
	}
	for (i = 0; i < 18; i += 1) { // absolutely thresholds
		T[i] = max(T[i], 0);
	}
	for (i = 0; i < 1 + N / 2; i += 1) {
		mask[i] = T[idx[i]]; // to linear scale
	}
}
#endif

void TimeStretch_Create(sound_stretch *src) {
	src->outFrameBuf = WebRtc_CreateBuffer(8 * FRAME_LEN + Rs, sizeof(Word16));
	src->farFrameBuf = WebRtc_CreateBuffer(8 * FRAME_LEN + Ra, sizeof(Word16));
	WebRtc_InitBuffer(src->farFrameBuf);
	WebRtc_InitBuffer(src->outFrameBuf);
}

void TimeStretch_Init(sound_stretch *src) {
	src->Cntr = 0;
	src->ResetPhase = 1;
}

void TimeStretch_Destroy(sound_stretch *src) {
	WebRtc_FreeBuffer(src->farFrameBuf);
	WebRtc_FreeBuffer(src->outFrameBuf);
}

Word32 atan2Cordic(Word16 y, Word16 x) {
	static Word16 cosTab[16] = { 0, 23169, 30272, 32137, 32609, 32727, 32757,
			32764, 32766, 32766, 32766, 32766, 32766, 32766, 32766, 32766 }; //@q15
	static Word16 sinTab[16] = { 32767, 23169, 12539, 6392, 3211, 1607, 804,
			402, 201, 100, 50, 25, 12, 6, 3, 1 }; //@q15

	Word16 CurAngle = 16384;
	Word32 SumAngle = 0;
	Word32 i;

	if (!x && !y)
		return (0);
	else if (!y) {
		return ((x < 0) ? 32767 : 0);
	} else if (!x) {
		return ((y < 0) ? -16384 : 16384);
	} else {
		Word32 tmp32no1;
		Word32 tmp32no2;

		tmp32no1 = x << 16;
		tmp32no1 = CLZ(tmp32no1 ^ (tmp32no1 << 1)); //norm
		tmp32no2 = y << 16;
		tmp32no2 = CLZ(tmp32no2 ^ (tmp32no2 << 1)); //norm
		tmp32no1 = (tmp32no1 > tmp32no2) ? tmp32no2 : tmp32no1;

		for (i = 0; i < 15; i += 1) {
			Word16 tmp16no1;
			Word32 L_var_out;

			if (y > 0) {
				tmp16no1 = x; //r*exp(j(@-b))
				L_var_out = L_mult(x, cosTab[i]);
				L_var_out = L_mac(L_var_out, y, sinTab[i]);
				x = sat_32_16(L_add(L_var_out, 0x8000) >> 16);
				L_var_out = L_mult(y, cosTab[i]);
				L_var_out = L_msu(L_var_out, tmp16no1, sinTab[i]);
				y = sat_32_16(L_add(L_var_out, 0x8000) >> 16);
				SumAngle += CurAngle;
			} else if (y < 0) {
				tmp16no1 = x;
				L_var_out = L_mult(x, cosTab[i]);
				L_var_out = L_msu(L_var_out, y, sinTab[i]);
				x = sat_32_16(L_add(L_var_out, 0x8000) >> 16);
				L_var_out = L_mult(y, cosTab[i]);
				L_var_out = L_mac(L_var_out, tmp16no1, sinTab[i]);
				y = sat_32_16(L_add(L_var_out, 0x8000) >> 16);
				SumAngle -= CurAngle;
			}
			CurAngle >>= 1;
		}
		return (SumAngle);
	}
}

void TimeStretch(Word16 *Sin, Word16 *Out, sound_stretch *src) {
	Word32 i, pos;
	Word32 zeros32 = 0;
	Word16 work_buffer[NFFT + 2];
	Word16 *sc_inputs = (Word16*) (((uintptr_t) work_buffer + 3) & ~3);
	Word16 blk_expno1;
	ComplexInt32 SoundEst32[PartLen];
	Word32 dphi[PartLen1] = { 0 };
	Word16 outBlock_buf[Rs + 8];
	Word16 *outBlock = (Word16*) (((uintptr_t) outBlock_buf + 15) & ~15);
	Word16 outBlocks_buf[2 * Rs + 2];
	Word16 *outBlocks = (Word16*) (((uintptr_t) outBlocks_buf + 3) & ~3);
	Word16 const *out_ptr;
	Word32 size;
	Word32 tmp32no1;
	Word32 tmp32no2;

	/**Pitch-Scaling**/
	static Word16 buffer[2 * Rs + hL] = { 0 };

	WebRtc_WriteBuffer(src->farFrameBuf, Sin, FRAME_LEN);
	while (WebRtc_available_read(src->farFrameBuf) >= Ra) {
		Word16 far_block[Ra];
		Word16 const *far_block_ptr;

		WebRtc_ReadBuffer(src->farFrameBuf, (void**) &far_block_ptr, far_block,
		Ra);

		memmove(src->MonoBuffer, &src->MonoBuffer[Ra],
				sizeof(Word16) * (NFFT - Ra));
		memmove(&src->MonoBuffer[NFFT - Ra], far_block_ptr,
				sizeof(Word16) * Ra);
		i = 0;
		do {
			register Word32 L_var_out;
			L_var_out = L_mult(squared_hann[i], src->MonoBuffer[i]);
			sc_inputs[i] = L_var_out >> 16;
		} while (++i < NFFT);

		blk_expno1 = Real_FFT((ComplexInt16*) sc_inputs, 8); //rf(p1:p2)

		if (0 == src->Cntr % 3 && 0) { //phase resets
			src->ResetPhase = 1;
			src->Cntr = 0;
		} else {
			i = 1;
			do {
				Word16 tmp16no1, tmp16no2;
				Word32 tmp32no1;
				register Word32 L_var_out;

				src->alf[i] = src->arf[i];
				src->plf[i] = src->prf[i];
				tmp16no1 = ((ComplexInt16*) sc_inputs)[i].real;
				L_var_out = tmp16no1 * tmp16no1;
				tmp16no2 = ((ComplexInt16*) sc_inputs)[i].imag;
				L_var_out = L_add(L_var_out, tmp16no2 * tmp16no2);
				src->arf[i] = lsl(usqrt(L_var_out), blk_expno1);
				src->prf[i] = atan2Cordic(tmp16no2, tmp16no1);

				tmp32no1 = src->prf[i] - src->plf[i]; //real_diff
				//tmp32no1 -= 12288 * i;
				tmp32no1 -= 20480 * i;
				tmp16no1 = tmp32no1; //[-pi,pi] phase unwrapping
				//dphi[i] = (tmp16no1 * 21845 >> 14) + 16384 * i;
				dphi[i] = (tmp16no1 * 26214 >> 15) + 16384 * i;

			} while (++i < PartLen);
		}

		if (!src->ResetPhase) {
			SoundEst32->real = 0; //dc
			SoundEst32->imag = 0; //nyquists
			i = 1;
			do {
				//SoundEst32[i].real = src->alf[i] * cos(src->phi[i]);
				//SoundEst32[i].imag = src->alf[i] * sin(src->phi[i]);
				register Word32 tmp32no1;
				register Word32 tmp32no2;
				Word16 vector[2];

				tmp32no1 = src->alf[i];
				zeros32 = CLZ(tmp32no1 ^ (tmp32no1 << 1));
				oscillator_core(src->phi[i], vector, sin_table, cos_table);
				if (zeros32 > 15) {
					SoundEst32[i].real = src->alf[i] * vector[0] >> 14;
					SoundEst32[i].imag = src->alf[i] * vector[1] >> 14;
				} else {
					zeros32 = 16 - zeros32;
					tmp32no2 = src->alf[i] >> zeros32;
					tmp32no1 = tmp32no2 * vector[0];
					SoundEst32[i].real = asr(tmp32no1, 14 - zeros32);
					tmp32no1 = tmp32no2 * vector[1];
					SoundEst32[i].imag = asr(tmp32no1, 14 - zeros32);
				}

			} while (++i < PartLen);
			zeros32 = norm2Word16(SoundEst32, NFFT);

			for (i = 1; i < PartLen; i += 1) {
				((Complex16_t*) sc_inputs + i)->real = SoundEst32[i].real
						>> zeros32;
				((Complex16_t*) sc_inputs + i)->imag = SoundEst32[i].imag
						>> zeros32;
			}
			i = PartLen - 2;
			do {
				Word16 zeros, zerosno1;

				tmp32no1 = SoundEst32[i].real - SoundEst32[i - 1].real
						- SoundEst32[i + 1].real;
				tmp32no2 = SoundEst32[i].imag - SoundEst32[i - 1].imag
						- SoundEst32[i + 1].imag;
				zeros = CLZ(tmp32no1 ^ tmp32no1 << 1);
				zerosno1 = CLZ(tmp32no2 ^ tmp32no2 << 1);
				zeros = (zeros < zerosno1) ? zeros : zerosno1;
				zeros = (zeros < 16) ? 16 - zeros : 0;
				tmp32no1 >>= zeros;
				tmp32no2 >>= zeros;
				src->phi[i] = atan2Cordic(tmp32no2, tmp32no1) << 16;

			} while (--i != 1);
			{
				register Word32 zeros;
				register Word32 zerosno1;

				tmp32no1 = SoundEst32[1].real - SoundEst32[0].real
						- SoundEst32[2].real; //bin[1]-dc-bin[2]
				tmp32no2 = SoundEst32[1].imag - SoundEst32[2].imag;
				zeros = CLZ(tmp32no1 ^ tmp32no1 << 1);
				zerosno1 = CLZ(tmp32no2 ^ tmp32no2 << 1);
				zeros = (zerosno1 < zeros) ? zerosno1 : zeros;
				zeros = (zeros < 16) ? 16 - zeros : 0;
				tmp32no1 >>= zeros;
				tmp32no2 >>= zeros;
				src->phi[1] = atan2Cordic(tmp32no2, tmp32no1) << 16;

				tmp32no1 = SoundEst32[PartLen - 1].real	//bin[N/2]-bin[N/2-1]-bin[1+N/2]
				- SoundEst32[PartLen - 2].real - SoundEst32[0].imag;
				tmp32no2 = SoundEst32[PartLen - 1].imag
						- SoundEst32[PartLen - 2].imag;
				zeros = CLZ(tmp32no1 ^ tmp32no1 << 1);
				zerosno1 = CLZ(tmp32no2 ^ tmp32no2 << 1);
				zeros = (zerosno1 < zeros) ? zerosno1 : zeros;
				zeros = (zeros < 16) ? 16 - zeros : 0;
				tmp32no1 >>= zeros;
				tmp32no2 >>= zeros;
				src->phi[PartLen - 1] = atan2Cordic(tmp32no2, tmp32no1) << 16;
			}
			sc_inputs[0] = 0; //dc
			sc_inputs[1] = 0; //nyquist
			HS_IFFT((Complex16_t*) sc_inputs, sc_inputs, 8);

		} else {

			src->ResetPhase = 0;
		}
		for (i = 0; i < NFFT; i += 1) {
			register Word32 L_var_out;
			L_var_out = L_mult(sc_inputs[i], squared_hann[i]);
			sc_inputs[i] = sat_32_16(asr(L_var_out, 16 - zeros32));
		}
		for (i = 0; i < NFFT - Rs; i += 1) {
			register Word32 L_var_out;
			L_var_out = L_add(sc_inputs[i] << 16, src->SynsBuffer[i] << 16);
			src->SynsBuffer[i] = L_var_out >> 16;
		}

		memmove(outBlock, src->SynsBuffer, sizeof(Word16) * Rs);
		memmove(src->SynsBuffer, &src->SynsBuffer[Rs],
				sizeof(Word16) * (NFFT - 2 * Rs));
		memmove(&src->SynsBuffer[NFFT - 2 * Rs], &sc_inputs[NFFT - Rs],
				sizeof(Word16) * Rs);
		/*phase-locked*/
		for (i = 1; i < PartLen; i += 1) {
			src->phi[i] += (Word64) dphi[i] << 16;
		}

		/*resampler process*/
#if 0
		memmove(buffer, buffer + Rs, sizeof(Word16) * hL);
		memmove(buffer + hL, outBlock, sizeof(Word16) * Rs);

		i = 0;
		do {
			Word32 j;
			Word16 *__restrict ptrWrd16;
			Word16 *__restrict ptrWrd16no1;

			pos = position_table[i];
			ptrWrd16 = &buffer[pos];
			ptrWrd16no1 = coeff[(i % 3)];

			tmp32no1 = 0;
			j = hL;
			do {
				tmp32no1 = L_mac(tmp32no1, *ptrWrd16++, *ptrWrd16no1++);
			}while (--j != 0);
			outBlock[i] = tmp32no1 >> 16;
		}while (++i < Ra);
#else
		intp_2(outBlock, outBlocks, &src_config[0], Rs);

		memmove(buffer, buffer + 2 * Rs, sizeof(Word16) * hL);
		memmove(buffer + hL, outBlocks, sizeof(Word16) * 2 * Rs);
		i = 0;
		do {
			Word32 j;
			Word16 *__restrict ptrWrd16;
			Word16 *__restrict ptrWrd16no1;

			pos = Position_Table[i];
			ptrWrd16 = &buffer[pos];
			ptrWrd16no1 = Coeff[(i % 5)];

			j = hL;
			tmp32no1 = 0;
			do {
				tmp32no1 = L_mac(tmp32no1, *ptrWrd16++, *ptrWrd16no1++);
			} while (--j != 0);
			outBlock[i] = tmp32no1 >> 16;
		} while (++i < Ra);

#endif
		src->Cntr += 1;

		WebRtc_WriteBuffer(src->outFrameBuf, outBlock, Ra);
	}
	size = WebRtc_available_read(src->outFrameBuf);
	if (size < FRAME_LEN) {
		WebRtc_MoveReadPtr(src->outFrameBuf, size - FRAME_LEN);
	}

	WebRtc_ReadBuffer(src->outFrameBuf, (void**) &out_ptr, Out,
	FRAME_LEN);
	if (out_ptr != Out) {
		memmove(Out, out_ptr, sizeof(Word16) * FRAME_LEN);
	}
}

void Overlap_Add(Word16 *Sin, Word16 *Sout, nr_state *NRI) {
	Word32 blk_exponent;
	Word32 i;
	Word16 work_buffer[NFFT + 2];
	Word16 *sc_in_buffer = (Word16*) (((uintptr_t) work_buffer + 3) & ~3);

	memmove(&NRI->sc_buffer[0], &NRI->sc_buffer[Ra],
			(NFFT - Ra) * sizeof(Word16));
	memmove(&NRI->sc_buffer[NFFT - Ra], Sin, Ra * sizeof(Word16));

	for (i = 0; i < NFFT; i += 1) {
		sc_in_buffer[i] = L_mult(NRI->sc_buffer[i], sqrt_hann_256[i]) >> 16;
	}
	blk_exponent = Real_FFT((Complex16_t *) sc_in_buffer, 8);
	NoiseSuppression(NRI, (Complex16_t *) sc_in_buffer, blk_exponent);

#if 0
	Word32 zeros32 = 0;
	WRITE(&zeros32, sizeof(Word32), 1, dptr_iv);
	WRITE(&zeros32, sizeof(Word32), 1, dptr_iv);
	for (i = 1; i < PartLen; i += 1) {
		Word32 tmp32no1;
		tmp32no1 = ((ComplexInt16*) sc_in_buffer + i)->real << blk_exponent;
		WRITE(&tmp32no1, sizeof(Word32), 1, dptr_iv);
		tmp32no1 = ((ComplexInt16*) sc_in_buffer + i)->imag << blk_exponent;
		WRITE(&tmp32no1, sizeof(Word32), 1, dptr_iv);
	}
	WRITE(&zeros32, sizeof(Word32), 1, dptr_iv);
	WRITE(&zeros32, sizeof(Word32), 1, dptr_iv);
#endif

	HS_IFFT((ComplexInt16*) sc_in_buffer, sc_in_buffer, 8);

	for (i = 0; i < NFFT; i += 1) {
		register Word32 L_var_out;
		L_var_out = asr(L_mult(sc_in_buffer[i], sqrt_hann_256[i]),
				16 - blk_exponent);
		sc_in_buffer[i] = sat_32_16(L_var_out);
	}

	for (i = 0; i < NFFT - Rs; i += 1) {
		register Word32 L_var_out;
		L_var_out = L_add(sc_in_buffer[i] << 16, NRI->buffer[i] << 16);
		NRI->buffer[i] = L_var_out >> 16;
	}

	memmove(Sout, NRI->buffer, sizeof(Word16) * Rs);
	memmove(NRI->buffer, &NRI->buffer[Rs], sizeof(Word16) * (NFFT - 2 * Rs));
	memmove(&NRI->buffer[NFFT - 2 * Rs], &sc_in_buffer[NFFT - Rs],
			sizeof(Word16) * Rs);
}

#if !defined(_MSC_VER)
void ICA_SeparateInit(ica_state *ica_config) {
	Word32 i;
	ica_config->cntr = 0;
	ica_config->Iters = 0;
	ica_config->isEmpty = 1;
	for (i = 1; i < 512; i += 1) {
		ica_config->WCh1[i][0] = 1;
		ica_config->WCh1[i][1] = 0;
		ica_config->WCh2[i][0] = 0;
		ica_config->WCh2[i][1] = 1;
		ica_config->PCh1[i][0] = 1;
		ica_config->PCh1[i][1] = 0;
		ica_config->PCh2[i][0] = 0;
		ica_config->PCh2[i][1] = 1;
		ica_config->DCh1[i][0] = 1;
		ica_config->DCh1[i][1] = 0;
		ica_config->DCh2[i][0] = 0;
		ica_config->DCh2[i][1] = 1;
		ica_config->uCh1[i][0] = 1;
		ica_config->uCh1[i][1] = 0;
		ica_config->uCh2[i][0] = 0;
		ica_config->uCh2[i][1] = 1;
		ica_config->aCh1[i][0] = 1;
		ica_config->aCh1[i][1] = 0;
		ica_config->aCh2[i][0] = 0;
		ica_config->aCh2[i][1] = 1;

		ica_config->Gain[i] = 32767;
		ica_config->Gain1[i] = 32767;
		ica_config->ringBuffer1[i] = WebRtc_CreateBuffer(nIter << 4,
				sizeof(float _Complex));
		ica_config->ringBuffer2[i] = WebRtc_CreateBuffer(nIter << 4,
				sizeof(float _Complex));
		//(ica_config->ringBuffer1[i])->write_pos = nIter;
		//(ica_config->ringBuffer2[i])->write_pos = nIter;
		//(ica_config->ringBuffer1[i])->rw_wrap = SAME_WRAP;
		//(ica_config->ringBuffer2[i])->rw_wrap = SAME_WRAP;
	}
	pthread_mutex_init(&ica_config->state_mutex, NULL);
	pthread_mutex_init(&ica_config->filter_mutex, NULL);
	pthread_mutex_init(&ica_config->queue_mutex, NULL);

	MatrixXcf a = MatrixXcf_new(2, 2);
	MatrixXcf b = MatrixXcf_new(2, 2);
	MatrixXcf c = MatrixXcf_new(2, 1);

	MatrixXcf_set_coeff(a, 0, 0, 777);
	MatrixXcf_set_coeff(a, 0, 1, 511);
	MatrixXcf_set_coeff(a, 1, 0, 511);
	MatrixXcf_set_coeff(a, 1, 1, 777);

	MatrixXcf_PCA(a, b, c);
	MatrixXcf_print(c);

	MatrixXi64_t d = MatrixXi64_t_new(2, 2);
	MatrixXi64_t e = MatrixXi64_t_new(2, 2);
	MatrixXi64_t f = MatrixXi64_t_new(2, 1);

	MatrixXi64_t_set_coeff(d, 0, 0, 1024);
	MatrixXi64_t_set_coeff(d, 0, 1, 512);
	MatrixXi64_t_set_coeff(d, 1, 0, 512);
	MatrixXi64_t_set_coeff(d, 1, 1, 1024);

	MatrixXi_PCA(d, e, f);
	MatrixXi64_t_print(e);
	MatrixXi64_t_print(f);

	printf("q15=%d\n", float2q15(-1.3456));
}

void ICA_SeparateDestroy(ica_state *ica_config) {
	Word32 i;
	for (i = 1; i < 512; i += 1) {
		WebRtc_FreeBuffer(ica_config->ringBuffer1[i]);
		WebRtc_FreeBuffer(ica_config->ringBuffer2[i]);
	}
	pthread_mutex_destroy(&ica_config->state_mutex);
	pthread_mutex_destroy(&ica_config->filter_mutex);
	pthread_mutex_destroy(&ica_config->queue_mutex);
}

int needQuit(pthread_mutex_t *mtx) {
	switch (pthread_mutex_trylock(mtx)) {
	case 0:
		pthread_mutex_unlock(mtx);
		return (1);
	case EBUSY:
		return (0);
	default:
		break;
	}
	return (0);
}

static __inline int cisnan(float _Complex z) {
	return (isnan(creal(z)) || isnan(cimag(z)) ? 1 :
	isinf(creal(z)) || isinf(cimag(z)) ? 1 : 0);
}

/**Brief description which ends at this dot. Details follow
 * here.
 */
void *pca_ica_thread_func(void *arg) {
	static int nCount = 0;
	Word32 i, j;
	ica_state* __restrict ica_config = ((ARG*) arg)->ica_config;
	MatrixXcf __restrict MatError;
	MatrixXcf __restrict MatDeMix;
	MatrixXcf __restrict MatCopy;
	MatrixXcf __restrict MatDmxOuts;
	MatrixXcf __restrict MatIdentity;
	MatrixXcf __restrict MatPcaOuts;
	MatrixXcf __restrict MatyCjOuts;
	MatrixXcf __restrict colvctor;
	MatrixXcf __restrict rowvctor;
	MatrixXcf __restrict MatCov;
	MatrixXcf __restrict MatDot;

	//float _Complex DataCh1[512][nIter];
	//float _Complex DataCh2[512][nIter];

	float _Complex (*DataCh1)[nIter] = ica_config->DataCh1;
	float _Complex (*DataCh2)[nIter] = ica_config->DataCh2;

	MatError = MatrixXcf_new(2, 2);
	MatDeMix = MatrixXcf_new(2, 2);
	MatCopy = MatrixXcf_new(2, 2);
	MatCov = MatrixXcf_new(2, 2);
	MatIdentity = MatrixXcf_new(2, 2);
	MatDmxOuts = MatrixXcf_new(2, nIter);
	MatPcaOuts = MatrixXcf_new(2, nIter);
	MatyCjOuts = MatrixXcf_new(nIter, 2);
	colvctor = MatrixXcf_new(2, 1);
	MatrixXcf_set_Identity(MatIdentity, 2, 2);
	rowvctor = MatrixXcf_new(1, 2);
	MatDot = MatrixXcf_new(1, 1);
	MatrixXcf_set_Ones(MatCov, 2, 2);

	while (!needQuit(((ARG*) arg)->mx)) {
		if (!ica_config->isEmpty) { //queue full
			int err1, err2;
			pthread_mutex_lock(&ica_config->state_mutex);
			ica_config->isEmpty = 1; //clear pending
			pthread_mutex_unlock(&ica_config->state_mutex);
			pthread_mutex_lock(&ica_config->queue_mutex);
			for (i = F_LOWER; i < F_UPPER; i += 1) {
				float _Complex const *data_ptr1;
				float _Complex const *data_ptr2;
#if 0
				memcpy(DataCh1[i], ica_config->DataCh1[i],
						sizeof(float _Complex) * nIter);
				memcpy(DataCh2[i], ica_config->DataCh2[i],
						sizeof(float _Complex) * nIter);
#else
				err1 = WebRtc_ReadBuffer(ica_config->ringBuffer1[i],
						(void**) &data_ptr1, DataCh1[i],
						nIter);
				err2 = WebRtc_ReadBuffer(ica_config->ringBuffer2[i],
						(void**) &data_ptr2, DataCh2[i],
						nIter);
				if (data_ptr1 != DataCh1[i])
					memmove(DataCh1[i], data_ptr1,
							sizeof(float _Complex) * nIter);
				if (data_ptr2 != DataCh2[i])
					memmove(DataCh2[i], data_ptr2,
							sizeof(float _Complex) * nIter);
				//assert(err1==nIter);
				//assert(err2==nIter);
#endif
			}
			pthread_mutex_unlock(&ica_config->queue_mutex);

			for (i = F_LOWER; i < F_UPPER; i += 1) {
				float doas[2];
				float eivalues[2];
				float _Complex tmp32no1, tmp32no2;
				bitfields fpu_no1, fpu_no2;
				Word32 fix32no1, fix32no2;
				Word16 tmp16no1, tmp16no2;

				if (ica_config->eivalues[i][0]
						> (0.999f
								* (ica_config->eivalues[i][0]
										+ ica_config->eivalues[i][1]))) {
					ica_config->pca_flag[i] = true; //DTD
					MatrixXcf_set_coeff(MatError, 0, 0, ica_config->DCh1[i][0]);
					MatrixXcf_set_coeff(MatError, 0, 1, ica_config->DCh1[i][1]);
					MatrixXcf_set_coeff(MatError, 1, 0, ica_config->DCh2[i][0]);
					MatrixXcf_set_coeff(MatError, 1, 1, ica_config->DCh2[i][1]);
				} else {
					ica_config->pca_flag[i] = false;
					MatrixXcf_set_coeff(MatDeMix, 0, 0, ica_config->WCh1[i][0]); //FastICA,dxh(:,:,k)
					MatrixXcf_set_coeff(MatDeMix, 0, 1, ica_config->WCh1[i][1]);
					MatrixXcf_set_coeff(MatDeMix, 1, 0, ica_config->WCh2[i][0]);
					MatrixXcf_set_coeff(MatDeMix, 1, 1, ica_config->WCh2[i][1]);

					MatrixXcf_set_coeff(MatCopy, 0, 0, ica_config->PCh1[i][0]); //PCA,pxh(:,:,k)
					MatrixXcf_set_coeff(MatCopy, 0, 1, ica_config->PCh1[i][1]);
					MatrixXcf_set_coeff(MatCopy, 1, 0, ica_config->PCh2[i][0]);
					MatrixXcf_set_coeff(MatCopy, 1, 1, ica_config->PCh2[i][1]);

					MatrixXcf_multiply(MatDeMix, MatCopy, MatError);
				}
#if 0
				tmp32no1 = conj(MatrixXcf_get_coeff(MatError, 0, 0));
				tmp32no2 = conj(MatrixXcf_get_coeff(MatError, 0, 1));
				MatrixXcf_set_coeff(colvctor, 0, 0, conj(tmp32no1)); ///w
				MatrixXcf_set_coeff(colvctor, 1, 0, conj(tmp32no2));
				MatrixXcf_set_coeff(rowvctor, 0, 0, tmp32no1);
				MatrixXcf_set_coeff(rowvctor, 0, 1, tmp32no2);

				MatrixXcf_multiply(MatCov, colvctor, colvctor);///w'*ones(2)*w
				MatrixXcf_multiply(rowvctor, colvctor, MatDot);
				doas[0] = creal(MatrixXcf_get_coeff(MatDot, 0, 0));///j1

				tmp32no1 = conj(MatrixXcf_get_coeff(MatError, 1, 0));
				tmp32no2 = conj(MatrixXcf_get_coeff(MatError, 1, 1));
				MatrixXcf_set_coeff(colvctor, 0, 0, conj(tmp32no1));
				MatrixXcf_set_coeff(colvctor, 1, 0, conj(tmp32no2));
				MatrixXcf_set_coeff(rowvctor, 0, 0, tmp32no1);
				MatrixXcf_set_coeff(rowvctor, 0, 1, tmp32no2);

				MatrixXcf_multiply(MatCov, colvctor, colvctor);
				MatrixXcf_multiply(rowvctor, colvctor, MatDot);
				doas[1] = creal(MatrixXcf_get_coeff(MatDot, 0, 0));///j2

				doas[0] >= doas[1] ? 0 : MatrixXcf_rowswap(MatError, 0, 1);
#else
				tmp32no1 = MatrixXcf_get_coeff(MatError, 1, 1);
				tmp32no2 = MatrixXcf_get_coeff(MatError, 1, 0);
				tmp32no1 *= conj(tmp32no2);
				fpu_no1.a = (float) creal(tmp32no1);
				fpu_no2.a = (float) cimag(tmp32no1);
				tmp16no1 = fpu_no1.exponent;
				tmp16no2 = fpu_no2.exponent;
				tmp16no1 = tmp16no1 > tmp16no2 ? tmp16no1 : tmp16no2;
				tmp16no1 -= 127;
				fix32no1 = (fpu_no1.fraction << 8) ^ 0x80000000;
				fix32no1 = (uint32_t) fix32no1
						>> (144 + tmp16no1 - fpu_no1.exponent);
				fix32no1 = (fpu_no1.sign) ? -fix32no1 : fix32no1;
				fix32no2 = (fpu_no2.fraction << 8) ^ 0x80000000;
				fix32no2 = (uint32_t) fix32no2
						>> (144 + tmp16no1 - fpu_no2.exponent);
				fix32no2 = fpu_no2.sign ? -fix32no2 : fix32no2;
				doas[0] =
						(true) ?
								atan2Cordic(-fix32no2, -fix32no1) :
								atan2(-cimag(tmp32no1), -creal(tmp32no1));

				tmp32no1 = MatrixXcf_get_coeff(MatError, 0, 1);
				tmp32no2 = MatrixXcf_get_coeff(MatError, 0, 0);
				tmp32no1 *= conj(tmp32no2);
				fpu_no1.a = (float) creal(tmp32no1);
				fpu_no2.a = (float) cimag(tmp32no1);
				tmp16no1 = fpu_no1.exponent;
				tmp16no2 = fpu_no2.exponent;
				tmp16no1 = tmp16no1 > tmp16no2 ? tmp16no1 : tmp16no2;
				tmp16no1 -= 127;
				fix32no1 = (fpu_no1.fraction << 8) ^ 0x80000000;
				fix32no1 = (uint32_t) fix32no1
						>> (144 + tmp16no1 - fpu_no1.exponent);
				fix32no1 = fpu_no1.sign ? -fix32no1 : fix32no1;
				fix32no2 = (fpu_no2.fraction << 8) ^ 0x80000000;
				fix32no2 = (uint32_t) fix32no2
						>> (144 + tmp16no1 - fpu_no2.exponent);
				fix32no2 = fpu_no2.sign ? -fix32no2 : fix32no2;
				doas[1] =
						(true) ?
								atan2Cordic(-fix32no2, -fix32no1) :
								atan2(-cimag(tmp32no1), -creal(tmp32no1));
#if defined(USE_BSSA)
				if (fabsf(doas[0]) > fabsf(doas[1])) {
#else
					if (doas[0] > doas[1]) {
#endif
					MatrixXcf_rowswap(MatError, 0, 1);
					ica_config->doas[i][0] = doas[1]; //arc(W(i,j)/W(i,J))
					ica_config->doas[i][1] = doas[0];
				} else {
					ica_config->doas[i][0] = doas[0];
					ica_config->doas[i][1] = doas[1];
				}
#endif
				MatrixXcf_inverse(MatError, MatDeMix); //project
				__real__ tmp32no1 = cos(pi * ica_config->doas[i][0] / 65536.f);
				__imag__ tmp32no1 = sin(pi * ica_config->doas[i][0] / 65536.f);
				__real__ tmp32no2 = cos(pi * ica_config->doas[i][1] / 65536.f);
				__imag__ tmp32no2 = sin(pi * ica_config->doas[i][1] / 65536.f);

				pthread_mutex_lock(&ica_config->filter_mutex);
				ica_config->DCh1[i][0] = MatrixXcf_get_coeff(MatError, 0, 0); //sorted
				ica_config->DCh1[i][1] = MatrixXcf_get_coeff(MatError, 0, 1);
				ica_config->DCh2[i][0] = MatrixXcf_get_coeff(MatError, 1, 0);
				ica_config->DCh2[i][1] = MatrixXcf_get_coeff(MatError, 1, 1);
				ica_config->uCh1[i][0] = MatrixXcf_get_coeff(MatDeMix, 0, 0); //projected back matrix
				ica_config->uCh1[i][1] = MatrixXcf_get_coeff(MatDeMix, 0, 1);
				ica_config->uCh2[i][0] = MatrixXcf_get_coeff(MatDeMix, 1, 0);
				ica_config->uCh2[i][1] = MatrixXcf_get_coeff(MatDeMix, 1, 1);
				ica_config->aCh1[i][0] = conj(tmp32no1);
				ica_config->aCh1[i][1] = tmp32no1;
				ica_config->aCh2[i][0] = conj(tmp32no2);
				ica_config->aCh2[i][1] = tmp32no2;
				pthread_mutex_unlock(&ica_config->filter_mutex);

				/*PCA,pre-whitening,D^-0.5*v',block(m-1)*/
				j = 0;
				do {
					MatrixXcf_set_coeff(MatPcaOuts, 0, j, DataCh1[i][j]);
					MatrixXcf_set_coeff(MatPcaOuts, 1, j, DataCh2[i][j]);
				} while (++j < nIter);
				MatrixXcf_adjoint(MatPcaOuts, MatyCjOuts);
				MatrixXcf_multiply(MatPcaOuts, MatyCjOuts, MatCopy); // covariance
				MatrixXcf_scalar(MatCopy, MatCov, 0.020833f);
				//MatrixXcf_PCA(MatCov, MatError, colvctor); //MatError=D^-0.5*v'
				MatrixXcf_eigensolver(MatCov, MatError, colvctor);

				eivalues[0] = creal(MatrixXcf_get_coeff(colvctor, 0, 0));
				eivalues[1] = creal(MatrixXcf_get_coeff(colvctor, 1, 0));
				eivalues[0] >= eivalues[1] ?
						0 : MatrixXcf_rowswap(colvctor, 0, 1), MatrixXcf_rowswap(
						MatError, 0, 1);
				ica_config->eivalues[i][0] = creal(
						MatrixXcf_get_coeff(colvctor, 0, 0));
				ica_config->eivalues[i][1] = creal(
						MatrixXcf_get_coeff(colvctor, 1, 0));
				MatrixXcf_multiply(MatError, MatPcaOuts, MatPcaOuts); //Whitening
				MatrixXcf_FastICA(MatPcaOuts, MatCopy, 8); //new thread

				ica_config->WCh1[i][0] = MatrixXcf_get_coeff(MatCopy, 0, 0);
				ica_config->WCh1[i][1] = MatrixXcf_get_coeff(MatCopy, 0, 1);
				ica_config->WCh2[i][0] = MatrixXcf_get_coeff(MatCopy, 1, 0);
				ica_config->WCh2[i][1] = MatrixXcf_get_coeff(MatCopy, 1, 1);

				if (cisnan(ica_config->WCh1[i][0])
						|| cisnan(ica_config->WCh1[i][1])
						|| cisnan(ica_config->WCh2[i][0])
						|| cisnan(ica_config->WCh2[i][1])) {
					ica_config->WCh1[i][0] = 1;
					ica_config->WCh1[i][1] = 0;
					ica_config->WCh2[i][0] = 0;
					ica_config->WCh2[i][1] = 1;
				}

				ica_config->PCh1[i][0] = MatrixXcf_get_coeff(MatError, 0, 0); //Whitening Matrix
				ica_config->PCh1[i][1] = MatrixXcf_get_coeff(MatError, 0, 1);
				ica_config->PCh2[i][0] = MatrixXcf_get_coeff(MatError, 1, 0);
				ica_config->PCh2[i][1] = MatrixXcf_get_coeff(MatError, 1, 1);

				if (cisnan(ica_config->PCh1[i][0])
						|| cisnan(ica_config->PCh1[i][1])
						|| cisnan(ica_config->PCh2[i][0])
						|| cisnan(ica_config->PCh2[i][1])) {
					ica_config->PCh1[i][0] = 0;
					ica_config->PCh1[i][1] = 0;
					ica_config->PCh2[i][0] = 0;
					ica_config->PCh2[i][1] = 0;
				}
			}
			nCount += 1;
		} else {
			usleep(32000);
		}
	}
	MatrixXcf_delete(MatDeMix);
	MatrixXcf_delete(MatCopy);
	MatrixXcf_delete(MatCov);
	MatrixXcf_delete(MatDmxOuts);
	MatrixXcf_delete(MatIdentity);
	MatrixXcf_delete(MatPcaOuts);
	MatrixXcf_delete(MatyCjOuts);
	MatrixXcf_delete(colvctor);
	MatrixXcf_delete(rowvctor);
	MatrixXcf_delete(MatDot);

	return (NULL);
}

void ICA_Separation(Word16 * __restrict MIC1, Word16 * __restrict MIC2,
		Word16 * __restrict Sout, Word16 * __restrict Sout1,
		ica_state * __restrict ica_config) {
	Word16 nCount;
	Word32 i, j;
	Word32 b1, b2;
	Word32 tmp32no3 = 0, tmp32no4 = 0;
	Word32 zerosno1 = 0, zerosno2 = 0;

	Word16 stft_chn1[1024];
	Word16 stft_chn2[1024];

	/*not aliased*/
	MatrixXcf __restrict MatDeMix; //dxh(:,:,k)
	MatrixXcf __restrict MatError;
	MatrixXcf __restrict MatCopy;
	MatrixXcf __restrict MatW;
	MatrixXcf __restrict MatIdentity;
	MatrixXcf __restrict MatPcaOuts;
	MatrixXcf __restrict MatDmxOuts;
	MatrixXcf __restrict MatNlrOuts;
	MatrixXcf __restrict MatyCjOuts;
	MatrixXcf __restrict colvctor;
	MatrixXcf __restrict vector2cf;

	MatCopy = MatrixXcf_new(2, 2);
	MatDeMix = MatrixXcf_new(2, 2);
	MatDmxOuts = MatrixXcf_new(2, nIter);
	MatError = MatrixXcf_new(2, 2);
	MatIdentity = MatrixXcf_new(2, 2);
	colvctor = MatrixXcf_new(2, 1);
	MatNlrOuts = MatrixXcf_new(2, nIter);
	MatPcaOuts = MatrixXcf_new(2, nIter);
	vector2cf = MatrixXcf_new(2, 1);
	MatW = MatrixXcf_new(2, 2);
	MatyCjOuts = MatrixXcf_new(nIter, 2);
	MatrixXcf_set_Identity(MatIdentity, 2, 2);

#if defined(DCH)
	memmove(ica_config->mic1Buf + 3 * 256, MIC1, sizeof(Word16) * 256); //overlaps/0.75
	memmove(ica_config->mic2Buf + 3 * 256, MIC2, sizeof(Word16) * 256);//overlaps/0.75
#else
	memmove(ica_config->mic1Buf + 256, MIC1, sizeof(Word16) * 256);
	memmove(ica_config->mic2Buf + 256, MIC2, sizeof(Word16) * 256);
#endif

	pthread_mutex_lock(&ica_config->state_mutex);
	if (!ica_config->cntr && ica_config->Iters)
		ica_config->isEmpty = 0;
	pthread_mutex_unlock(&ica_config->state_mutex);

#if defined(DCH)
	for (i = 0; i < 512; i += 1) {
		stft_chn1[i] = L_mult(ica_config->mic1Buf[i], hann1024[i]) >> 16;
		stft_chn2[i] = L_mult(ica_config->mic2Buf[i], hann1024[i]) >> 16;
		stft_chn1[i + 512] = L_mult(ica_config->mic1Buf[i + 512],
				hann1024[511 - i]) >> 16;
		stft_chn2[i + 512] = L_mult(ica_config->mic2Buf[i + 512],
				hann1024[511 - i]) >> 16;
	}
#else
	for (i = 0; i < 256; i += 1) {
		stft_chn1[i] = L_mult(ica_config->mic1Buf[i], hann512[i]) >> 16;
		stft_chn2[i] = L_mult(ica_config->mic2Buf[i], hann512[i]) >> 16;
		stft_chn1[i + 256] = L_mult(ica_config->mic1Buf[i + 256],
				hann512[255 - i]) >> 16;
		stft_chn2[i + 256] = L_mult(ica_config->mic2Buf[i + 256],
				hann512[255 - i]) >> 16;
	}
#endif
	b1 = Real_FFT((ComplexInt16*) stft_chn1, N_ORDER);
	b2 = Real_FFT((ComplexInt16*) stft_chn2, N_ORDER);

#if defined(ICA_THREAD)
	if (!ica_config->isEmpty) { //mod(cntr,L3)==0

		for (i = 1; i < F_UPPER; i += 1) {
			float doas[2];
			float eivalues[2];
			float _Complex tmp32no1, tmp32no2;
			bitfields fpu_no1, fpu_no2;
			Word32 fix32no1, fix32no2;
			Word16 tmp16no1, tmp16no2;

			if (ica_config->eivalues[i][0]
					> (0.999f
							* (ica_config->eivalues[i][0]
									+ ica_config->eivalues[i][1]))) {
				ica_config->pca_flag[i] = true;
#if 1
				MatrixXcf_set_coeff(MatError, 0, 0, ica_config->DCh1[i][0]);
				MatrixXcf_set_coeff(MatError, 0, 1, ica_config->DCh1[i][1]);
				MatrixXcf_set_coeff(MatError, 1, 0, ica_config->DCh2[i][0]);
				MatrixXcf_set_coeff(MatError, 1, 1, ica_config->DCh2[i][1]);
#else
				MatrixXcf_set_coeff(MatError, 0, 0, 1);
				MatrixXcf_set_coeff(MatError, 0, 1, 0);
				MatrixXcf_set_coeff(MatError, 1, 0, 0);
				MatrixXcf_set_coeff(MatError, 1, 1, 1);
#endif
			} else {
				ica_config->pca_flag[i] = false;
				MatrixXcf_set_coeff(MatDeMix, 0, 0, ica_config->WCh1[i][0]); //FastICA,dxh(:,:,k)
				MatrixXcf_set_coeff(MatDeMix, 0, 1, ica_config->WCh1[i][1]);
				MatrixXcf_set_coeff(MatDeMix, 1, 0, ica_config->WCh2[i][0]);
				MatrixXcf_set_coeff(MatDeMix, 1, 1, ica_config->WCh2[i][1]);

				MatrixXcf_set_coeff(MatCopy, 0, 0, ica_config->PCh1[i][0]);//PCA,pxh(:,:,k)
				MatrixXcf_set_coeff(MatCopy, 0, 1, ica_config->PCh1[i][1]);
				MatrixXcf_set_coeff(MatCopy, 1, 0, ica_config->PCh2[i][0]);
				MatrixXcf_set_coeff(MatCopy, 1, 1, ica_config->PCh2[i][1]);
				MatrixXcf_multiply(MatDeMix, MatCopy, MatError);
			}

			/*tmp32no1 = MatrixXcf_get_coeff(MatError, 0, 0);
			 fwrite(&tmp32no1, sizeof(float), 2, pFiles);
			 tmp32no1 = MatrixXcf_get_coeff(MatError, 0, 1);
			 fwrite(&tmp32no1, sizeof(float), 2, pFiles);
			 tmp32no1 = MatrixXcf_get_coeff(MatError, 1, 0);
			 fwrite(&tmp32no1, sizeof(float), 2, pFiles);
			 tmp32no1 = MatrixXcf_get_coeff(MatError, 1, 1);
			 fwrite(&tmp32no1, sizeof(float), 2, pFiles);*/

			j = 0;
			do {
				MatrixXcf_set_coeff(MatDmxOuts, 0, j, ica_config->IcaCh1[i][j]);
				MatrixXcf_set_coeff(MatDmxOuts, 1, j, ica_config->IcaCh2[i][j]);
			}while (++j < nIter); //block(m-2)
#if 1
#if 0
			MatrixXcf_inverse(MatError, MatDeMix); //projection,column vector
			tmp32no1 = MatrixXcf_get_coeff(MatDeMix, 0, 0);
			tmp32no2 = MatrixXcf_get_coeff(MatDeMix, 1, 0);
			tmp32no1 *= conj(tmp32no2);
			fpu_no1.a = (float) creal(tmp32no1);
			fpu_no2.a = (float) cimag(tmp32no1);
			tmp16no1 = fpu_no1.exponent;
			tmp16no2 = fpu_no2.exponent;
			tmp16no1 = tmp16no1 > tmp16no2 ? tmp16no1 : tmp16no2;
			tmp16no1 -= 127;
			fix32no1 = fpu_no1.fraction << 8 ^ 0x80000000;//@q.Exp
			fix32no1 = (uint32_t) fix32no1
			>> (144 - fpu_no1.exponent + tmp16no1);
			fix32no1 = (fpu_no1.sign) ? -fix32no1 : fix32no1;
			fix32no2 = fpu_no2.fraction << 8 ^ 0x80000000;
			fix32no2 = (uint32_t) fix32no2
			>> (144 - fpu_no2.exponent + tmp16no1);
			fix32no2 = (fpu_no2.sign) ? -fix32no2 : fix32no2;
			doas[0] =
			(true) ?
			atan2Cordic(fix32no2, fix32no1) :
			atan2(cimag(tmp32no1), creal(tmp32no1));
			tmp32no1 = MatrixXcf_get_coeff(MatDeMix, 0, 1);
			tmp32no2 = MatrixXcf_get_coeff(MatDeMix, 1, 1);
			tmp32no1 *= conj(tmp32no2);
			fpu_no1.a = (float) creal(tmp32no1);
			fpu_no2.a = (float) cimag(tmp32no1);
			tmp16no1 = fpu_no1.exponent;
			tmp16no2 = fpu_no2.exponent;
			tmp16no1 = tmp16no1 > tmp16no2 ? tmp16no1 : tmp16no2;
			tmp16no1 -= 127;
			fix32no1 = fpu_no1.fraction << 8 ^ 0x80000000;
			fix32no1 = (uint32_t) fix32no1
			>> (144 - fpu_no1.exponent + tmp16no1);
			fix32no1 = (fpu_no1.sign) ? -fix32no1 : fix32no1;
			fix32no2 = fpu_no2.fraction << 8 ^ 0x80000000;
			fix32no2 = (uint32_t) fix32no2
			>> (144 - fpu_no2.exponent + tmp16no1);
			fix32no2 = (fpu_no2.sign) ? -fix32no2 : fix32no2;
			doas[1] =
			(true) ?
			atan2Cordic(fix32no2, fix32no1) :
			atan2(cimag(tmp32no1), creal(tmp32no1));
			fabsf(doas[0]) > fabsf(doas[1]) ?
			MatrixXcf_columnswap(MatDeMix, 0, 1) : 0;
			MatrixXcf_inverse(MatDeMix, MatError);
#else
			tmp32no1 = MatrixXcf_get_coeff(MatError, 1, 1);
			tmp32no2 = MatrixXcf_get_coeff(MatError, 1, 0);
			tmp32no1 *= conj(tmp32no2);
			fpu_no1.a = (float) creal(tmp32no1);
			fpu_no2.a = (float) cimag(tmp32no1);
			tmp16no1 = fpu_no1.exponent;
			tmp16no2 = fpu_no2.exponent;
			tmp16no1 = tmp16no1 > tmp16no2 ? tmp16no1 : tmp16no2;
			tmp16no1 -= 127;
			fix32no1 = (fpu_no1.fraction << 8) ^ 0x80000000;
			fix32no1 = (uint32_t) fix32no1
			>> (144 + tmp16no1 - fpu_no1.exponent);
			fix32no1 = (fpu_no1.sign) ? -fix32no1 : fix32no1;
			fix32no2 = (fpu_no2.fraction << 8) ^ 0x80000000;
			fix32no2 = (uint32_t) fix32no2
			>> (144 + tmp16no1 - fpu_no2.exponent);
			fix32no2 = fpu_no2.sign ? -fix32no2 : fix32no2;
			doas[0] =
			(true) ?
			atan2Cordic(-fix32no2, -fix32no1) :
			atan2(-cimag(tmp32no1), -creal(tmp32no1));

			tmp32no1 = MatrixXcf_get_coeff(MatError, 0, 1);
			tmp32no2 = MatrixXcf_get_coeff(MatError, 0, 0);
			tmp32no1 *= conj(tmp32no2);
			fpu_no1.a = (float) creal(tmp32no1);
			fpu_no2.a = (float) cimag(tmp32no1);
			tmp16no1 = fpu_no1.exponent;
			tmp16no2 = fpu_no2.exponent;
			tmp16no1 = tmp16no1 > tmp16no2 ? tmp16no1 : tmp16no2;
			tmp16no1 -= 127;
			fix32no1 = (fpu_no1.fraction << 8) ^ 0x80000000;
			fix32no1 = (uint32_t) fix32no1
			>> (144 + tmp16no1 - fpu_no1.exponent);
			fix32no1 = fpu_no1.sign ? -fix32no1 : fix32no1;
			fix32no2 = (fpu_no2.fraction << 8) ^ 0x80000000;
			fix32no2 = (uint32_t) fix32no2
			>> (144 + tmp16no1 - fpu_no2.exponent);
			fix32no2 = fpu_no2.sign ? -fix32no2 : fix32no2;
			doas[1] =
			(true) ?
			atan2Cordic(-fix32no2, -fix32no1) :
			atan2(-cimag(tmp32no1), -creal(tmp32no1));
#if defined(USE_BSSA)
			if (fabsf(doas[0]) > fabsf(doas[1])) {
#else
				if (doas[0] > doas[1]) {
#endif
					MatrixXcf_rowswap(MatError, 0, 1);
					ica_config->doas[i][0] = doas[1]; //arc(W(i,j)/W(i,J))
					ica_config->doas[i][1] = doas[0];
				} else {
					ica_config->doas[i][0] = doas[0];
					ica_config->doas[i][1] = doas[1];
				}
#endif
#endif
				__real__ tmp32no1 = cos(pi * ica_config->doas[i][0] / 65536.f);
				__imag__ tmp32no1 = sin(pi * ica_config->doas[i][0] / 65536.f);
				__real__ tmp32no2 = cos(pi * ica_config->doas[i][1] / 65536.f);
				__imag__ tmp32no2 = sin(pi * ica_config->doas[i][1] / 65536.f);

				MatrixXcf_inverse(MatError, MatDeMix); //PBM=(W(indices,:)+eps*I)^-1
				ica_config->DCh1[i][0] = MatrixXcf_get_coeff(MatError, 0, 0);//sorted
				ica_config->DCh1[i][1] = MatrixXcf_get_coeff(MatError, 0, 1);
				ica_config->DCh2[i][0] = MatrixXcf_get_coeff(MatError, 1, 0);
				ica_config->DCh2[i][1] = MatrixXcf_get_coeff(MatError, 1, 1);
				ica_config->uCh1[i][0] = MatrixXcf_get_coeff(MatDeMix, 0, 0);//projected back matrix
				ica_config->uCh1[i][1] = MatrixXcf_get_coeff(MatDeMix, 0, 1);
				ica_config->uCh2[i][0] = MatrixXcf_get_coeff(MatDeMix, 1, 0);
				ica_config->uCh2[i][1] = MatrixXcf_get_coeff(MatDeMix, 1, 1);

				/*tmp32no1 = MatrixXcf_get_coeff(MatDeMix, 0, 0);
				 fwrite(&tmp32no1, sizeof(float), 2, pFiles);
				 tmp32no1 = MatrixXcf_get_coeff(MatDeMix, 0, 1);
				 fwrite(&tmp32no1, sizeof(float), 2, pFiles);
				 tmp32no1 = MatrixXcf_get_coeff(MatDeMix, 1, 0);
				 fwrite(&tmp32no1, sizeof(float), 2, pFiles);
				 tmp32no1 = MatrixXcf_get_coeff(MatDeMix, 1, 1);
				 fwrite(&tmp32no1, sizeof(float), 2, pFiles);*/

				ica_config->aCh1[i][0] = conj(tmp32no1);
				ica_config->aCh1[i][1] = tmp32no1;
				ica_config->aCh2[i][0] = conj(tmp32no2);
				ica_config->aCh2[i][1] = tmp32no2;///[y1;y2]=W(indices,:,k)*block(m-2)
				MatrixXcf_multiply(MatError, MatDmxOuts, MatPcaOuts);//[y1(target);y2(noise_ref)]

				j = 0;
				do { //projection back,block(m-2)
					float _Complex tmp32no1;
					tmp32no1 = MatrixXcf_get_coeff(MatPcaOuts, 1, j);//null@target,noise_ref
					MatrixXcf_set_coeff(colvctor, 0, 0, 0);
					MatrixXcf_set_coeff(colvctor, 1, 0, tmp32no1);
					MatrixXcf_multiply(MatDeMix, colvctor, colvctor);
					tmp32no1 = MatrixXcf_get_coeff(colvctor, 0, 0);//noise@sensor-i
					ica_config->ICAD1[i][j].real = creal(tmp32no1) * 32768;
					ica_config->ICAD1[i][j].imag = cimag(tmp32no1) * 32768;
#if !defined(USE_BSSA)
					tmp32no1 = MatrixXcf_get_coeff(MatPcaOuts, 0, j);
					MatrixXcf_set_coeff(colvctor, 0, 0, tmp32no1);
					MatrixXcf_set_coeff(colvctor, 1, 0, 0);
					MatrixXcf_multiply(MatDeMix, colvctor, colvctor); //response
					tmp32no1 = MatrixXcf_get_coeff(colvctor, 0, 0);///target@sensor-i
					ica_config->ICAD3[i][j].real = creal(tmp32no1) * 32768;
					ica_config->ICAD3[i][j].imag = cimag(tmp32no1) * 32768;
#else
					tmp32no1 = MatrixXcf_get_coeff(colvctor, 1, 0); //noise@sensor-ii
					ica_config->ICAD3[i][j].real = creal(tmp32no1) * 32768;
					ica_config->ICAD3[i][j].imag = cimag(tmp32no1) * 32768;

					tmp32no1 = MatrixXcf_get_coeff(MatDmxOuts, 0, j);//dual-ch1
					ica_config->ICAD2[i][j].real = creal(tmp32no1) * 32768;
					ica_config->ICAD2[i][j].imag = cimag(tmp32no1) * 32768;

					tmp32no1 = MatrixXcf_get_coeff(MatDmxOuts, 1, j);//dual-ch2
					ica_config->ICAD4[i][j].real = creal(tmp32no1) * 32768;
					ica_config->ICAD4[i][j].imag = cimag(tmp32no1) * 32768;
#endif
				}while (++j < nIter);

				/*PCA,pre-whitening,D^-0.5*v',block(m-1)*/
				j = 0;
				do {
					MatrixXcf_set_coeff(MatPcaOuts, 0, j,
							ica_config->DataCh1[i][j]);
					MatrixXcf_set_coeff(MatPcaOuts, 1, j,
							ica_config->DataCh2[i][j]);
				}while (++j < nIter);
				MatrixXcf_adjoint(MatPcaOuts, MatyCjOuts);
				MatrixXcf_multiply(MatPcaOuts, MatyCjOuts, MatCopy); // covariance
				MatrixXcf_scalar(MatCopy, MatCopy, 0.020833f);
				MatrixXcf_PCA(MatCopy, MatError, colvctor);//MatError=D^-0.5*v'
				//MatrixXcf_eigensolver(MatCopy, MatError, colvctor);
#if 1
				tmp32no1 = MatrixXcf_get_coeff(MatError, 0, 0);
				fwrite(&tmp32no1, sizeof(float), 2, pFiles);
				tmp32no1 = MatrixXcf_get_coeff(MatError, 0, 1);
				fwrite(&tmp32no1, sizeof(float), 2, pFiles);
				tmp32no1 = MatrixXcf_get_coeff(MatError, 1, 0);
				fwrite(&tmp32no1, sizeof(float), 2, pFiles);
				tmp32no1 = MatrixXcf_get_coeff(MatError, 1, 1);
				fwrite(&tmp32no1, sizeof(float), 2, pFiles);
#else
				tmp32no1 = MatrixXcf_get_coeff(colvctor, 0, 0);
				fwrite(&tmp32no1, sizeof(float), 2, pFiles);
				tmp32no1 = MatrixXcf_get_coeff(colvctor, 1, 0);
				fwrite(&tmp32no1, sizeof(float), 2, pFiles);
#endif
				eivalues[0] = creal(MatrixXcf_get_coeff(colvctor, 0, 0));
				eivalues[1] = creal(MatrixXcf_get_coeff(colvctor, 1, 0));
				eivalues[0] >= eivalues[1] ? 0 : MatrixXcf_rowswap(colvctor, 0, 1), MatrixXcf_rowswap(
						MatError, 0, 1);
				ica_config->eivalues[i][0] = creal(
						MatrixXcf_get_coeff(colvctor, 0, 0));
				ica_config->eivalues[i][1] = creal(
						MatrixXcf_get_coeff(colvctor, 1, 0));
				MatrixXcf_multiply(MatError, MatPcaOuts, MatPcaOuts);//Whitening
#if defined(GramSchmidt)
				MatrixXcf_FastICA(MatPcaOuts, MatCopy, 48);	//new thread
				/*tmp32no1 = MatrixXcf_get_coeff(MatCopy, 0, 0);
				 fwrite(&tmp32no1, sizeof(float), 2, pFiles);
				 tmp32no1 = MatrixXcf_get_coeff(MatCopy, 0, 1);
				 fwrite(&tmp32no1, sizeof(float), 2, pFiles);
				 tmp32no1 = MatrixXcf_get_coeff(MatCopy, 1, 0);
				 fwrite(&tmp32no1, sizeof(float), 2, pFiles);
				 tmp32no1 = MatrixXcf_get_coeff(MatCopy, 1, 1);
				 fwrite(&tmp32no1, sizeof(float), 2, pFiles);*/

				ica_config->WCh1[i][0] = MatrixXcf_get_coeff(MatCopy, 0, 0);
				ica_config->WCh1[i][1] = MatrixXcf_get_coeff(MatCopy, 0, 1);
				ica_config->WCh2[i][0] = MatrixXcf_get_coeff(MatCopy, 1, 0);
				ica_config->WCh2[i][1] = MatrixXcf_get_coeff(MatCopy, 1, 1);
#endif
				/*FastICA parameters save*/
				MatrixXcf_transpose(MatPcaOuts, MatyCjOuts); //z.'
				MatrixXcf_multiply(MatPcaOuts, MatyCjOuts, MatCopy);//z*z.'
				MatrixXcf_scalar(MatCopy, MatCopy, 0.020833f);//Phat=z*z.'/L3
				ica_config->PWC1[i][0] = MatrixXcf_get_coeff(MatCopy, 0, 0);//Phat(1,:)
				ica_config->PWC1[i][1] = MatrixXcf_get_coeff(MatCopy, 0, 1);
				ica_config->PWC2[i][0] = MatrixXcf_get_coeff(MatCopy, 1, 0);//Phat(2,:)
				ica_config->PWC2[i][1] = MatrixXcf_get_coeff(MatCopy, 1, 1);

				j = 0;
				do { //PcaChx:whitening data
					ica_config->PcaCh1[i][j] = MatrixXcf_get_coeff(MatPcaOuts, 0,
							j);
					ica_config->PcaCh2[i][j] = MatrixXcf_get_coeff(MatPcaOuts, 1,
							j);
				}while (++j < nIter);

				memcpy(ica_config->IcaCh1[i], ica_config->DataCh1[i],
						sizeof(float _Complex) * nIter); //IcaChx:ica_inputs,block(m-2)
				memcpy(ica_config->IcaCh2[i], ica_config->DataCh2[i],
						sizeof(float _Complex) * nIter);
				ica_config->PCh1[i][0] = MatrixXcf_get_coeff(MatError, 0, 0);//Whitening Matrix
				ica_config->PCh1[i][1] = MatrixXcf_get_coeff(MatError, 0, 1);
				ica_config->PCh2[i][0] = MatrixXcf_get_coeff(MatError, 1, 0);
				ica_config->PCh2[i][1] = MatrixXcf_get_coeff(MatError, 1, 1);
#if !defined(GramSchmidt)
				ica_config->WCh1[i][0] = 1; //reset deMixing Matrix
				ica_config->WCh1[i][1] = 0;
				ica_config->WCh2[i][0] = 0;
				ica_config->WCh2[i][1] = 1;
#endif
			}
			ica_config->isEmpty = 1;
		}
#endif

#if defined(ICA_THREAD)
	nCount = 0;
	for (i = 1; i < 512; i += 1) {
		register Word32 iters = 0;
		j = 0;
		do {
			MatrixXcf_set_coeff(MatPcaOuts, 0, j, *(ica_config->PcaCh1[i] + j));
			MatrixXcf_set_coeff(MatPcaOuts, 1, j, *(ica_config->PcaCh2[i] + j));
		}while (++j < nIter);

		MatrixXcf_set_coeff(MatDeMix, 0, 0, ica_config->WCh1[i][0]);
		MatrixXcf_set_coeff(MatDeMix, 0, 1, ica_config->WCh1[i][1]);
		MatrixXcf_set_coeff(MatDeMix, 1, 0, ica_config->WCh2[i][0]);
		MatrixXcf_set_coeff(MatDeMix, 1, 1, ica_config->WCh2[i][1]);

		/*FastICA,parallel joint symmetric orthogonalization*/
#if 1
		MatrixXcf_adjoint(MatDeMix, MatDeMix); //W=dxh(:,:,k)'
		MatrixXcf_set_coeff(MatCopy, 0, 0, ica_config->PWC1[i][0]);
		MatrixXcf_set_coeff(MatCopy, 0, 1, ica_config->PWC1[i][1]);
		MatrixXcf_set_coeff(MatCopy, 1, 0, ica_config->PWC2[i][0]);
		MatrixXcf_set_coeff(MatCopy, 1, 1, ica_config->PWC2[i][1]);

		MatrixXcf_adjoint(MatPcaOuts, MatyCjOuts);//z'
		do {
			MatrixXcf_multiply(MatyCjOuts, MatDeMix, MatyCjOuts); //yCj=z'*W
			MatrixXcf_multiply(MatCopy, MatDeMix, MatError);//PhatW=Phat*W
			j = 0;
			do {
				float _Complex u[2];
				u[0] = MatrixXcf_get_coeff(MatyCjOuts, j, 0);
				u[1] = MatrixXcf_get_coeff(MatyCjOuts, j, 1);
				u[0] *= powf(cabs(u[0]), 2); //(y'.*abs(y').^2)
				u[1] *= powf(cabs(u[1]), 2);//(y'.*abs(y').^2)
				MatrixXcf_set_coeff(MatyCjOuts, j, 0, u[0]);
				MatrixXcf_set_coeff(MatyCjOuts, j, 1, u[1]);
			}while (++j < nIter);
			MatrixXcf_multiply(MatPcaOuts, MatyCjOuts, MatW); //z*(y'.*abs(y').^2)/L3
			MatrixXcf_scalar(MatW, MatW, 0.020833f);
			MatrixXcf_sub(MatW, MatDeMix, MatW);
			MatrixXcf_sub(MatW, MatDeMix, MatW);
			MatrixXcf_transpose(MatDeMix, MatDeMix);
			MatrixXcf_multiply(MatDeMix, MatError, MatDeMix);//diag(W.'PhatW)
			MatrixXcf_diagonal(MatDeMix, MatDeMix);
			MatrixXcf_adjoint(MatDeMix, MatDeMix);
			MatrixXcf_transpose(MatError, MatError);
			MatrixXcf_multiply(MatDeMix, MatError, MatError);
			MatrixXcf_adjoint(MatError, MatError);
			MatrixXcf_sub(MatW, MatError, MatW);
#if 1
			MatrixXcf_adjoint(MatW, MatError);
			MatrixXcf_multiply(MatError, MatW, MatError);
			MatrixXcf_orthonormal(MatError, MatError);
			MatrixXcf_multiply(MatW, MatError, MatDeMix);
#else
			j = 0;
			do {
				float scalar;
				scalar = MatrixXcf_cols_norm(MatW); //norm(W,1)
				MatrixXcf_scalar(MatW, MatError, 1 / scalar);//W/norm(W,1)
				MatrixXcf_scalar(MatError, MatW, 1.5f);//1.5W
				MatrixXcf_adjoint(MatError, MatCopy);//W'
				MatrixXcf_multiply(MatError, MatCopy, MatCopy);//W*W'
				MatrixXcf_multiply(MatCopy, MatError, MatCopy);//W*W'*W
				MatrixXcf_scalar(MatCopy, MatCopy, 0.5f);
				MatrixXcf_sub(MatW, MatCopy, MatW);
			}while (++j < 16);
			MatrixXcf_copy(MatDeMix, MatW);
#endif
		}while (++iters < 1);
		MatrixXcf_adjoint(MatDeMix, MatDeMix); //dxh(:,:,k)=W'

#else
		do {
			MatrixXcf_multiply(MatDeMix, MatPcaOuts, MatDmxOuts);
			j = 0;
			do { //u=W*x,W+=mu*(eye(2)-(u*u')/L3)*W
				float complex u[2];
				u[0] = MatrixXcf_get_coeff(MatDmxOuts, 0, j);
				u[1] = MatrixXcf_get_coeff(MatDmxOuts, 1, j);
				u[0] = -sign(creal(u[0])) - 1.iF * sign(cimag(u[0]));
				u[1] = -sign(creal(u[1])) - 1.iF * sign(cimag(u[1]));
				MatrixXcf_set_coeff(MatNlrOuts, 0, j, u[0]);
				MatrixXcf_set_coeff(MatNlrOuts, 1, j, u[1]);
			}while (++j < nIter);
			MatrixXcf_adjoint(MatDmxOuts, MatyCjOuts); //u^H

			MatrixXcf_multiply(MatNlrOuts, MatyCjOuts, MatError);
			MatrixXcf_scalar(MatError, MatError, 0.020833f);
			MatrixXcf_add(MatError, MatIdentity, MatError);
			MatrixXcf_multiply(MatError, MatDeMix, MatCopy);
			MatrixXcf_scalar(MatCopy, MatCopy, 0.01f);
			MatrixXcf_add(MatDeMix, MatCopy, MatDeMix);
			MatrixXcf_adjoint(MatDeMix, MatW);
			MatrixXcf_multiply(MatDeMix, MatW, MatError);
			MatrixXcf_orthonormal(MatError, MatError);
			MatrixXcf_multiply(MatError, MatDeMix, MatDeMix);

		}while (++iters < 8);
#endif
		/*save ICA deMixing @ each iteration*/
#if !defined(GramSchmidt)
		ica_config->WCh1[i][0] = MatrixXcf_get_coeff(MatDeMix, 0, 0);
		ica_config->WCh1[i][1] = MatrixXcf_get_coeff(MatDeMix, 0, 1);
		ica_config->WCh2[i][0] = MatrixXcf_get_coeff(MatDeMix, 1, 0);
		ica_config->WCh2[i][1] = MatrixXcf_get_coeff(MatDeMix, 1, 1);
		nCount += ica_config->pca_flag[i];
#endif
	}
#endif

	for (i = 1; i < F_UPPER; i += 1) {
		float _Complex tmp32no1, tmp32no2;
		Word16 const alphas = 32767;
		Word16 const supGain = 2;
		Word16 Gapriori;
		Word16 tmp16no1, tmp16no2; //[x1;x2]=[a1,a2]*[s1;s2]
		Word64 tmp64no1, tmp64no2; //W*[x1;x2]=(W*A)*[s1;s2]=(P*D)*[s1;s2],inv(W)=[a1,a2]*[d1^-1,0;0,d2^-1]*P

		__real__ tmp32no1 = tmp32no3 =
				ica_config->ICAD2[i][ica_config->cntr].real =
						((Complex16_t*) stft_chn1)[i].real << b1; ///inv(W)=[a1/d1,a2/d2]*[0,1;1,0]
		__imag__ tmp32no1 = tmp32no4 =
				ica_config->ICAD2[i][ica_config->cntr].imag =
						((Complex16_t*) stft_chn1)[i].imag << b1;

		__real__ tmp32no2 = ica_config->ICAD4[i][ica_config->cntr].real =
				((Complex16_t*) stft_chn2)[i].real << b2;
		__imag__ tmp32no2 = ica_config->ICAD4[i][ica_config->cntr].imag =
				((Complex16_t*) stft_chn2)[i].imag << b2;

		MatrixXcf_set_coeff(colvctor, 0, 0, tmp32no1); //[x1;x2]
		MatrixXcf_set_coeff(colvctor, 1, 0, tmp32no2); //x=[x1;x2]
		pthread_mutex_lock(&ica_config->filter_mutex);
		MatrixXcf_set_coeff(MatError, 0, 0, ica_config->DCh1[i][0]); //unmixing-matrix
		MatrixXcf_set_coeff(MatError, 0, 1, ica_config->DCh1[i][1]); //A*s=inv(W*V)*P*D*s
		MatrixXcf_set_coeff(MatError, 1, 0, ica_config->DCh2[i][0]);
		MatrixXcf_set_coeff(MatError, 1, 1, ica_config->DCh2[i][1]);
		MatrixXcf_set_coeff(MatW, 0, 0, ica_config->uCh1[i][0]); //sudo inverse
		MatrixXcf_set_coeff(MatW, 0, 1, ica_config->uCh1[i][1]);
		MatrixXcf_set_coeff(MatW, 1, 0, ica_config->uCh2[i][0]); //A*s=inv(W*V)*P*D*s
		MatrixXcf_set_coeff(MatW, 1, 1, ica_config->uCh2[i][1]); //inv(W*V)*p<->p*(W*V)
		pthread_mutex_unlock(&ica_config->filter_mutex); //p*(W*V)*A*s=(p*P*D*s),A*s=(inv(W*V)*p)*(p*P*D*s)
		MatrixXcf_multiply(MatError, colvctor, colvctor); //y=[y1;y2]=W*x

		MatrixXcf_copy(vector2cf, colvctor); //[0;y2],noise-only
		MatrixXcf_set_coeff(colvctor, 0, 0, 0); //0-target
		MatrixXcf_multiply(MatW, colvctor, colvctor);
		tmp32no1 = MatrixXcf_get_coeff(colvctor, 0, 0);
		ica_config->ICAD1[i][ica_config->cntr].real = creal(tmp32no1); //noise_ref@ch1
		ica_config->ICAD1[i][ica_config->cntr].imag = cimag(tmp32no1);

#if defined(USE_BSSA)
		tmp32no2 = MatrixXcf_get_coeff(colvctor, 1, 0); //[0,y2],noise_ref@ch2
		ica_config->ICAD3[i][ica_config->cntr].real = creal(tmp32no2);
		ica_config->ICAD3[i][ica_config->cntr].imag = cimag(tmp32no2);
		tmp64no1 = (Word64) tmp32no3 * tmp32no3; //posterior-SNR
		tmp64no1 += (Word64) tmp32no4 * tmp32no4;
		tmp16no1 = CLZ64(tmp64no1 ^ tmp64no1 << 1);
		tmp64no1 <<= tmp16no1;
		///assert(ica_config->cntr == 0);
		///printf("%d:%I64d\n", i, tmp64no1);
		tmp32no3 = ica_config->ICAD1[i][ica_config->cntr].real;	//farFields-noise
		tmp32no4 = ica_config->ICAD1[i][ica_config->cntr].imag;
		tmp64no2 = (Word64) tmp32no3 * tmp32no3;
		tmp64no2 += (Word64) tmp32no4 * tmp32no4;
#if !defined(Wiener_Post)
		tmp64no2 *= supGain; //(1-sup*|noise|^2/|X|^2)^0.5
		tmp16no2 = CLZ64(tmp64no2 ^ tmp64no2 << 1);
		tmp64no2 <<= tmp16no2;
		///assert(ica_config->cntr == 0);
		///printf("%d:%I64d\n", i, tmp64no2);
		if (tmp64no2 > tmp64no1) {
			tmp64no2 -= tmp64no1;
			tmp32no3 = udiv_128_64(tmp64no1, tmp64no2);
			tmp32no3 += 32767;
		} else {
			tmp32no3 = udiv_128_64(tmp64no1, tmp64no2);
		}
		tmp32no3 = asr(tmp32no3, tmp16no2 - tmp16no1 - 1); //2^16*(|Nk|^2/|Yk|^2)
		tmp32no3 = max(65536 - tmp32no3, 0);
		tmp32no3 = usqrt(tmp32no3); //2^8*(1-supGain*|Nk|^2/|Yk|^2)
		ica_config->Gain[i] = tmp32no3 <<= 7; //@q15
		ica_config->ICAD2[i][ica_config->cntr].real = (Word64) tmp32no3
				* (tmp32no4 = ica_config->ICAD2[i][ica_config->cntr].real)
				>> 16;
		ica_config->ICAD2[i][ica_config->cntr].imag = (Word64) tmp32no3
				* (tmp32no4 = ica_config->ICAD2[i][ica_config->cntr].imag)
				>> 16;
		//Ch2-SNR,(1-sup*|noise|^2/|X|^2)^0.5
		tmp32no3 = ica_config->ICAD4[i][ica_config->cntr].real;
		tmp32no4 = ica_config->ICAD4[i][ica_config->cntr].imag;
		tmp64no1 = (Word64) tmp32no3 * tmp32no3;
		tmp64no1 += (Word64) tmp32no4 * tmp32no4;
		tmp16no1 = CLZ64(tmp64no1 ^ tmp64no1 << 1);
		tmp64no1 <<= tmp16no1;
		///assert(ica_config->cntr == 0);
		///printf("%d:%I64d\n", i, tmp64no1);
		tmp32no3 = ica_config->ICAD3[i][ica_config->cntr].real;
		tmp32no4 = ica_config->ICAD3[i][ica_config->cntr].imag;
		tmp64no2 = (Word64) tmp32no3 * tmp32no3;
		tmp64no2 += (Word64) tmp32no4 * tmp32no4;
		tmp64no2 *= supGain;
		tmp16no2 = CLZ64(tmp64no2 ^ tmp64no2 << 1);
		tmp64no2 <<= tmp16no2;
		///assert(ica_config->cntr == 0);
		///printf("%d:%I64d\n", i, tmp64no2);
		if (tmp64no2 > tmp64no1) {
			tmp64no2 -= tmp64no1;
			tmp32no3 = udiv_128_64(tmp64no1, tmp64no2);
			tmp32no3 += 32767;
		} else {
			tmp32no3 = udiv_128_64(tmp64no1, tmp64no2);
		}
		tmp32no3 = asr(tmp32no3, tmp16no2 - tmp16no1 - 1);
		tmp32no3 = max(65536 - tmp32no3, 0);
		tmp32no3 = usqrt(tmp32no3) << 7; //for beamforming

		ica_config->ICAD4[i][ica_config->cntr].real = (Word64) tmp32no3
				* (tmp32no4 = ica_config->ICAD4[i][ica_config->cntr].real)
				>> 16;
		ica_config->ICAD4[i][ica_config->cntr].imag = (Word64) tmp32no3
				* (tmp32no4 = ica_config->ICAD4[i][ica_config->cntr].imag)
				>> 16;
#else

#if 0
		tmp64no2 = ica_config->noise[i] - tmp64no2; //@q30
		tmp16no2 = CLZ64(tmp64no2 ^ tmp64no2 << 1);
		tmp64no2 <<= tmp16no2;
		tmp32no3 = tmp64no2 >> 32;//@q(30+(tmp16no2-32))
		tmp32no3 = (Word64) alphas * tmp32no3 >> 15;
		tmp64no2 = ica_config->noise[i] -=
		(tmp16no2 - 32 > 0) ?
		tmp32no3 >> (tmp16no2 - 32) :
		tmp32no3 << (32 - tmp16no2);
#endif
		tmp16no2 = CLZ64(tmp64no2 ^ tmp64no2 << 1); //@ch1-noise
		tmp64no2 <<= tmp16no2;
		if (tmp64no1 > tmp64no2) { //apriori-SNR,max(|Yk|^2/|Nk|^2-1,0)
			tmp64no1 -= tmp64no2;
			tmp32no3 = udiv_128_64(tmp64no2, tmp64no1);
			tmp32no3 += 32767;
		} else {
			tmp32no3 = udiv_128_64(tmp64no2, tmp64no1);
		}
		tmp32no3 = asr(tmp32no3, tmp16no1 - tmp16no2); //postSNR,@q15
		tmp16no1 = ica_config->Gain[i];//@q15
		Gapriori = L_mult(tmp16no1, tmp16no1) >> 16;//a*g(n-1,k)^2*r(n-1,k)+(1-a)*max(r(n,k)-1,0)
		tmp32no4 = (Word64) ica_config->preSNR[i] * Gapriori >> 15;
		tmp32no4 -= tmp32no4 >> 6;//a=(1-1/64)
		tmp32no3 = max((ica_config->preSNR[i] = tmp32no3) - 32767, 0);
		tmp32no3 >>= 6;
		tmp32no4 += tmp32no3;//apriori-SNR
		tmp32no3 = L_add(tmp32no4, 32768);
		tmp16no1 = CLZ(tmp32no4 ^ tmp32no4 << 1);
		tmp16no2 = CLZ(tmp32no3 ^ tmp32no3 << 1);
		tmp32no4 <<= tmp16no1;
		tmp32no3 <<= tmp16no2;
		if (tmp32no4 > tmp32no3) {
			tmp32no4 -= tmp32no3;
			tmp32no3 = udiv_64_32(tmp32no3, tmp32no4);
			tmp32no3 += 32767;
		} else {
			tmp32no3 = udiv_64_32(tmp32no3, tmp32no4);
		}
		ica_config->Gain[i] = tmp32no3 = asr(tmp32no3, tmp16no1 - tmp16no2);
		//assert(tmp32no3 < 32768);

		tmp32no4 = ica_config->ICAD2[i][ica_config->cntr].real;
		ica_config->ICAD2[i][ica_config->cntr].real = (Word64) tmp32no3
		* tmp32no4 >> 15;
		tmp32no4 = ica_config->ICAD2[i][ica_config->cntr].imag;
		ica_config->ICAD2[i][ica_config->cntr].imag = (Word64) tmp32no3
		* tmp32no4 >> 15;

		tmp32no3 = ica_config->ICAD4[i][ica_config->cntr].real;
		tmp32no4 = ica_config->ICAD4[i][ica_config->cntr].imag;
		tmp64no1 = (Word64) tmp32no3 * tmp32no3;
		tmp64no1 += (Word64) tmp32no4 * tmp32no4;
		tmp16no1 = CLZ64(tmp64no1 ^ tmp64no1 << 1);
		tmp64no1 <<= tmp16no1;

		tmp32no3 = ica_config->ICAD3[i][ica_config->cntr].real;
		tmp32no4 = ica_config->ICAD3[i][ica_config->cntr].imag;
		tmp64no2 = (Word64) tmp32no3 * tmp32no3;
		tmp64no2 += (Word64) tmp32no4 * tmp32no4;
		tmp16no2 = CLZ64(tmp64no2 ^ tmp64no2 << 1);
		tmp64no2 <<= tmp16no2;

		if (tmp64no1 > tmp64no2) {
			tmp64no1 -= tmp64no2;
			tmp32no3 = udiv_128_64(tmp64no2, tmp64no1);
			tmp32no3 += 32767;
		} else {
			tmp32no3 = udiv_128_64(tmp64no2, tmp64no1);
		}
		tmp32no3 = asr(tmp32no3, tmp16no1 - tmp16no2); //postSNR
		tmp16no1 = ica_config->Gain1[i];
		Gapriori = L_mult(tmp16no1, tmp16no1) >> 16;
		tmp32no4 = (Word64) ica_config->preSNR1[i] * Gapriori >> 15;
		tmp32no4 -= tmp32no4 >> 6;
		tmp32no3 = max((ica_config->preSNR1[i] = tmp32no3) - 32767, 0);
		tmp32no4 += tmp32no3 >> 6;//apriori-SNR
		tmp32no3 = L_add(tmp32no4, 32768);
		tmp16no1 = CLZ(tmp32no4 ^ tmp32no4 << 1);
		tmp16no2 = CLZ(tmp32no3 ^ tmp32no3 << 1);
		tmp32no4 <<= tmp16no1;
		tmp32no3 <<= tmp16no2;
		if (tmp32no4 > tmp32no3) {
			tmp32no4 -= tmp32no3;
			tmp32no3 = udiv_64_32(tmp32no3, tmp32no4);
			tmp32no3 += 32767;
		} else {
			tmp32no3 = udiv_64_32(tmp32no3, tmp32no4);
		}
		ica_config->Gain1[i] = tmp32no3 = asr(tmp32no3, tmp16no1 - tmp16no2);
		//assert(tmp32no3 < 32768);

		tmp32no4 = ica_config->ICAD4[i][ica_config->cntr].real;
		ica_config->ICAD4[i][ica_config->cntr].real = (Word64) tmp32no3
		* tmp32no4 >> 15;
		tmp32no4 = ica_config->ICAD4[i][ica_config->cntr].imag;
		ica_config->ICAD4[i][ica_config->cntr].imag = (Word64) tmp32no3
		* tmp32no4 >> 15;
#endif
#else
		MatrixXcf_set_coeff(vector2cf, 1, 0, 0); //[y1;0]
		MatrixXcf_multiply(MatW, vector2cf, vector2cf);
		tmp32no1 = MatrixXcf_get_coeff(vector2cf, 0, 0);
		ica_config->ICAD3[i][ica_config->cntr].real = creal(tmp32no1);
		ica_config->ICAD3[i][ica_config->cntr].imag = cimag(tmp32no1);
#endif

#if defined(USE_BSSA)
#if 0 //beamforming
		ica_config->ICAD2[i][ica_config->cntr].real +=
		ica_config->ICAD4[i][ica_config->cntr].real;
		ica_config->ICAD2[i][ica_config->cntr].imag +=
		ica_config->ICAD4[i][ica_config->cntr].imag;
#else
		pthread_mutex_lock(&ica_config->filter_mutex);
		MatrixXcf_set_coeff(MatW, 0, 0, ica_config->aCh1[i][0]);
		MatrixXcf_set_coeff(MatW, 0, 1, ica_config->aCh1[i][1]);
		MatrixXcf_set_coeff(MatW, 1, 0, ica_config->aCh2[i][0]);
		MatrixXcf_set_coeff(MatW, 1, 1, ica_config->aCh2[i][1]);
		pthread_mutex_unlock(&ica_config->filter_mutex);

		__real__ tmp32no1 = ica_config->ICAD2[i][ica_config->cntr].real;
		__imag__ tmp32no1 = ica_config->ICAD2[i][ica_config->cntr].imag;
		__real__ tmp32no2 = ica_config->ICAD4[i][ica_config->cntr].real;
		__imag__ tmp32no2 = ica_config->ICAD4[i][ica_config->cntr].imag;

		MatrixXcf_set_coeff(colvctor, 0, 0, tmp32no1);
		MatrixXcf_set_coeff(colvctor, 1, 0, tmp32no2);
		MatrixXcf_multiply(MatW, colvctor, colvctor);
		tmp32no1 = MatrixXcf_get_coeff(colvctor, 0, 0);
		ica_config->ICAD2[i][ica_config->cntr].real = creal(tmp32no1);
		ica_config->ICAD2[i][ica_config->cntr].imag = cimag(tmp32no1);
#endif
#else
		ica_config->ICAD2[i][ica_config->cntr] =
		ica_config->ICAD3[i][ica_config->cntr];
		ica_config->ICAD4[i][ica_config->cntr] =
		ica_config->ICAD1[i][ica_config->cntr];
#endif
	}
	tmp32no3 = 32;
	tmp32no4 = 32;
	for (i = 1; i < F_UPPER; i += 1) {
		Word32 tmp32no1;
		Word32 tmp32no2;

		tmp32no1 = ica_config->ICAD2[i][ica_config->cntr].real;
		tmp32no2 = ica_config->ICAD2[i][ica_config->cntr].imag;
		tmp32no1 ^= tmp32no1 << 1;
		tmp32no2 ^= tmp32no2 << 1;
		tmp32no1 = CLZ(tmp32no1);
		tmp32no2 = CLZ(tmp32no2);
		tmp32no3 = (tmp32no3 > tmp32no1) ? tmp32no1 : tmp32no3;
		tmp32no4 = (tmp32no4 > tmp32no2) ? tmp32no2 : tmp32no4;
	}

	tmp32no3 = min(tmp32no3, tmp32no4);
	tmp32no3 = (tmp32no3 < 16) ? 16 - tmp32no3 : 0;

#if !defined(USE_BSSA)
	zerosno1 = 32;
	zerosno2 = 32;
	for (i = 1; i < 512; i += 1) {
		Word32 tmp32no1;
		Word32 tmp32no2;

		tmp32no1 = ica_config->ICAD4[i][ica_config->cntr].real;
		tmp32no2 = ica_config->ICAD4[i][ica_config->cntr].imag;
		tmp32no1 ^= tmp32no1 << 1;
		tmp32no2 ^= tmp32no2 << 1;
		tmp32no1 = CLZ(tmp32no1);
		tmp32no2 = CLZ(tmp32no2);
		zerosno1 = (zerosno1 > tmp32no1) ? tmp32no1 : zerosno1;
		zerosno2 = (zerosno2 > tmp32no2) ? tmp32no2 : zerosno2;
	}
	zerosno1 = min(zerosno1, zerosno2);
	zerosno1 = (zerosno1 < 16) ? 16 - zerosno1 : 0;
#endif

	pthread_mutex_lock(&ica_config->queue_mutex);
	for (i = 1; i < F_UPPER; i += 1) { //buffer_mxd(:,:,k):DataChx
		float _Complex tmp32no1, tmp32no2;
		int err1, err2;
#if 0
		memmove(ica_config->DataCh1[i], &ica_config->DataCh1[i][1],
				sizeof(float _Complex) * (nIter - 1));
		memmove(ica_config->DataCh2[i], &ica_config->DataCh2[i][1],
				sizeof(float _Complex) * (nIter - 1));
		tmp32no1 = ((Complex16_t*) stft_chn1)[i].real
		+ 1.iF * ((Complex16_t*) stft_chn1)[i].imag;
		tmp32no1 *= powf(2.0, b1 - 15);
		ica_config->DataCh1[i][nIter - 1] = tmp32no1;
		tmp32no2 = ((Complex16_t*) stft_chn2)[i].real
		+ 1.iF * ((Complex16_t*) stft_chn2)[i].imag;
		tmp32no2 *= powf(2.0, b2 - 15);
		ica_config->DataCh2[i][nIter - 1] = tmp32no2;
#else
		tmp32no1 = ((Complex16_t*) stft_chn1 + i)->real
				+ 1.iF * ((Complex16_t*) stft_chn1 + i)->imag;
		tmp32no1 *= powf(2.0, b1 - 15);
		tmp32no2 = ((Complex16_t*) stft_chn2 + i)->real
				+ 1.iF * ((Complex16_t*) stft_chn2 + i)->imag;
		tmp32no2 *= powf(2.0, b2 - 15);
		err1 = WebRtc_WriteBuffer(ica_config->ringBuffer1[i], &tmp32no1, 1);
		err2 = WebRtc_WriteBuffer(ica_config->ringBuffer2[i], &tmp32no2, 1);
		assert(err1 == 1);
		assert(err2 == 1);
#endif
	}
	pthread_mutex_unlock(&ica_config->queue_mutex);

	for (i = 1; i < F_UPPER; i += 1) {
		((Complex16_t*) stft_chn1)[i].real =
				ica_config->ICAD2[i][ica_config->cntr].real >> tmp32no3;
		((Complex16_t*) stft_chn1)[i].imag =
				ica_config->ICAD2[i][ica_config->cntr].imag >> tmp32no3;
#if !defined(USE_BSSA)
		((Complex16_t*) stft_chn2)[i].real =
		ica_config->ICAD4[i][ica_config->cntr].real >> zerosno1;
		((Complex16_t*) stft_chn2)[i].imag =
		ica_config->ICAD4[i][ica_config->cntr].imag >> zerosno1;
#endif
	}
	stft_chn1[0] = 0; //dc
	stft_chn1[1] = 0; //nyquist
	memset((UWord32*) stft_chn1, 0, sizeof(UWord32) * F_LOWER);
	HS_IFFT((ComplexInt16*) stft_chn1, stft_chn1, N_ORDER);

#if !defined(USE_BSSA)
	stft_chn2[0] = 0;
	stft_chn2[1] = 0;
	memset((UWord32*) stft_chn2, 0, sizeof(UWord32) * F_LOWER);
	HS_IFFT((Complex16_t*) stft_chn2, stft_chn2, N_ORDER);
#else
	stft_chn2[0] = 0;
	stft_chn2[1] = 0;
	memset((UWord32*) stft_chn2, 0, sizeof(UWord32) * F_LOWER);
	HS_IFFT((Complex16_t*) stft_chn2, stft_chn2, N_ORDER);
#endif

#if defined(DCH)
	for (i = 0; i < 512; i += 1) {
		register Word32 L_var_out;
		L_var_out = asr(L_mult(stft_chn1[i], hann1024[i]), 16 - tmp32no3);
		stft_chn1[i] = sat_32_16(L_var_out);
		L_var_out = asr(L_mult(stft_chn1[i + 512], hann1024[511 - i]),
				16 - tmp32no3);
		stft_chn1[i + 512] = sat_32_16(L_var_out);
#if !defined(USE_BSSA)
		L_var_out = asr(L_mult(stft_chn2[i], hann1024[i]), 16 - zerosno1);
		stft_chn2[i] = sat_32_16(L_var_out);
		L_var_out = asr(L_mult(stft_chn2[i + 512], hann1024[511 - i]),
				16 - zerosno1);
		stft_chn2[i + 512] = sat_32_16(L_var_out);
#else
		//stft_chn2[i] = stft_chn1[i];
		//stft_chn2[i + 512] = stft_chn1[i + 512];
		L_var_out = asr(L_mult(stft_chn2[i], hann1024[i]), 16 - b2);
		stft_chn2[i] = sat_32_16(L_var_out);
		L_var_out = asr(L_mult(stft_chn2[i + 512], hann1024[511 - i]), 16 - b2);
		stft_chn2[i + 512] = sat_32_16(L_var_out);
#endif
	}

	for (i = 0; i < 768; i += 1) {
		register Word32 L_var_out;
		L_var_out = L_add(stft_chn1[i] << 16, ica_config->buffer_Olpa[i] << 16);
		ica_config->buffer_Olpa[i] = L_var_out >> 16;
		L_var_out = L_add(stft_chn2[i] << 16,
				ica_config->buffer_Olpa1[i] << 16);
		ica_config->buffer_Olpa1[i] = L_var_out >> 16;
	}
	memmove(Sout, ica_config->buffer_Olpa, 256 * sizeof(Word16));
	memmove(Sout1, ica_config->buffer_Olpa1, 256 * sizeof(Word16));
	memmove(ica_config->buffer_Olpa, ica_config->buffer_Olpa + 256,
			512 * sizeof(Word16));
	memmove(ica_config->buffer_Olpa + 512, stft_chn1 + 768,
			256 * sizeof(Word16));
	memmove(ica_config->buffer_Olpa1, ica_config->buffer_Olpa1 + 256,
			512 * sizeof(Word16));
	memmove(ica_config->buffer_Olpa1 + 512, stft_chn2 + 768,
			256 * sizeof(Word16));

	memmove(ica_config->mic1Buf, ica_config->mic1Buf + 256,
			sizeof(Word16) * 768);
	memmove(ica_config->mic2Buf, ica_config->mic2Buf + 256,
			sizeof(Word16) * 768);
#else
	for (i = 0; i < 256; i += 1) {
		register Word32 L_var_out;
		L_var_out = asr(L_mult(stft_chn1[i], hann512[i]), 16 - tmp32no3);
		stft_chn1[i] = sat_32_16(L_var_out);
		L_var_out = asr(L_mult(stft_chn1[i + 256], hann512[255 - i]),
				16 - tmp32no3);
		stft_chn1[i + 256] = sat_32_16(L_var_out);
#if !defined(USE_BSSA)
		L_var_out = asr(L_mult(stft_chn2[i], hann512[i]), 16 - zerosno1);
		stft_chn2[i] = sat_32_16(L_var_out);
		L_var_out = asr(L_mult(stft_chn2[i + 256], hann512[255 - i]),
				16 - zerosno1);
		stft_chn2[i + 256] = sat_32_16(L_var_out);
#else
		//stft_chn2[i] = stft_chn1[i];
		//stft_chn2[i + 256] = stft_chn1[i + 256];
		L_var_out = asr(L_mult(stft_chn2[i], hann512[i]), 16 - b2);
		stft_chn2[i] = sat_32_16(L_var_out);
		L_var_out = asr(L_mult(stft_chn2[i + 256], hann512[255 - i]), 16 - b2);
		stft_chn2[i + 256] = sat_32_16(L_var_out);
#endif
	}
	for (i = 0; i < 256; i += 1) {
		register Word32 L_var_out;
		L_var_out = L_add(stft_chn1[i] << 16, ica_config->buffer_Olpa[i] << 16);
		ica_config->buffer_Olpa[i] = L_var_out >> 16;
		L_var_out = L_add(stft_chn2[i] << 16,
				ica_config->buffer_Olpa1[i] << 16);
		ica_config->buffer_Olpa1[i] = L_var_out >> 16;
	}
	memmove(Sout, ica_config->buffer_Olpa, 256 * sizeof(Word16));
	memmove(Sout1, ica_config->buffer_Olpa1, 256 * sizeof(Word16));
	memmove(ica_config->buffer_Olpa, stft_chn1 + 256, 256 * sizeof(Word16));

	memmove(ica_config->buffer_Olpa1, stft_chn2 + 256, 256 * sizeof(Word16));

	memmove(ica_config->mic1Buf, ica_config->mic1Buf + 256,
			sizeof(Word16) * 256);
	memmove(ica_config->mic2Buf, ica_config->mic2Buf + 256,
			sizeof(Word16) * 256);

#endif
	ica_config->cntr = (ica_config->cntr + 1) % nIter;
	ica_config->Iters = 1;

	MatrixXcf_delete(MatDeMix);
	MatrixXcf_delete(MatError);
	MatrixXcf_delete(MatCopy);
	MatrixXcf_delete(MatW);
	MatrixXcf_delete(MatIdentity);
	MatrixXcf_delete(MatPcaOuts);
	MatrixXcf_delete(MatDmxOuts);
	MatrixXcf_delete(MatNlrOuts);
	MatrixXcf_delete(MatyCjOuts);
	MatrixXcf_delete(colvctor);
	MatrixXcf_delete(vector2cf);
}
#endif
