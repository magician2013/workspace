16:50:14 **** Incremental Build of configuration Debug for project eigens ****
Info: Internal Builder is used for build
g++ -O2 -g -Wall -c -fmessage-length=0 -std=c++11 -ftemplate-backtrace-limit=0 -o binary_library.o "..\\binary_library.cpp" 
..\binary_library.cpp: In function 'void MatrixXcf_FastICA(C_MatrixXcf*, C_MatrixXcf*, int)':
..\binary_library.cpp:307:12: warning: unused variable 'nIter' [-Wunused-variable]
  int const nIter = 8;
            ^~~~~
..\binary_library.cpp:308:20: warning: unused variable 'k' [-Wunused-variable]
  int i = 0, j = 0, k = 0;
                    ^
..\binary_library.cpp: In function 'void matrixxci_pca(C_MatrixXci64_t*, C_MatrixXci64_t*, C_MatrixXci64_t*)':
..\binary_library.cpp:653:11: warning: unused variable 'tmp16no1' [-Wunused-variable]
   int16_t tmp16no1, tmp16no2;
           ^~~~~~~~
..\binary_library.cpp:653:21: warning: unused variable 'tmp16no2' [-Wunused-variable]
   int16_t tmp16no1, tmp16no2;
                     ^~~~~~~~
..\binary_library.cpp: In function 'void MatrixXcf_PCA(C_MatrixXcf*, C_MatrixXcf*, C_MatrixXcf*)':
..\binary_library.cpp:761:13: warning: unused variable 'nIter' [-Wunused-variable]
  const int &nIter = 16;
             ^~~~~
..\binary_library.cpp: In function 'void MatrixXcf_eigensolver(const C_MatrixXcf*, C_MatrixXcf*, C_MatrixXcf*)':
..\binary_library.cpp:949:6: warning: unused variable 'i' [-Wunused-variable]
  int i, j;
      ^
..\binary_library.cpp:949:9: warning: unused variable 'j' [-Wunused-variable]
  int i, j;
         ^
..\binary_library.cpp:950:6: warning: unused variable 'rows' [-Wunused-variable]
  int rows = C_to_Eigen<const MatrixXcf, const C_MatrixXcf>(m1).rows();
      ^~~~
..\binary_library.cpp:951:6: warning: unused variable 'cols' [-Wunused-variable]
  int cols = C_to_Eigen<const MatrixXcf, const C_MatrixXcf>(m1).cols();
      ^~~~
In file included from ..\Eigen/Core:420:0,
                 from ..\binary_library.cpp:18:
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::Matrix<double, -1, -1>; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::Matrix<double, -1, -1>; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Matrix<double, -1, -1>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, -1, -1>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:278:27:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&&) [with _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:137:47:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_mean<double>, 1>, -1, -1> >, Eigen::internal::sub_assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_mean<double>, 1>, -1, -1> >, Eigen::internal::sub_assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_mean<double>, 1>, -1, -1>; Functor = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_mean<double>, 1>, -1, -1>; Functor = Eigen::internal::sub_assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_mean<double>, 1>, -1, -1>; Func = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_mean<double>, 1>, -1, -1>; Func = Eigen::internal::sub_assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/CwiseBinaryOp.h:164:18:   required from 'Derived& Eigen::MatrixBase<Derived>::operator-=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_mean<double>, 1>, -1, -1>; Derived = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >]'
..\binary_library.cpp:144:43:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, 1> >, Eigen::internal::evaluator<Eigen::Matrix<double, -1, 1> >, Eigen::internal::sub_assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, 1> >, Eigen::internal::evaluator<Eigen::Matrix<double, -1, 1> >, Eigen::internal::sub_assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, 1>; SrcXprType = Eigen::Matrix<double, -1, 1>; Functor = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, 1>; SrcXprType = Eigen::Matrix<double, -1, 1>; Functor = Eigen::internal::sub_assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, 1>; Src = Eigen::Matrix<double, -1, 1>; Func = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:828:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<double, -1, 1>; Src = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, 1>, 0>, 0>; Func = Eigen::internal::sub_assign_op<double, double>; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/CwiseBinaryOp.h:164:18:   required from 'Derived& Eigen::MatrixBase<Derived>::operator-=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, 1>, 0>, 0>; Derived = Eigen::Matrix<double, -1, 1>]'
..\binary_library.cpp:153:37:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Array<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::Array<long long int, -1, -1, 0, -1, -1> >, Eigen::internal::mul_assign_op<std::complex<long long int>, long long int> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Array<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::Array<long long int, -1, -1, 0, -1, -1> >, Eigen::internal::mul_assign_op<std::complex<long long int>, long long int>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Array<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::Array<long long int, -1, -1, 0, -1, -1>; Functor = Eigen::internal::mul_assign_op<std::complex<long long int>, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Array<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::Array<long long int, -1, -1, 0, -1, -1>; Functor = Eigen::internal::mul_assign_op<std::complex<long long int>, long long int>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Array<std::complex<long long int>, -1, -1>; Src = Eigen::Array<long long int, -1, -1, 0, -1, -1>; Func = Eigen::internal::mul_assign_op<std::complex<long long int>, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Array<std::complex<long long int>, -1, -1>; Src = Eigen::Array<long long int, -1, -1, 0, -1, -1>; Func = Eigen::internal::mul_assign_op<std::complex<long long int>, long long int>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/ArrayBase.h:207:18:   required from 'Derived& Eigen::ArrayBase<Derived>::operator*=(const Eigen::ArrayBase<OtherDerived>&) [with OtherDerived = Eigen::Array<long long int, -1, -1, 0, -1, -1>; Derived = Eigen::Array<std::complex<long long int>, -1, -1>]'
..\binary_library.cpp:233:30:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<long long int, std::complex<long long int> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> >, const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::internal::sub_assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<long long int, std::complex<long long int> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> >, const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::internal::sub_assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<long long int, std::complex<long long int> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> >, const Eigen::Matrix<std::complex<long long int>, -1, -1> >; Functor = Eigen::internal::sub_assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<long long int, std::complex<long long int> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> >, const Eigen::Matrix<std::complex<long long int>, -1, -1> >; Functor = Eigen::internal::sub_assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<long long int, std::complex<long long int> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> >, const Eigen::Matrix<std::complex<long long int>, -1, -1> >; Func = Eigen::internal::sub_assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<long long int, std::complex<long long int> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> >, const Eigen::Matrix<std::complex<long long int>, -1, -1> >; Func = Eigen::internal::sub_assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/CwiseBinaryOp.h:164:18:   required from 'Derived& Eigen::MatrixBase<Derived>::operator-=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<long long int, std::complex<long long int> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> >, const Eigen::Matrix<std::complex<long long int>, -1, -1> >; Derived = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\binary_library.cpp:253:12:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::sub_assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::sub_assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; Functor = Eigen::internal::sub_assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; Functor = Eigen::internal::sub_assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::Matrix<std::complex<long long int>, -1, -1>; Func = Eigen::internal::sub_assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::Matrix<std::complex<long long int>, -1, -1>; Func = Eigen::internal::sub_assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/CwiseBinaryOp.h:164:18:   required from 'Derived& Eigen::MatrixBase<Derived>::operator-=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<std::complex<long long int>, -1, -1>; Derived = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\binary_library.cpp:268:8:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::Matrix<std::complex<float>, -1, -1>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::Matrix<std::complex<float>, -1, -1>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Matrix<std::complex<float>, -1, -1>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<std::complex<float>, -1, -1>; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:278:27:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&&) [with _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:312:55:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::Matrix<std::complex<long long int>, -1, -1>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<std::complex<long long int>, -1, -1>; Derived = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:278:27:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&&) [with _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:331:65:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::internal::div_assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::internal::div_assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Functor = Eigen::internal::div_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Functor = Eigen::internal::div_assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Func = Eigen::internal::div_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Func = Eigen::internal::div_assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/SelfCwiseBinaryOp.h:45:28:   required from 'Derived& Eigen::DenseBase<Derived>::operator/=(const Scalar&) [with Derived = Eigen::Matrix<std::complex<float>, -1, -1>; Eigen::DenseBase<Derived>::Scalar = std::complex<float>]'
..\binary_library.cpp:340:10:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::internal::mul_assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::internal::mul_assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, 1> >; Functor = Eigen::internal::mul_assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, 1> >; Functor = Eigen::internal::mul_assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, 1> >; Func = Eigen::internal::mul_assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, 1> >; Func = Eigen::internal::mul_assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/SelfCwiseBinaryOp.h:21:28:   required from 'Derived& Eigen::DenseBase<Derived>::operator*=(const Scalar&) [with Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>; Eigen::DenseBase<Derived>::Scalar = std::complex<long long int>]'
..\binary_library.cpp:425:8:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, 1, -1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, 1, -1> > >, Eigen::internal::div_assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, 1, -1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, 1, -1> > >, Eigen::internal::div_assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, 1, -1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, 1, -1> >; Functor = Eigen::internal::div_assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, 1, -1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, 1, -1> >; Functor = Eigen::internal::div_assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, 1, -1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, 1, -1> >; Func = Eigen::internal::div_assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, 1, -1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, 1, -1> >; Func = Eigen::internal::div_assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/SelfCwiseBinaryOp.h:45:28:   required from 'Derived& Eigen::DenseBase<Derived>::operator/=(const Scalar&) [with Derived = Eigen::Matrix<std::complex<long long int>, 1, -1>; Eigen::DenseBase<Derived>::Scalar = std::complex<long long int>]'
..\binary_library.cpp:437:10:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Array<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<long long int, long long int>, const Eigen::Array<long long int, -1, -1, 0, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Array<long long int, -1, -1, 0, -1, -1> > > >, Eigen::internal::mul_assign_op<std::complex<long long int>, long long int> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Array<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<long long int, long long int>, const Eigen::Array<long long int, -1, -1, 0, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Array<long long int, -1, -1, 0, -1, -1> > > >, Eigen::internal::mul_assign_op<std::complex<long long int>, long long int>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Array<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<long long int, long long int>, const Eigen::Array<long long int, -1, -1, 0, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Array<long long int, -1, -1, 0, -1, -1> > >; Functor = Eigen::internal::mul_assign_op<std::complex<long long int>, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Array<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<long long int, long long int>, const Eigen::Array<long long int, -1, -1, 0, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Array<long long int, -1, -1, 0, -1, -1> > >; Functor = Eigen::internal::mul_assign_op<std::complex<long long int>, long long int>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Array<std::complex<long long int>, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<long long int, long long int>, const Eigen::Array<long long int, -1, -1, 0, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Array<long long int, -1, -1, 0, -1, -1> > >; Func = Eigen::internal::mul_assign_op<std::complex<long long int>, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Array<std::complex<long long int>, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<long long int, long long int>, const Eigen::Array<long long int, -1, -1, 0, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Array<long long int, -1, -1, 0, -1, -1> > >; Func = Eigen::internal::mul_assign_op<std::complex<long long int>, long long int>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/ArrayBase.h:207:18:   required from 'Derived& Eigen::ArrayBase<Derived>::operator*=(const Eigen::ArrayBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<long long int, long long int>, const Eigen::Array<long long int, -1, -1, 0, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Array<long long int, -1, -1, 0, -1, -1> > >; Derived = Eigen::Array<std::complex<long long int>, -1, -1>]'
..\binary_library.cpp:439:41:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Array<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Array<std::complex<long long int>, -1, -1> > >, Eigen::internal::div_assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Array<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Array<std::complex<long long int>, -1, -1> > >, Eigen::internal::div_assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Array<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Array<std::complex<long long int>, -1, -1> >; Functor = Eigen::internal::div_assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Array<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Array<std::complex<long long int>, -1, -1> >; Functor = Eigen::internal::div_assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Array<std::complex<long long int>, -1, -1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Array<std::complex<long long int>, -1, -1> >; Func = Eigen::internal::div_assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Array<std::complex<long long int>, -1, -1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Array<std::complex<long long int>, -1, -1> >; Func = Eigen::internal::div_assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/SelfCwiseBinaryOp.h:45:28:   required from 'Derived& Eigen::DenseBase<Derived>::operator/=(const Scalar&) [with Derived = Eigen::Array<std::complex<long long int>, -1, -1>; Eigen::DenseBase<Derived>::Scalar = std::complex<long long int>]'
..\binary_library.cpp:440:13:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, 1, 1, 0, 1, 1> > >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> > > >, Eigen::internal::sub_assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, 1, 1, 0, 1, 1> > >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> > > >, Eigen::internal::sub_assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, 1, 1, 0, 1, 1> > >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> > >; Functor = Eigen::internal::sub_assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, 1, 1, 0, 1, 1> > >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> > >; Functor = Eigen::internal::sub_assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, 1, 1, 0, 1, 1> > >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> > >; Func = Eigen::internal::sub_assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, 1, 1, 0, 1, 1> > >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> > >; Func = Eigen::internal::sub_assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/CwiseBinaryOp.h:164:18:   required from 'Derived& Eigen::MatrixBase<Derived>::operator-=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, 1, 1, 0, 1, 1> > >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> > >; Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\binary_library.cpp:442:58:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::internal::div_assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::internal::div_assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, 1> >; Functor = Eigen::internal::div_assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, 1> >; Functor = Eigen::internal::div_assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, 1> >; Func = Eigen::internal::div_assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, 1> >; Func = Eigen::internal::div_assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/SelfCwiseBinaryOp.h:45:28:   required from 'Derived& Eigen::DenseBase<Derived>::operator/=(const Scalar&) [with Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>; Eigen::DenseBase<Derived>::Scalar = std::complex<long long int>]'
..\binary_library.cpp:444:10:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> > > >, Eigen::internal::sub_assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> > > >, Eigen::internal::sub_assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> > >; Functor = Eigen::internal::sub_assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> > >; Functor = Eigen::internal::sub_assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> > >; Func = Eigen::internal::sub_assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> > >; Func = Eigen::internal::sub_assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/CwiseBinaryOp.h:164:18:   required from 'Derived& Eigen::MatrixBase<Derived>::operator-=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> > >; Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\binary_library.cpp:445:21:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1> > >, Eigen::internal::mul_assign_op<long long int, long long int> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1> > >, Eigen::internal::mul_assign_op<long long int, long long int>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >; Functor = Eigen::internal::mul_assign_op<long long int, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >; Functor = Eigen::internal::mul_assign_op<long long int, long long int>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >; Func = Eigen::internal::mul_assign_op<long long int, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >; Func = Eigen::internal::mul_assign_op<long long int, long long int>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/SelfCwiseBinaryOp.h:21:28:   required from 'Derived& Eigen::DenseBase<Derived>::operator*=(const Scalar&) [with Derived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Eigen::DenseBase<Derived>::Scalar = long long int]'
..\binary_library.cpp:514:15:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1> > >, Eigen::internal::div_assign_op<long long int, long long int> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1> > >, Eigen::internal::div_assign_op<long long int, long long int>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >; Functor = Eigen::internal::div_assign_op<long long int, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >; Functor = Eigen::internal::div_assign_op<long long int, long long int>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >; Func = Eigen::internal::div_assign_op<long long int, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >; Func = Eigen::internal::div_assign_op<long long int, long long int>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/SelfCwiseBinaryOp.h:45:28:   required from 'Derived& Eigen::DenseBase<Derived>::operator/=(const Scalar&) [with Derived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Eigen::DenseBase<Derived>::Scalar = long long int]'
..\binary_library.cpp:519:13:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, Eigen::internal::sub_assign_op<long long int, long long int> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, Eigen::internal::sub_assign_op<long long int, long long int>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; SrcXprType = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Functor = Eigen::internal::sub_assign_op<long long int, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; SrcXprType = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Functor = Eigen::internal::sub_assign_op<long long int, long long int>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Func = Eigen::internal::sub_assign_op<long long int, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Func = Eigen::internal::sub_assign_op<long long int, long long int>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/CwiseBinaryOp.h:164:18:   required from 'Derived& Eigen::MatrixBase<Derived>::operator-=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Derived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>]'
..\binary_library.cpp:522:16:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::internal::sub_assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::internal::sub_assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; SrcXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; Functor = Eigen::internal::sub_assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; SrcXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; Functor = Eigen::internal::sub_assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::Matrix<std::complex<long long int>, -1, 1>; Func = Eigen::internal::sub_assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::Matrix<std::complex<long long int>, -1, 1>; Func = Eigen::internal::sub_assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/CwiseBinaryOp.h:164:18:   required from 'Derived& Eigen::MatrixBase<Derived>::operator-=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<std::complex<long long int>, -1, 1>; Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\binary_library.cpp:601:16:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::internal::mul_assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::internal::mul_assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Functor = Eigen::internal::mul_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Functor = Eigen::internal::mul_assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Func = Eigen::internal::mul_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Func = Eigen::internal::mul_assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/SelfCwiseBinaryOp.h:21:28:   required from 'Derived& Eigen::DenseBase<Derived>::operator*=(const Scalar&) [with Derived = Eigen::Matrix<std::complex<float>, -1, -1>; Eigen::DenseBase<Derived>::Scalar = std::complex<float>]'
..\binary_library.cpp:790:12:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> > >, Eigen::internal::div_assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> > >, Eigen::internal::div_assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, 1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Functor = Eigen::internal::div_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, 1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Functor = Eigen::internal::div_assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, 1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Func = Eigen::internal::div_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, 1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Func = Eigen::internal::div_assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/SelfCwiseBinaryOp.h:45:28:   required from 'Derived& Eigen::DenseBase<Derived>::operator/=(const Scalar&) [with Derived = Eigen::Matrix<std::complex<float>, -1, 1>; Eigen::DenseBase<Derived>::Scalar = std::complex<float>]'
..\binary_library.cpp:804:14:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true> >, Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true> >, Eigen::internal::swap_assign_op<std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true> >, Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true> >, Eigen::internal::swap_assign_op<std::complex<float> >, 1>'
..\Eigen/src/Core/Swap.h:19:7:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true> >, Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true> >, Eigen::internal::swap_assign_op<std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>; SrcXprType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>; Functor = Eigen::internal::swap_assign_op<std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>; SrcXprType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>; Functor = Eigen::internal::swap_assign_op<std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>; Src = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>; Func = Eigen::internal::swap_assign_op<std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>; Src = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>; Func = Eigen::internal::swap_assign_op<std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/DenseBase.h:418:22:   required from 'void Eigen::DenseBase<Derived>::swap(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>; Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>]'
..\binary_library.cpp:976:49:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false> >, Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false> >, Eigen::internal::swap_assign_op<std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false> >, Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false> >, Eigen::internal::swap_assign_op<std::complex<float> >, 1>'
..\Eigen/src/Core/Swap.h:19:7:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false> >, Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false> >, Eigen::internal::swap_assign_op<std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>; SrcXprType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>; Functor = Eigen::internal::swap_assign_op<std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>; SrcXprType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>; Functor = Eigen::internal::swap_assign_op<std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>; Src = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>; Func = Eigen::internal::swap_assign_op<std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>; Src = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>; Func = Eigen::internal::swap_assign_op<std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/DenseBase.h:418:22:   required from 'void Eigen::DenseBase<Derived>::swap(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>; Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>]'
..\binary_library.cpp:981:49:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:537:19:   required from 'Eigen::PlainObjectBase<Derived>::PlainObjectBase(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:379:29:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:137:47:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:537:19:   required from 'Eigen::PlainObjectBase<Derived>::PlainObjectBase(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:379:29:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:138:43:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::MatrixWrapper<const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::ArrayWrapper<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, const Eigen::ArrayWrapper<const Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>, -1, -1> > > > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::MatrixWrapper<const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::ArrayWrapper<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, const Eigen::ArrayWrapper<const Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>, -1, -1> > > > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::MatrixWrapper<const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::ArrayWrapper<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, const Eigen::ArrayWrapper<const Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>, -1, -1> > > >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::MatrixWrapper<const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::ArrayWrapper<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, const Eigen::ArrayWrapper<const Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>, -1, -1> > > >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::MatrixWrapper<const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::ArrayWrapper<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, const Eigen::ArrayWrapper<const Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>, -1, -1> > > >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::MatrixWrapper<const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::ArrayWrapper<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, const Eigen::ArrayWrapper<const Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>, -1, -1> > > >; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::MatrixWrapper<const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::ArrayWrapper<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, const Eigen::ArrayWrapper<const Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>, -1, -1> > > >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::MatrixWrapper<const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::ArrayWrapper<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, const Eigen::ArrayWrapper<const Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>, -1, -1> > > >; Derived = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >]'
..\binary_library.cpp:145:73:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:537:19:   required from 'Eigen::PlainObjectBase<Derived>::PlainObjectBase(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:379:29:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:147:40:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, 1> >, Eigen::internal::evaluator<Eigen::Matrix<double, -1, 1> >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, 1> >, Eigen::internal::evaluator<Eigen::Matrix<double, -1, 1> >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, 1>; SrcXprType = Eigen::Matrix<double, -1, 1>; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, 1>; SrcXprType = Eigen::Matrix<double, -1, 1>; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, 1>; Src = Eigen::Matrix<double, -1, 1>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, -1, 1>; Derived = Eigen::Matrix<double, -1, 1>]'
..\Eigen/src/Core/Matrix.h:278:27:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&&) [with _Scalar = double; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Core/Dot.h:128:30:   required from 'const PlainObject Eigen::MatrixBase<Derived>::normalized() const [with Derived = Eigen::Matrix<double, -1, 1>; Eigen::MatrixBase<Derived>::PlainObject = Eigen::Matrix<double, -1, 1>]'
..\binary_library.cpp:154:21:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true> >, Eigen::internal::evaluator<Eigen::Matrix<double, -1, 1> >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true> >, Eigen::internal::evaluator<Eigen::Matrix<double, -1, 1> >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>; SrcXprType = Eigen::Matrix<double, -1, 1>; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>; SrcXprType = Eigen::Matrix<double, -1, 1>; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>; Src = Eigen::Matrix<double, -1, 1>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>; Src = Eigen::Matrix<double, -1, 1>; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>; Src = Eigen::Matrix<double, -1, 1>]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, -1, 1>; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>]'
..\binary_library.cpp:156:17:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Matrix<double, -1, -1>; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Matrix<double, -1, -1>; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Matrix<double, -1, -1>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:828:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 0>; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 0>]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 0>; Derived = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >]'
..\binary_library.cpp:166:15:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::internal::evaluator<Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::internal::assign_op<std::complex<double>, std::complex<double> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::internal::evaluator<Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::internal::assign_op<std::complex<double>, std::complex<double> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<double>, -1, -1>; SrcXprType = Eigen::Matrix<std::complex<double>, -1, -1>; Functor = Eigen::internal::assign_op<std::complex<double>, std::complex<double> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<double>, -1, -1>; SrcXprType = Eigen::Matrix<std::complex<double>, -1, -1>; Functor = Eigen::internal::assign_op<std::complex<double>, std::complex<double> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<double>, -1, -1>; Src = Eigen::Matrix<std::complex<double>, -1, -1>; Func = Eigen::internal::assign_op<std::complex<double>, std::complex<double> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<std::complex<double>, -1, -1>; Derived = Eigen::Matrix<std::complex<double>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:278:27:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&&) [with _Scalar = std::complex<double>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Eigenvalues/EigenSolver.h:373:10:   required from 'Eigen::EigenSolver<_MatrixType>::EigenvectorsType Eigen::EigenSolver<_MatrixType>::eigenvectors() const [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::EigenSolver<_MatrixType>::EigenvectorsType = Eigen::Matrix<std::complex<double>, -1, -1>; typename Eigen::NumTraits<typename Derived::Scalar>::Real = double]'
..\binary_library.cpp:177:27:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Array<long long int, -1, -1, 0, -1, -1> >, Eigen::internal::evaluator<Eigen::Array<long long int, -1, -1, 0, -1, -1> >, Eigen::internal::assign_op<long long int, long long int> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Array<long long int, -1, -1, 0, -1, -1> >, Eigen::internal::evaluator<Eigen::Array<long long int, -1, -1, 0, -1, -1> >, Eigen::internal::assign_op<long long int, long long int>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Array<long long int, -1, -1, 0, -1, -1>; SrcXprType = Eigen::Array<long long int, -1, -1, 0, -1, -1>; Functor = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Array<long long int, -1, -1, 0, -1, -1>; SrcXprType = Eigen::Array<long long int, -1, -1, 0, -1, -1>; Functor = Eigen::internal::assign_op<long long int, long long int>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Array<long long int, -1, -1, 0, -1, -1>; Src = Eigen::Array<long long int, -1, -1, 0, -1, -1>; Func = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Array<long long int, -1, -1, 0, -1, -1>; Derived = Eigen::Array<long long int, -1, -1, 0, -1, -1>]'
..\Eigen/src/Core/Array.h:157:27:   required from 'Eigen::Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Array(Eigen::Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&&) [with _Scalar = long long int; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/DenseBase.h:406:62:   required from 'Eigen::DenseBase<Derived>::EvalReturnType Eigen::DenseBase<Derived>::eval() const [with Derived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_abs2_op<std::complex<long long int> >, const Eigen::Array<std::complex<long long int>, -1, -1> >; Eigen::DenseBase<Derived>::EvalReturnType = const Eigen::Array<long long int, -1, -1, 0, -1, -1>]'
..\binary_library.cpp:233:30:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:537:19:   required from 'Eigen::PlainObjectBase<Derived>::PlainObjectBase(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:379:29:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:312:55:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, float>, const Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, const Eigen::Matrix<float, -1, -1> > > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, float>, const Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, const Eigen::Matrix<float, -1, -1> > > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, float>, const Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, const Eigen::Matrix<float, -1, -1> > >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, float>, const Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, const Eigen::Matrix<float, -1, -1> > >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, float>, const Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, const Eigen::Matrix<float, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, float>, const Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, const Eigen::Matrix<float, -1, -1> > >; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:537:19:   required from 'Eigen::PlainObjectBase<Derived>::PlainObjectBase(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, float>, const Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, const Eigen::Matrix<float, -1, -1> > >; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:379:29:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, float>, const Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, const Eigen::Matrix<float, -1, -1> > >; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:315:43:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseUnaryOp<Eigen::internal::scalar_cast_op<std::complex<float>, std::complex<long long int> >, const Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseUnaryOp<Eigen::internal::scalar_cast_op<std::complex<float>, std::complex<long long int> >, const Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_cast_op<std::complex<float>, std::complex<long long int> >, const Eigen::Matrix<std::complex<float>, -1, -1> >; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_cast_op<std::complex<float>, std::complex<long long int> >, const Eigen::Matrix<std::complex<float>, -1, -1> >; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::CwiseUnaryOp<Eigen::internal::scalar_cast_op<std::complex<float>, std::complex<long long int> >, const Eigen::Matrix<std::complex<float>, -1, -1> >; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_cast_op<std::complex<float>, std::complex<long long int> >, const Eigen::Matrix<std::complex<float>, -1, -1> >; Derived = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:537:19:   required from 'Eigen::PlainObjectBase<Derived>::PlainObjectBase(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_cast_op<std::complex<float>, std::complex<long long int> >, const Eigen::Matrix<std::complex<float>, -1, -1> >; Derived = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:379:29:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_cast_op<std::complex<float>, std::complex<long long int> >, const Eigen::Matrix<std::complex<float>, -1, -1> >; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:331:65:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> > > >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> > > >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> > >; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> > >; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> > >; Derived = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:537:19:   required from 'Eigen::PlainObjectBase<Derived>::PlainObjectBase(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> > >; Derived = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:379:29:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> > >; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:414:47:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, -1> >; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, -1> >; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, -1> >; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, -1> >; Derived = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:537:19:   required from 'Eigen::PlainObjectBase<Derived>::PlainObjectBase(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, -1> >; Derived = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:379:29:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, -1> >; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:419:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, -1> >; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, -1> >; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, -1> >; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, -1> >; Derived = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:537:19:   required from 'Eigen::PlainObjectBase<Derived>::PlainObjectBase(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, -1> >; Derived = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:379:29:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, -1> >; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:420:53:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<long long int>, -1, -1>, -1, 1, true> >, Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<long long int>, -1, -1>, -1, 1, true> >, Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<std::complex<long long int>, -1, -1>, -1, 1, true>; SrcXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<std::complex<long long int>, -1, -1>, -1, 1, true>; SrcXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<long long int>, -1, -1>, -1, 1, true>; Src = Eigen::Matrix<std::complex<long long int>, -1, 1>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<long long int>, -1, -1>, -1, 1, true>; Src = Eigen::Matrix<std::complex<long long int>, -1, 1>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<long long int>, -1, -1>, -1, 1, true>; Src = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<std::complex<long long int>, -1, 1>; Derived = Eigen::Block<Eigen::Matrix<std::complex<long long int>, -1, -1>, -1, 1, true>]'
..\binary_library.cpp:489:17:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<long long int, -1, -1>, -1, 1, true> >, Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, Eigen::internal::assign_op<long long int, long long int> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<long long int, -1, -1>, -1, 1, true> >, Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, Eigen::internal::assign_op<long long int, long long int>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<long long int, -1, -1>, -1, 1, true>; SrcXprType = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Functor = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<long long int, -1, -1>, -1, 1, true>; SrcXprType = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Functor = Eigen::internal::assign_op<long long int, long long int>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Matrix<long long int, -1, -1>, -1, 1, true>; Src = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Func = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Matrix<long long int, -1, -1>, -1, 1, true>; Src = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Func = Eigen::internal::assign_op<long long int, long long int>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Block<Eigen::Matrix<long long int, -1, -1>, -1, 1, true>; Src = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Derived = Eigen::Block<Eigen::Matrix<long long int, -1, -1>, -1, 1, true>]'
..\binary_library.cpp:543:17:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1> >, Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1> >, Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; SrcXprType = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; SrcXprType = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; Src = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; Derived = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>]'
..\Eigen/src/Core/Matrix.h:278:27:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&&) [with _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 1; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/DenseBase.h:406:62:   required from 'Eigen::DenseBase<Derived>::EvalReturnType Eigen::DenseBase<Derived>::eval() const [with Derived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >; Eigen::DenseBase<Derived>::EvalReturnType = const Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>]'
..\binary_library.cpp:923:42:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, 1> >, Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, 1> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, 1> >, Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, 1> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, 1>; SrcXprType = Eigen::Matrix<std::complex<float>, -1, 1>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, 1>; SrcXprType = Eigen::Matrix<std::complex<float>, -1, 1>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, 1>; Src = Eigen::Matrix<std::complex<float>, -1, 1>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<std::complex<float>, -1, 1>; Derived = Eigen::Matrix<std::complex<float>, -1, 1>]'
..\Eigen/src/Core/Matrix.h:278:27:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&&) [with _Scalar = std::complex<float>; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/QR/ColPivHouseholderQR.h:48:38:   required from 'const Eigen::CompleteOrthogonalDecomposition<typename Eigen::DenseBase<Derived>::PlainObject> Eigen::MatrixBase<Derived>::completeOrthogonalDecomposition() const [with Derived = Eigen::Matrix<std::complex<float>, -1, -1>; typename Eigen::DenseBase<Derived>::PlainObject = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:943:87:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<long long int, 1, -1, 1, 1, -1> >, Eigen::internal::evaluator<Eigen::Matrix<long long int, 1, -1, 1, 1, -1> >, Eigen::internal::assign_op<long long int, long long int> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<long long int, 1, -1, 1, 1, -1> >, Eigen::internal::evaluator<Eigen::Matrix<long long int, 1, -1, 1, 1, -1> >, Eigen::internal::assign_op<long long int, long long int>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<long long int, 1, -1, 1, 1, -1>; SrcXprType = Eigen::Matrix<long long int, 1, -1, 1, 1, -1>; Functor = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<long long int, 1, -1, 1, 1, -1>; SrcXprType = Eigen::Matrix<long long int, 1, -1, 1, 1, -1>; Functor = Eigen::internal::assign_op<long long int, long long int>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<long long int, 1, -1, 1, 1, -1>; Src = Eigen::Matrix<long long int, 1, -1, 1, 1, -1>; Func = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<long long int, 1, -1, 1, 1, -1>; Derived = Eigen::Matrix<long long int, 1, -1, 1, 1, -1>]'
..\Eigen/src/Core/Matrix.h:278:27:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&&) [with _Scalar = long long int; int _Rows = 1; int _Cols = -1; int _Options = 1; int _MaxRows = 1; int _MaxCols = -1]'
..\Eigen/src/QR/ColPivHouseholderQR.h:48:38:   required from 'const Eigen::CompleteOrthogonalDecomposition<typename Eigen::DenseBase<Derived>::PlainObject> Eigen::MatrixBase<Derived>::completeOrthogonalDecomposition() const [with Derived = Eigen::Matrix<std::complex<float>, -1, -1>; typename Eigen::DenseBase<Derived>::PlainObject = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:943:87:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, 1, -1> >, Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, 1, -1> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, 1, -1> >, Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, 1, -1> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, 1, -1>; SrcXprType = Eigen::Matrix<std::complex<float>, 1, -1>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, 1, -1>; SrcXprType = Eigen::Matrix<std::complex<float>, 1, -1>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, 1, -1>; Src = Eigen::Matrix<std::complex<float>, 1, -1>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<std::complex<float>, 1, -1>; Derived = Eigen::Matrix<std::complex<float>, 1, -1>]'
..\Eigen/src/Core/Matrix.h:278:27:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&&) [with _Scalar = std::complex<float>; int _Rows = 1; int _Cols = -1; int _Options = 1; int _MaxRows = 1; int _MaxCols = -1]'
..\Eigen/src/QR/ColPivHouseholderQR.h:48:38:   required from 'const Eigen::CompleteOrthogonalDecomposition<typename Eigen::DenseBase<Derived>::PlainObject> Eigen::MatrixBase<Derived>::completeOrthogonalDecomposition() const [with Derived = Eigen::Matrix<std::complex<float>, -1, -1>; typename Eigen::DenseBase<Derived>::PlainObject = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:943:87:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<float, 1, -1> >, Eigen::internal::evaluator<Eigen::Matrix<float, 1, -1> >, Eigen::internal::assign_op<float, float> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<float, 1, -1> >, Eigen::internal::evaluator<Eigen::Matrix<float, 1, -1> >, Eigen::internal::assign_op<float, float>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<float, 1, -1>; SrcXprType = Eigen::Matrix<float, 1, -1>; Functor = Eigen::internal::assign_op<float, float>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<float, 1, -1>; SrcXprType = Eigen::Matrix<float, 1, -1>; Functor = Eigen::internal::assign_op<float, float>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<float, 1, -1>; Src = Eigen::Matrix<float, 1, -1>; Func = Eigen::internal::assign_op<float, float>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<float, 1, -1>; Derived = Eigen::Matrix<float, 1, -1>]'
..\Eigen/src/Core/Matrix.h:278:27:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&&) [with _Scalar = float; int _Rows = 1; int _Cols = -1; int _Options = 1; int _MaxRows = 1; int _MaxCols = -1]'
..\Eigen/src/QR/ColPivHouseholderQR.h:48:38:   required from 'const Eigen::CompleteOrthogonalDecomposition<typename Eigen::DenseBase<Derived>::PlainObject> Eigen::MatrixBase<Derived>::completeOrthogonalDecomposition() const [with Derived = Eigen::Matrix<std::complex<float>, -1, -1>; typename Eigen::DenseBase<Derived>::PlainObject = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:943:87:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, const Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, const Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, const Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, const Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, const Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, const Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, const Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, const Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >; Derived = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >]'
..\binary_library.cpp:1105:53:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, 1> >, Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true> >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, 1> >, Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true> >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, 1>; SrcXprType = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, 1>; SrcXprType = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, 1>; Src = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<double, -1, 1>; Src = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, -1, 1>; Src = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>; Derived = Eigen::Matrix<double, -1, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>; _Scalar = double; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\binary_library.cpp:150:17:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> > > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> > > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> > >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> > >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> > >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> > >; Derived = Eigen::Matrix<double, -1, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:537:19:   required from 'Eigen::PlainObjectBase<Derived>::PlainObjectBase(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> > >; Derived = Eigen::Matrix<double, -1, 1>]'
..\Eigen/src/Core/Matrix.h:379:29:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> > >; _Scalar = double; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Core/Dot.h:128:30:   required from 'const PlainObject Eigen::MatrixBase<Derived>::normalized() const [with Derived = Eigen::Matrix<double, -1, 1>; Eigen::MatrixBase<Derived>::PlainObject = Eigen::Matrix<double, -1, 1>]'
..\binary_library.cpp:154:21:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, 1> >, Eigen::internal::evaluator<Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<Eigen::Matrix<double, -1, 1> > > > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, 1> >, Eigen::internal::evaluator<Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<Eigen::Matrix<double, -1, 1> > > > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, 1>; SrcXprType = Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<Eigen::Matrix<double, -1, 1> > > >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, 1>; SrcXprType = Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<Eigen::Matrix<double, -1, 1> > > >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, 1>; Src = Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<Eigen::Matrix<double, -1, 1> > > >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<double, -1, 1>; Src = Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<Eigen::Matrix<double, -1, 1> > > >; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, -1, 1>; Src = Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<Eigen::Matrix<double, -1, 1> > > >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<Eigen::Matrix<double, -1, 1> > > >; Derived = Eigen::Matrix<double, -1, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<Eigen::Matrix<double, -1, 1> > > >; _Scalar = double; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\binary_library.cpp:164:40:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::DiagonalWrapper<const Eigen::Matrix<double, -1, 1> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 1> >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::DiagonalWrapper<const Eigen::Matrix<double, -1, 1> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 1> >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::Product<Eigen::DiagonalWrapper<const Eigen::Matrix<double, -1, 1> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 1>; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::Product<Eigen::DiagonalWrapper<const Eigen::Matrix<double, -1, 1> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 1>; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::DiagonalWrapper<const Eigen::Matrix<double, -1, 1> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 1>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::DiagonalWrapper<const Eigen::Matrix<double, -1, 1> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 1>; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::DiagonalWrapper<const Eigen::Matrix<double, -1, 1> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::DiagonalWrapper<const Eigen::Matrix<double, -1, 1> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 1>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::DiagonalWrapper<const Eigen::Matrix<double, -1, 1> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 1>; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:165:47:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_cube_op<double>, const Eigen::ArrayWrapper<Eigen::Matrix<double, -1, -1> > > > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_cube_op<double>, const Eigen::ArrayWrapper<Eigen::Matrix<double, -1, -1> > > > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_cube_op<double>, const Eigen::ArrayWrapper<Eigen::Matrix<double, -1, -1> > > >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_cube_op<double>, const Eigen::ArrayWrapper<Eigen::Matrix<double, -1, -1> > > >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_cube_op<double>, const Eigen::ArrayWrapper<Eigen::Matrix<double, -1, -1> > > >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_cube_op<double>, const Eigen::ArrayWrapper<Eigen::Matrix<double, -1, -1> > > >; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_cube_op<double>, const Eigen::ArrayWrapper<Eigen::Matrix<double, -1, -1> > > >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_cube_op<double>, const Eigen::ArrayWrapper<Eigen::Matrix<double, -1, -1> > > >; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_cube_op<double>, const Eigen::ArrayWrapper<Eigen::Matrix<double, -1, -1> > > >; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:170:31:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:171:27:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> >, const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_square_op<double>, const Eigen::ArrayWrapper<Eigen::Matrix<double, -1, -1> > > > > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> >, const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_square_op<double>, const Eigen::ArrayWrapper<Eigen::Matrix<double, -1, -1> > > > > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> >, const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_square_op<double>, const Eigen::ArrayWrapper<Eigen::Matrix<double, -1, -1> > > > >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> >, const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_square_op<double>, const Eigen::ArrayWrapper<Eigen::Matrix<double, -1, -1> > > > >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> >, const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_square_op<double>, const Eigen::ArrayWrapper<Eigen::Matrix<double, -1, -1> > > > >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> >, const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_square_op<double>, const Eigen::ArrayWrapper<Eigen::Matrix<double, -1, -1> > > > >; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> >, const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_square_op<double>, const Eigen::ArrayWrapper<Eigen::Matrix<double, -1, -1> > > > >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> >, const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_square_op<double>, const Eigen::ArrayWrapper<Eigen::Matrix<double, -1, -1> > > > >; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> >, const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_square_op<double>, const Eigen::ArrayWrapper<Eigen::Matrix<double, -1, -1> > > > >; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:172:37:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:173:38:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::DiagonalWrapper<const Eigen::Matrix<double, -1, -1> >, 1> > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::DiagonalWrapper<const Eigen::Matrix<double, -1, -1> >, 1> > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::DiagonalWrapper<const Eigen::Matrix<double, -1, -1> >, 1> >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::DiagonalWrapper<const Eigen::Matrix<double, -1, -1> >, 1> >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::DiagonalWrapper<const Eigen::Matrix<double, -1, -1> >, 1> >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::DiagonalWrapper<const Eigen::Matrix<double, -1, -1> >, 1> >; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::DiagonalWrapper<const Eigen::Matrix<double, -1, -1> >, 1> >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::DiagonalWrapper<const Eigen::Matrix<double, -1, -1> >, 1> >; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::DiagonalWrapper<const Eigen::Matrix<double, -1, -1> >, 1> >; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:174:34:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<double>, -1, -1>, -1, 1, true> >, Eigen::internal::evaluator<Eigen::CwiseUnaryOp<Eigen::internal::scalar_cast_op<double, std::complex<double> >, const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, true> > >, Eigen::internal::assign_op<std::complex<double>, std::complex<double> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<double>, -1, -1>, -1, 1, true> >, Eigen::internal::evaluator<Eigen::CwiseUnaryOp<Eigen::internal::scalar_cast_op<double, std::complex<double> >, const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, true> > >, Eigen::internal::assign_op<std::complex<double>, std::complex<double> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<std::complex<double>, -1, -1>, -1, 1, true>; SrcXprType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_cast_op<double, std::complex<double> >, const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, true> >; Functor = Eigen::internal::assign_op<std::complex<double>, std::complex<double> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<std::complex<double>, -1, -1>, -1, 1, true>; SrcXprType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_cast_op<double, std::complex<double> >, const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, true> >; Functor = Eigen::internal::assign_op<std::complex<double>, std::complex<double> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<double>, -1, -1>, -1, 1, true>; Src = Eigen::CwiseUnaryOp<Eigen::internal::scalar_cast_op<double, std::complex<double> >, const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, true> >; Func = Eigen::internal::assign_op<std::complex<double>, std::complex<double> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<double>, -1, -1>, -1, 1, true>; Src = Eigen::CwiseUnaryOp<Eigen::internal::scalar_cast_op<double, std::complex<double> >, const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, true> >; Func = Eigen::internal::assign_op<std::complex<double>, std::complex<double> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<double>, -1, -1>, -1, 1, true>; Src = Eigen::CwiseUnaryOp<Eigen::internal::scalar_cast_op<double, std::complex<double> >, const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, true> >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_cast_op<double, std::complex<double> >, const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, true> >; Derived = Eigen::Block<Eigen::Matrix<std::complex<double>, -1, -1>, -1, 1, true>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:357:19:   required from 'Eigen::EigenSolver<_MatrixType>::EigenvectorsType Eigen::EigenSolver<_MatrixType>::eigenvectors() const [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::EigenSolver<_MatrixType>::EigenvectorsType = Eigen::Matrix<std::complex<double>, -1, -1>; typename Eigen::NumTraits<typename Derived::Scalar>::Real = double]'
..\binary_library.cpp:177:27:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<double>, -1, -1>, -1, 1, true> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, 1> > >, Eigen::internal::div_assign_op<std::complex<double>, std::complex<double> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<double>, -1, -1>, -1, 1, true> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, 1> > >, Eigen::internal::div_assign_op<std::complex<double>, std::complex<double> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<std::complex<double>, -1, -1>, -1, 1, true>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, 1> >; Functor = Eigen::internal::div_assign_op<std::complex<double>, std::complex<double> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<std::complex<double>, -1, -1>, -1, 1, true>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, 1> >; Functor = Eigen::internal::div_assign_op<std::complex<double>, std::complex<double> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<double>, -1, -1>, -1, 1, true>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, 1> >; Func = Eigen::internal::div_assign_op<std::complex<double>, std::complex<double> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<double>, -1, -1>, -1, 1, true>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, 1> >; Func = Eigen::internal::div_assign_op<std::complex<double>, std::complex<double> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/SelfCwiseBinaryOp.h:45:28:   required from 'Derived& Eigen::DenseBase<Derived>::operator/=(const Scalar&) [with Derived = Eigen::Block<Eigen::Matrix<std::complex<double>, -1, -1>, -1, 1, true>; Eigen::DenseBase<Derived>::Scalar = std::complex<double>]'
..\Eigen/src/Core/Dot.h:147:15:   required from 'void Eigen::MatrixBase<Derived>::normalize() [with Derived = Eigen::Block<Eigen::Matrix<std::complex<double>, -1, -1>, -1, 1, true>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:358:7:   required from 'Eigen::EigenSolver<_MatrixType>::EigenvectorsType Eigen::EigenSolver<_MatrixType>::eigenvectors() const [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::EigenSolver<_MatrixType>::EigenvectorsType = Eigen::Matrix<std::complex<double>, -1, -1>; typename Eigen::NumTraits<typename Derived::Scalar>::Real = double]'
..\binary_library.cpp:177:27:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:199:32:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<long long int, std::complex<long long int> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, -1> > > >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<long long int, std::complex<long long int> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, -1> > > >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<long long int, std::complex<long long int> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, -1> > >; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<long long int, std::complex<long long int> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, -1> > >; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<long long int, std::complex<long long int> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<long long int, std::complex<long long int> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<long long int, std::complex<long long int> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, -1> > >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<long long int, std::complex<long long int> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, -1> > >; Derived = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<long long int, std::complex<long long int> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, -1> > >; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:211:51:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Array<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > > > >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Array<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > > > >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Array<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > > >; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Array<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > > >; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Array<std::complex<long long int>, -1, -1>; Src = Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > > >; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Array<std::complex<long long int>, -1, -1>; Src = Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > > >; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Array<std::complex<long long int>, -1, -1>; Src = Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > > >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > > >; Derived = Eigen::Array<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/Array.h:109:24:   required from 'Eigen::Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > > >; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:232:30:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Array<long long int, -1, -1, 0, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseUnaryOp<Eigen::internal::scalar_abs2_op<std::complex<long long int> >, const Eigen::Array<std::complex<long long int>, -1, -1> > >, Eigen::internal::assign_op<long long int, long long int> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Array<long long int, -1, -1, 0, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseUnaryOp<Eigen::internal::scalar_abs2_op<std::complex<long long int> >, const Eigen::Array<std::complex<long long int>, -1, -1> > >, Eigen::internal::assign_op<long long int, long long int>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Array<long long int, -1, -1, 0, -1, -1>; SrcXprType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_abs2_op<std::complex<long long int> >, const Eigen::Array<std::complex<long long int>, -1, -1> >; Functor = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Array<long long int, -1, -1, 0, -1, -1>; SrcXprType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_abs2_op<std::complex<long long int> >, const Eigen::Array<std::complex<long long int>, -1, -1> >; Functor = Eigen::internal::assign_op<long long int, long long int>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Array<long long int, -1, -1, 0, -1, -1>; Src = Eigen::CwiseUnaryOp<Eigen::internal::scalar_abs2_op<std::complex<long long int> >, const Eigen::Array<std::complex<long long int>, -1, -1> >; Func = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_abs2_op<std::complex<long long int> >, const Eigen::Array<std::complex<long long int>, -1, -1> >; Derived = Eigen::Array<long long int, -1, -1, 0, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::CwiseUnaryOp<Eigen::internal::scalar_abs2_op<std::complex<long long int> >, const Eigen::Array<std::complex<long long int>, -1, -1> >; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_abs2_op<std::complex<long long int> >, const Eigen::Array<std::complex<long long int>, -1, -1> >; Derived = Eigen::Array<long long int, -1, -1, 0, -1, -1>]'
..\Eigen/src/Core/Array.h:173:31:   required from 'Eigen::Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Array(const T&) [with T = Eigen::CwiseUnaryOp<Eigen::internal::scalar_abs2_op<std::complex<long long int> >, const Eigen::Array<std::complex<long long int>, -1, -1> >; _Scalar = long long int; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/DenseBase.h:406:48:   required from 'Eigen::DenseBase<Derived>::EvalReturnType Eigen::DenseBase<Derived>::eval() const [with Derived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_abs2_op<std::complex<long long int> >, const Eigen::Array<std::complex<long long int>, -1, -1> >; Eigen::DenseBase<Derived>::EvalReturnType = const Eigen::Array<long long int, -1, -1, 0, -1, -1>]'
..\binary_library.cpp:233:30:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::Diagonal<Eigen::Matrix<std::complex<long long int>, -1, -1>, 0> >, 1> >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::Diagonal<Eigen::Matrix<std::complex<long long int>, -1, -1>, 0> >, 1> >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::Diagonal<Eigen::Matrix<std::complex<long long int>, -1, -1>, 0> >, 1>; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::Diagonal<Eigen::Matrix<std::complex<long long int>, -1, -1>, 0> >, 1>; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::Diagonal<Eigen::Matrix<std::complex<long long int>, -1, -1>, 0> >, 1>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::Diagonal<Eigen::Matrix<std::complex<long long int>, -1, -1>, 0> >, 1>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::Diagonal<Eigen::Matrix<std::complex<long long int>, -1, -1>, 0> >, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::Diagonal<Eigen::Matrix<std::complex<long long int>, -1, -1>, 0> >, 1>; Derived = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::Diagonal<Eigen::Matrix<std::complex<long long int>, -1, -1>, 0> >, 1>; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:261:58:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:302:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<long long int>, -1, -1>, -1, 1, true> >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<long long int>, -1, -1>, -1, 1, true> >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; SrcXprType = Eigen::Block<Eigen::Matrix<std::complex<long long int>, -1, -1>, -1, 1, true>; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; SrcXprType = Eigen::Block<Eigen::Matrix<std::complex<long long int>, -1, -1>, -1, 1, true>; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::Block<Eigen::Matrix<std::complex<long long int>, -1, -1>, -1, 1, true>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::Block<Eigen::Matrix<std::complex<long long int>, -1, -1>, -1, 1, true>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::Block<Eigen::Matrix<std::complex<long long int>, -1, -1>, -1, 1, true>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Matrix<std::complex<long long int>, -1, -1>, -1, 1, true>; Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Matrix<std::complex<long long int>, -1, -1>, -1, 1, true>; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\binary_library.cpp:424:17:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; SrcXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; SrcXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::Matrix<std::complex<long long int>, -1, 1>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:828:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\binary_library.cpp:428:18:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, 1, -1> >, Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, 1, -1> >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, 1, -1> >, Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, 1, -1> >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, 1, -1>; SrcXprType = Eigen::Matrix<std::complex<long long int>, 1, -1>; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, 1, -1>; SrcXprType = Eigen::Matrix<std::complex<long long int>, 1, -1>; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, 1, -1>; Src = Eigen::Matrix<std::complex<long long int>, 1, -1>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:828:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, 1, -1>; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<long long int>, 1, -1>; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, 1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; _Scalar = std::complex<long long int>; int _Rows = 1; int _Cols = -1; int _Options = 1; int _MaxRows = 1; int _MaxCols = -1]'
..\binary_library.cpp:436:23:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Array<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, 1, -1> > > > >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Array<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, 1, -1> > > > >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Array<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, 1, -1> > > >; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Array<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, 1, -1> > > >; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Array<std::complex<long long int>, -1, -1>; Src = Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, 1, -1> > > >; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Array<std::complex<long long int>, -1, -1>; Src = Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, 1, -1> > > >; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Array<std::complex<long long int>, -1, -1>; Src = Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, 1, -1> > > >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, 1, -1> > > >; Derived = Eigen::Array<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/Array.h:109:24:   required from 'Eigen::Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, 1, -1> > > >; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:438:31:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<std::complex<long long int>, std::complex<long long int> >, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::MatrixWrapper<Eigen::Array<std::complex<long long int>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> > >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> > >, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<long long int, std::complex<long long int> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> > > >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<std::complex<long long int>, std::complex<long long int> >, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::MatrixWrapper<Eigen::Array<std::complex<long long int>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> > >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> > >, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<long long int, std::complex<long long int> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> > > >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<std::complex<long long int>, std::complex<long long int> >, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::MatrixWrapper<Eigen::Array<std::complex<long long int>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> > >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> > >, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<long long int, std::complex<long long int> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> > >; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<std::complex<long long int>, std::complex<long long int> >, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::MatrixWrapper<Eigen::Array<std::complex<long long int>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> > >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> > >, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<long long int, std::complex<long long int> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> > >; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<std::complex<long long int>, std::complex<long long int> >, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::MatrixWrapper<Eigen::Array<std::complex<long long int>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> > >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> > >, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<long long int, std::complex<long long int> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> > >; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<std::complex<long long int>, std::complex<long long int> >, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::MatrixWrapper<Eigen::Array<std::complex<long long int>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> > >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> > >, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<long long int, std::complex<long long int> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> > >; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<std::complex<long long int>, std::complex<long long int> >, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::MatrixWrapper<Eigen::Array<std::complex<long long int>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> > >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> > >, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<long long int, std::complex<long long int> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> > >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<std::complex<long long int>, std::complex<long long int> >, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::MatrixWrapper<Eigen::Array<std::complex<long long int>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> > >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> > >, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<long long int, std::complex<long long int> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> > >; Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<std::complex<long long int>, std::complex<long long int> >, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::MatrixWrapper<Eigen::Array<std::complex<long long int>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> > >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> > >, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<long long int, std::complex<long long int> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> > >; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\binary_library.cpp:441:52:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<long long int>, Eigen::Matrix<long long int, -1, -1> > >, Eigen::internal::assign_op<long long int, long long int> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<long long int>, Eigen::Matrix<long long int, -1, -1> > >, Eigen::internal::assign_op<long long int, long long int>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<long long int, -1, -1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<long long int>, Eigen::Matrix<long long int, -1, -1> >; Functor = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<long long int, -1, -1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<long long int>, Eigen::Matrix<long long int, -1, -1> >; Functor = Eigen::internal::assign_op<long long int, long long int>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<long long int, -1, -1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<long long int>, Eigen::Matrix<long long int, -1, -1> >; Func = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<long long int, -1, -1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<long long int>, Eigen::Matrix<long long int, -1, -1> >; Func = Eigen::internal::assign_op<long long int, long long int>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<long long int, -1, -1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<long long int>, Eigen::Matrix<long long int, -1, -1> >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<long long int>, Eigen::Matrix<long long int, -1, -1> >; Derived = Eigen::Matrix<long long int, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<long long int>, Eigen::Matrix<long long int, -1, -1> >; _Scalar = long long int; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:510:44:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, -1> > >, Eigen::internal::assign_op<long long int, long long int> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, -1> > >, Eigen::internal::assign_op<long long int, long long int>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<long long int, -1, -1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, -1> >; Functor = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<long long int, -1, -1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, -1> >; Functor = Eigen::internal::assign_op<long long int, long long int>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<long long int, -1, -1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, -1> >; Func = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<long long int, -1, -1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, -1> >; Func = Eigen::internal::assign_op<long long int, long long int>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<long long int, -1, -1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, -1> >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, -1> >; Derived = Eigen::Matrix<long long int, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, -1> >; _Scalar = long long int; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:511:38:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<long long int, -1, -1>, -1, 1, true> >, Eigen::internal::assign_op<long long int, long long int> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<long long int, -1, -1>, -1, 1, true> >, Eigen::internal::assign_op<long long int, long long int>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; SrcXprType = Eigen::Block<Eigen::Matrix<long long int, -1, -1>, -1, 1, true>; Functor = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; SrcXprType = Eigen::Block<Eigen::Matrix<long long int, -1, -1>, -1, 1, true>; Functor = Eigen::internal::assign_op<long long int, long long int>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::Block<Eigen::Matrix<long long int, -1, -1>, -1, 1, true>; Func = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::Block<Eigen::Matrix<long long int, -1, -1>, -1, 1, true>; Func = Eigen::internal::assign_op<long long int, long long int>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::Block<Eigen::Matrix<long long int, -1, -1>, -1, 1, true>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Matrix<long long int, -1, -1>, -1, 1, true>; Derived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Matrix<long long int, -1, -1>, -1, 1, true>; _Scalar = long long int; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\binary_library.cpp:513:26:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, Eigen::internal::assign_op<long long int, long long int> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, Eigen::internal::assign_op<long long int, long long int>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; SrcXprType = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Functor = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; SrcXprType = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Functor = Eigen::internal::assign_op<long long int, long long int>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Func = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:828:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Func = Eigen::internal::assign_op<long long int, long long int>; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Derived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; _Scalar = long long int; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\binary_library.cpp:517:24:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, -1> >, Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, -1> >, Eigen::internal::assign_op<long long int, long long int> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, -1> >, Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, -1> >, Eigen::internal::assign_op<long long int, long long int>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<long long int, -1, -1>; SrcXprType = Eigen::Matrix<long long int, -1, -1>; Functor = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<long long int, -1, -1>; SrcXprType = Eigen::Matrix<long long int, -1, -1>; Functor = Eigen::internal::assign_op<long long int, long long int>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<long long int, -1, -1>; Src = Eigen::Matrix<long long int, -1, -1>; Func = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<long long int, -1, -1>; Src = Eigen::Matrix<long long int, -1, -1>; Func = Eigen::internal::assign_op<long long int, long long int>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<long long int, -1, -1>; Src = Eigen::Matrix<long long int, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<long long int, -1, -1>; Derived = Eigen::Matrix<long long int, -1, -1>]'
..\Eigen/src/Core/Matrix.h:208:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&) [with _Scalar = long long int; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:552:53:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, -1> >, Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, Eigen::internal::assign_op<long long int, long long int> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, -1> >, Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, Eigen::internal::assign_op<long long int, long long int>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<long long int, -1, -1>; SrcXprType = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Functor = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<long long int, -1, -1>; SrcXprType = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Functor = Eigen::internal::assign_op<long long int, long long int>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<long long int, -1, -1>; Src = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Func = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<long long int, -1, -1>; Src = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Func = Eigen::internal::assign_op<long long int, long long int>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<long long int, -1, -1>; Src = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Derived = Eigen::Matrix<long long int, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; _Scalar = long long int; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:553:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > > >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > > >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >; Derived = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:685:24:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::DiagonalWrapper<const Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 1> >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::DiagonalWrapper<const Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 1> >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::Product<Eigen::DiagonalWrapper<const Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 1>; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::Product<Eigen::DiagonalWrapper<const Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 1>; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::Product<Eigen::DiagonalWrapper<const Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 1>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::Product<Eigen::DiagonalWrapper<const Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 1>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::Product<Eigen::DiagonalWrapper<const Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::DiagonalWrapper<const Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 1>; Derived = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::DiagonalWrapper<const Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 1>; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:686:30:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::Matrix<std::complex<long long int>, -1, 1>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::Matrix<std::complex<long long int>, -1, 1>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<std::complex<long long int>, -1, 1>; Derived = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<std::complex<long long int>, -1, 1>; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:688:59:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, 1> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, 1> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::Matrix<std::complex<float>, -1, 1>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::Matrix<std::complex<float>, -1, 1>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Matrix<std::complex<float>, -1, 1>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Matrix<std::complex<float>, -1, 1>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Matrix<std::complex<float>, -1, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<std::complex<float>, -1, 1>; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<std::complex<float>, -1, 1>; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:829:51:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> > >, Eigen::internal::mul_assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> > >, Eigen::internal::mul_assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Functor = Eigen::internal::mul_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Functor = Eigen::internal::mul_assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Func = Eigen::internal::mul_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Func = Eigen::internal::mul_assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/SelfCwiseBinaryOp.h:21:28:   required from 'Derived& Eigen::DenseBase<Derived>::operator*=(const Scalar&) [with Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>; Eigen::DenseBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/SVD/JacobiSVD.h:750:39:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<float, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, Eigen::Matrix<float, -1, 1> > >, Eigen::internal::mul_assign_op<float, float> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<float, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, Eigen::Matrix<float, -1, 1> > >, Eigen::internal::mul_assign_op<float, float>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<float, -1, 1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, Eigen::Matrix<float, -1, 1> >; Functor = Eigen::internal::mul_assign_op<float, float>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<float, -1, 1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, Eigen::Matrix<float, -1, 1> >; Functor = Eigen::internal::mul_assign_op<float, float>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<float, -1, 1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, Eigen::Matrix<float, -1, 1> >; Func = Eigen::internal::mul_assign_op<float, float>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<float, -1, 1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, Eigen::Matrix<float, -1, 1> >; Func = Eigen::internal::mul_assign_op<float, float>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/SelfCwiseBinaryOp.h:21:28:   required from 'Derived& Eigen::DenseBase<Derived>::operator*=(const Scalar&) [with Derived = Eigen::Matrix<float, -1, 1>; Eigen::DenseBase<Derived>::Scalar = float]'
..\Eigen/src/SVD/JacobiSVD.h:761:20:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<std::complex<float>, std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, -1>, const Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<std::complex<float>, std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, -1>, const Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<std::complex<float>, std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, -1>, const Eigen::Matrix<std::complex<float>, -1, -1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<std::complex<float>, std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, -1>, const Eigen::Matrix<std::complex<float>, -1, -1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<std::complex<float>, std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, -1>, const Eigen::Matrix<std::complex<float>, -1, -1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<std::complex<float>, std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, -1>, const Eigen::Matrix<std::complex<float>, -1, -1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<std::complex<float>, std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, -1>, const Eigen::Matrix<std::complex<float>, -1, -1> >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<std::complex<float>, std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, -1>, const Eigen::Matrix<std::complex<float>, -1, -1> >; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<std::complex<float>, std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, -1>, const Eigen::Matrix<std::complex<float>, -1, -1> >; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:918:55:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; SrcXprType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; SrcXprType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; Src = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >; Derived = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >; Derived = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 1; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/DenseBase.h:406:48:   required from 'Eigen::DenseBase<Derived>::EvalReturnType Eigen::DenseBase<Derived>::eval() const [with Derived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >; Eigen::DenseBase<Derived>::EvalReturnType = const Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>]'
..\binary_library.cpp:923:42:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:923:42:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, -1> > > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, -1> > > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, -1> > >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, -1> > >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, -1> > >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, -1> > >; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, -1> > >; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:929:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, float>, const Eigen::Matrix<std::complex<float>, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, const Eigen::Matrix<float, -1, -1> > > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, float>, const Eigen::Matrix<std::complex<float>, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, const Eigen::Matrix<float, -1, -1> > > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, float>, const Eigen::Matrix<std::complex<float>, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, const Eigen::Matrix<float, -1, -1> > >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, float>, const Eigen::Matrix<std::complex<float>, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, const Eigen::Matrix<float, -1, -1> > >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, float>, const Eigen::Matrix<std::complex<float>, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, const Eigen::Matrix<float, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, float>, const Eigen::Matrix<std::complex<float>, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, const Eigen::Matrix<float, -1, -1> > >; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:537:19:   required from 'Eigen::PlainObjectBase<Derived>::PlainObjectBase(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, float>, const Eigen::Matrix<std::complex<float>, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, const Eigen::Matrix<float, -1, -1> > >; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:379:29:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, float>, const Eigen::Matrix<std::complex<float>, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, const Eigen::Matrix<float, -1, -1> > >; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/Dot.h:128:30:   required from 'const PlainObject Eigen::MatrixBase<Derived>::normalized() const [with Derived = Eigen::Matrix<std::complex<float>, -1, -1>; Eigen::MatrixBase<Derived>::PlainObject = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:934:37:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<Eigen::Matrix<std::complex<float>, -1, -1> > > > >, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 1> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<Eigen::Matrix<std::complex<float>, -1, -1> > > > >, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 1> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::Product<Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<Eigen::Matrix<std::complex<float>, -1, -1> > > > >, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 1>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::Product<Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<Eigen::Matrix<std::complex<float>, -1, -1> > > > >, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 1>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Product<Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<Eigen::Matrix<std::complex<float>, -1, -1> > > > >, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 1>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Product<Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<Eigen::Matrix<std::complex<float>, -1, -1> > > > >, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 1>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Product<Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<Eigen::Matrix<std::complex<float>, -1, -1> > > > >, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<Eigen::Matrix<std::complex<float>, -1, -1> > > > >, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 1>; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<Eigen::Matrix<std::complex<float>, -1, -1> > > > >, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 1>; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:970:32:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1> >, Eigen::internal::evaluator<Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1> >, Eigen::internal::evaluator<Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; SrcXprType = Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; SrcXprType = Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; Src = Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >; Derived = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >; OtherDerived = Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >; Derived = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 1; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/DenseBase.h:406:48:   required from 'Eigen::DenseBase<Derived>::EvalReturnType Eigen::DenseBase<Derived>::eval() const [with Derived = Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >; Eigen::DenseBase<Derived>::EvalReturnType = const Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>]'
..\binary_library.cpp:986:38:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<std::complex<float>, std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, -1>, const Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<std::complex<float>, std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, -1>, const Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<std::complex<float>, std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, -1>, const Eigen::Matrix<std::complex<float>, -1, -1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<std::complex<float>, std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, -1>, const Eigen::Matrix<std::complex<float>, -1, -1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<std::complex<float>, std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, -1>, const Eigen::Matrix<std::complex<float>, -1, -1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<std::complex<float>, std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, -1>, const Eigen::Matrix<std::complex<float>, -1, -1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<std::complex<float>, std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, -1>, const Eigen::Matrix<std::complex<float>, -1, -1> >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<std::complex<float>, std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, -1>, const Eigen::Matrix<std::complex<float>, -1, -1> >; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<std::complex<float>, std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, -1>, const Eigen::Matrix<std::complex<float>, -1, -1> >; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:993:55:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:1039:34:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::Matrix<double, -1, -1> > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::Matrix<double, -1, -1> > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::Matrix<double, -1, -1> >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::Matrix<double, -1, -1> >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::Matrix<double, -1, -1> >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::Matrix<double, -1, -1> >; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::Matrix<double, -1, -1> >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::Matrix<double, -1, -1> >; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::Matrix<double, -1, -1> >; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:1061:53:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> > >, Eigen::internal::mul_assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> > >, Eigen::internal::mul_assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Functor = Eigen::internal::mul_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Functor = Eigen::internal::mul_assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Func = Eigen::internal::mul_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Func = Eigen::internal::mul_assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/SelfCwiseBinaryOp.h:21:28:   required from 'Derived& Eigen::DenseBase<Derived>::operator*=(const Scalar&) [with Derived = Eigen::Matrix<double, -1, -1>; Eigen::DenseBase<Derived>::Scalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:276:10:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> > >, Eigen::internal::div_assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> > >, Eigen::internal::div_assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Functor = Eigen::internal::div_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Functor = Eigen::internal::div_assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Func = Eigen::internal::div_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Func = Eigen::internal::div_assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/SelfCwiseBinaryOp.h:45:28:   required from 'Derived& Eigen::DenseBase<Derived>::operator/=(const Scalar&) [with Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Eigen::DenseBase<Derived>::Scalar = double]'
..\Eigen/src/Eigenvalues/EigenSolver.h:525:40:   required from 'void Eigen::EigenSolver<_MatrixType>::doComputeEigenvectors() [with _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:447:28:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> > >, Eigen::internal::div_assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> > >, Eigen::internal::div_assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Functor = Eigen::internal::div_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Functor = Eigen::internal::div_assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Func = Eigen::internal::div_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Func = Eigen::internal::div_assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/SelfCwiseBinaryOp.h:45:28:   required from 'Derived& Eigen::DenseBase<Derived>::operator/=(const Scalar&) [with Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>; Eigen::DenseBase<Derived>::Scalar = double]'
..\Eigen/src/Eigenvalues/EigenSolver.h:598:45:   required from 'void Eigen::EigenSolver<_MatrixType>::doComputeEigenvectors() [with _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:447:28:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> > >, Eigen::internal::mul_assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> > >, Eigen::internal::mul_assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> >; Functor = Eigen::internal::mul_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> >; Functor = Eigen::internal::mul_assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> >; Func = Eigen::internal::mul_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> >; Func = Eigen::internal::mul_assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/SelfCwiseBinaryOp.h:21:28:   required from 'Derived& Eigen::DenseBase<Derived>::operator*=(const Scalar&) [with Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>; Eigen::DenseBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/SVD/JacobiSVD.h:387:28:   required from 'static bool Eigen::internal::svd_precondition_2x2_block_to_be_real<MatrixType, QRPreconditioner, true>::run(typename Eigen::internal::svd_precondition_2x2_block_to_be_real<MatrixType, QRPreconditioner, true>::SVD::WorkMatrixType&, Eigen::internal::svd_precondition_2x2_block_to_be_real<MatrixType, QRPreconditioner, true>::SVD&, Eigen::Index, Eigen::Index, Eigen::internal::svd_precondition_2x2_block_to_be_real<MatrixType, QRPreconditioner, true>::RealScalar&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; typename Eigen::internal::svd_precondition_2x2_block_to_be_real<MatrixType, QRPreconditioner, true>::SVD::WorkMatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; Eigen::internal::svd_precondition_2x2_block_to_be_real<MatrixType, QRPreconditioner, true>::SVD = Eigen::JacobiSVD<Eigen::Matrix<std::complex<float>, -1, -1>, 2>; Eigen::Index = long long int; Eigen::internal::svd_precondition_2x2_block_to_be_real<MatrixType, QRPreconditioner, true>::RealScalar = float]'
..\Eigen/src/SVD/JacobiSVD.h:719:96:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true> >, Eigen::internal::evaluator<Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<std::complex<float> >, const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true> >, Eigen::internal::evaluator<Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<std::complex<float> >, const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>; SrcXprType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<std::complex<float> >, const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>; SrcXprType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<std::complex<float> >, const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>; Src = Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<std::complex<float> >, const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>; Src = Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<std::complex<float> >, const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>; Src = Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<std::complex<float> >, const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true> >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<std::complex<float> >, const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true> >; Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>]'
..\Eigen/src/SVD/JacobiSVD.h:757:60:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Derived = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/CwiseNullaryOp.h:327:20:   required from 'Derived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Eigen::DenseBase<Derived>::Scalar = double]'
..\Eigen/src/Core/CwiseNullaryOp.h:501:21:   required from 'Derived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >]'
..\binary_library.cpp:1075:24:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/Assign.h:57:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::MatrixBase<Derived>&) [with Derived = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/MapBase.h:286:39:   required from 'Derived& Eigen::MapBase<Derived, 1>::operator=(const Eigen::MapBase<Derived, 1>&) [with Derived = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/Map.h:155:5:   required from 'Eigen::Map<MatrixType, MapOptions, StrideType>& Eigen::Map<MatrixType, MapOptions, StrideType>::operator=(const Eigen::Map<MatrixType, MapOptions, StrideType>&) [with PlainObjectType = Eigen::Matrix<double, -1, -1>; int MapOptions = 0; StrideType = Eigen::Stride<0, 0>]'
..\binary_library.cpp:1079:34:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, float>, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, const Eigen::Matrix<float, -1, -1> > > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, float>, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, const Eigen::Matrix<float, -1, -1> > > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, float>, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, const Eigen::Matrix<float, -1, -1> > >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, float>, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, const Eigen::Matrix<float, -1, -1> > >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, float>, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, const Eigen::Matrix<float, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, float>, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, const Eigen::Matrix<float, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, float>, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, const Eigen::Matrix<float, -1, -1> > >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, float>, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, const Eigen::Matrix<float, -1, -1> > >; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, float>, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, const Eigen::Matrix<float, -1, -1> > >; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/SVD/JacobiSVD.h:689:18:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::internal::swap_assign_op<std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::internal::swap_assign_op<std::complex<float> >, 1>'
..\Eigen/src/Core/Swap.h:19:7:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::internal::swap_assign_op<std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>; SrcXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>; Functor = Eigen::internal::swap_assign_op<std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>; SrcXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>; Functor = Eigen::internal::swap_assign_op<std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>; Src = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>; Func = Eigen::internal::swap_assign_op<std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>; Src = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>; Func = Eigen::internal::swap_assign_op<std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/DenseBase.h:418:22:   required from 'void Eigen::DenseBase<Derived>::swap(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>; Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>]'
..\Eigen/src/QR/CompleteOrthogonalDecomposition.h:440:9:   required from 'void Eigen::CompleteOrthogonalDecomposition<MatrixType>::computeInPlace() [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/QR/CompleteOrthogonalDecomposition.h:187:19:   required from 'Eigen::CompleteOrthogonalDecomposition<MatrixType>& Eigen::CompleteOrthogonalDecomposition<MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/QR/CompleteOrthogonalDecomposition.h:118:12:   required from 'Eigen::CompleteOrthogonalDecomposition<MatrixType>::CompleteOrthogonalDecomposition(const Eigen::EigenBase<OtherDerived>&) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/QR/CompleteOrthogonalDecomposition.h:557:10:   required from 'const Eigen::CompleteOrthogonalDecomposition<typename Eigen::DenseBase<Derived>::PlainObject> Eigen::MatrixBase<Derived>::completeOrthogonalDecomposition() const [with Derived = Eigen::Matrix<std::complex<float>, -1, -1>; typename Eigen::DenseBase<Derived>::PlainObject = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:943:87:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, 1> >, Eigen::internal::evaluator<Eigen::Diagonal<const Eigen::Matrix<std::complex<float>, -1, -1>, 0> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, 1> >, Eigen::internal::evaluator<Eigen::Diagonal<const Eigen::Matrix<std::complex<float>, -1, -1>, 0> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, 1>; SrcXprType = Eigen::Diagonal<const Eigen::Matrix<std::complex<float>, -1, -1>, 0>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, 1>; SrcXprType = Eigen::Diagonal<const Eigen::Matrix<std::complex<float>, -1, -1>, 0>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, 1>; Src = Eigen::Diagonal<const Eigen::Matrix<std::complex<float>, -1, -1>, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, 1>; Src = Eigen::Diagonal<const Eigen::Matrix<std::complex<float>, -1, -1>, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, -1, 1>; Src = Eigen::Diagonal<const Eigen::Matrix<std::complex<float>, -1, -1>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Diagonal<const Eigen::Matrix<std::complex<float>, -1, -1>, 0>; Derived = Eigen::Matrix<std::complex<float>, -1, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Diagonal<const Eigen::Matrix<std::complex<float>, -1, -1>, 0>; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Eigenvalues/ComplexEigenSolver.h:274:16:   required from 'Eigen::ComplexEigenSolver<MatrixType>& Eigen::ComplexEigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Eigenvalues/ComplexEigenSolver.h:134:14:   required from 'Eigen::ComplexEigenSolver<_MatrixType>::ComplexEigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:954:54:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> > >, Eigen::internal::div_assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> > >, Eigen::internal::div_assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Functor = Eigen::internal::div_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Functor = Eigen::internal::div_assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Func = Eigen::internal::div_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Func = Eigen::internal::div_assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/SelfCwiseBinaryOp.h:45:28:   required from 'Derived& Eigen::DenseBase<Derived>::operator/=(const Scalar&) [with Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>; Eigen::DenseBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/Dot.h:147:15:   required from 'void Eigen::MatrixBase<Derived>::normalize() [with Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>]'
..\Eigen/src/Eigenvalues/ComplexEigenSolver.h:321:5:   required from 'void Eigen::ComplexEigenSolver<_MatrixType>::doComputeEigenvectors(Eigen::ComplexEigenSolver<_MatrixType>::RealScalar) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; Eigen::ComplexEigenSolver<_MatrixType>::RealScalar = float]'
..\Eigen/src/Eigenvalues/ComplexEigenSolver.h:276:28:   required from 'Eigen::ComplexEigenSolver<MatrixType>& Eigen::ComplexEigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Eigenvalues/ComplexEigenSolver.h:134:14:   required from 'Eigen::ComplexEigenSolver<_MatrixType>::ComplexEigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:954:54:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, 2, 1> >, Eigen::internal::evaluator<Eigen::Matrix<double, 2, 1> >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, 2, 1> >, Eigen::internal::evaluator<Eigen::Matrix<double, 2, 1> >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, 2, 1>; SrcXprType = Eigen::Matrix<double, 2, 1>; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, 2, 1>; SrcXprType = Eigen::Matrix<double, 2, 1>; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, 2, 1>; Src = Eigen::Matrix<double, 2, 1>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 2, 1>; Derived = Eigen::Matrix<double, 2, 1>]'
..\Eigen/src/Core/Matrix.h:278:27:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&&) [with _Scalar = double; int _Rows = 2; int _Cols = 1; int _Options = 0; int _MaxRows = 2; int _MaxCols = 1]'
..\Eigen/src/Eigenvalues/RealSchur.h:521:24:   required from 'void Eigen::RealSchur<_MatrixType>::performFrancisQRStep(Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, bool, const Vector3s&, Eigen::RealSchur<_MatrixType>::Scalar*) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::RealSchur<_MatrixType>::Index = long long int; Eigen::RealSchur<_MatrixType>::Vector3s = Eigen::Matrix<double, 3, 1>; typename MatrixType::Scalar = double; Eigen::RealSchur<_MatrixType>::Scalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:337:29:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::computeFromHessenberg(const HessMatrixType&, const OrthMatrixType&, bool) [with HessMatrixType = Eigen::internal::HessenbergDecompositionMatrixHReturnType<Eigen::Matrix<double, -1, -1> >; OrthMatrixType = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:274:24:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::TriangularView<Eigen::Matrix<std::complex<float>, -1, -1>, 10> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::TriangularView<Eigen::Matrix<std::complex<float>, -1, -1>, 10> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/TriangularMatrix.h:736:7:   required from 'class Eigen::internal::triangular_dense_assignment_kernel<2, 8, 0, Eigen::internal::evaluator<Eigen::TriangularView<Eigen::Matrix<std::complex<float>, -1, -1>, 10> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/TriangularMatrix.h:799:10:   required from 'void Eigen::internal::call_triangular_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with int Mode = 10; bool SetOpposite = false; DstXprType = Eigen::TriangularView<Eigen::Matrix<std::complex<float>, -1, -1>, 10>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/TriangularMatrix.h:847:61:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Triangular>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::TriangularView<Eigen::Matrix<std::complex<float>, -1, -1>, 10>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::TriangularView<Eigen::Matrix<std::complex<float>, -1, -1>, 10>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/TriangularMatrix.h:560:37:   required from 'Eigen::TriangularView<MatrixType, _Mode>& Eigen::TriangularViewImpl<_MatrixType, _Mode, Eigen::Dense>::operator=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; unsigned int _Mode = 10]'
..\Eigen/src/Core/TriangularMatrix.h:394:20:   required from 'Eigen::TriangularViewImpl<_MatrixType, _Mode, Eigen::Dense>::TriangularViewType& Eigen::TriangularViewImpl<_MatrixType, _Mode, Eigen::Dense>::setConstant(const Scalar&) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; unsigned int _Mode = 10; Eigen::TriangularViewImpl<_MatrixType, _Mode, Eigen::Dense>::TriangularViewType = Eigen::TriangularView<Eigen::Matrix<std::complex<float>, -1, -1>, 10>; Eigen::TriangularViewImpl<_MatrixType, _Mode, Eigen::Dense>::Scalar = std::complex<float>]'
..\Eigen/src/Core/TriangularMatrix.h:397:55:   required from 'Eigen::TriangularViewImpl<_MatrixType, _Mode, Eigen::Dense>::TriangularViewType& Eigen::TriangularViewImpl<_MatrixType, _Mode, Eigen::Dense>::setZero() [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; unsigned int _Mode = 10; Eigen::TriangularViewImpl<_MatrixType, _Mode, Eigen::Dense>::TriangularViewType = Eigen::TriangularView<Eigen::Matrix<std::complex<float>, -1, -1>, 10>]'
..\Eigen/src/Householder/HouseholderSequence.h:250:9:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::evalTo(Dest&, Workspace&) const [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Workspace = Eigen::Matrix<std::complex<float>, 1, -1>; VectorsType = Eigen::Matrix<std::complex<float>, -1, -1>; CoeffsType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; int Side = 1]'
..\Eigen/src/SVD/JacobiSVD.h:233:30:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::internal::mul_assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::internal::mul_assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Functor = Eigen::internal::mul_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Functor = Eigen::internal::mul_assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Func = Eigen::internal::mul_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Func = Eigen::internal::mul_assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/SelfCwiseBinaryOp.h:21:28:   required from 'Derived& Eigen::DenseBase<Derived>::operator*=(const Scalar&) [with Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Eigen::DenseBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Householder/Householder.h:157:11:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheRight(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false>; Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Householder/HouseholderSequence.h:255:13:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::evalTo(Dest&, Workspace&) const [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Workspace = Eigen::Matrix<std::complex<float>, 1, -1>; VectorsType = Eigen::Matrix<std::complex<float>, -1, -1>; CoeffsType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; int Side = 1]'
..\Eigen/src/SVD/JacobiSVD.h:233:30:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true> >, Eigen::internal::add_assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true> >, Eigen::internal::add_assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>; Functor = Eigen::internal::add_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>; Functor = Eigen::internal::add_assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>; Func = Eigen::internal::add_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>; Func = Eigen::internal::add_assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/CwiseBinaryOp.h:177:18:   required from 'Derived& Eigen::MatrixBase<Derived>::operator+=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>; Derived = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Householder/Householder.h:164:9:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheRight(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false>; Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Householder/HouseholderSequence.h:255:13:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::evalTo(Dest&, Workspace&) const [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Workspace = Eigen::Matrix<std::complex<float>, 1, -1>; VectorsType = Eigen::Matrix<std::complex<float>, -1, -1>; CoeffsType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; int Side = 1]'
..\Eigen/src/SVD/JacobiSVD.h:233:30:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > > >, Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > > >, Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >; Functor = Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >; Functor = Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >; Func = Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >; Func = Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/CwiseBinaryOp.h:164:18:   required from 'Derived& Eigen::MatrixBase<Derived>::operator-=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >; Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>]'
..\Eigen/src/Householder/Householder.h:165:18:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheRight(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false>; Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Householder/HouseholderSequence.h:255:13:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::evalTo(Dest&, Workspace&) const [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Workspace = Eigen::Matrix<std::complex<float>, 1, -1>; VectorsType = Eigen::Matrix<std::complex<float>, -1, -1>; CoeffsType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; int Side = 1]'
..\Eigen/src/SVD/JacobiSVD.h:233:30:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 1, -1, false> >, Eigen::internal::add_assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 1, -1, false> >, Eigen::internal::add_assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 1, -1, false>; Functor = Eigen::internal::add_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 1, -1, false>; Functor = Eigen::internal::add_assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 1, -1, false>; Func = Eigen::internal::add_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 1, -1, false>; Func = Eigen::internal::add_assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/CwiseBinaryOp.h:177:18:   required from 'Derived& Eigen::MatrixBase<Derived>::operator+=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 1, -1, false>; Derived = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Householder/Householder.h:127:9:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheLeft(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false>; Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Householder/HouseholderSequence.h:258:13:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::evalTo(Dest&, Workspace&) const [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Workspace = Eigen::Matrix<std::complex<float>, 1, -1>; VectorsType = Eigen::Matrix<std::complex<float>, -1, -1>; CoeffsType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; int Side = 1]'
..\Eigen/src/SVD/JacobiSVD.h:233:30:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 1, -1, false> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> > > >, Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 1, -1, false> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> > > >, Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 1, -1, false>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> > >; Functor = Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 1, -1, false>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> > >; Functor = Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 1, -1, false>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> > >; Func = Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 1, -1, false>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> > >; Func = Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/CwiseBinaryOp.h:164:18:   required from 'Derived& Eigen::MatrixBase<Derived>::operator-=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> > >; Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 1, -1, false>]'
..\Eigen/src/Householder/Householder.h:128:18:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheLeft(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false>; Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Householder/HouseholderSequence.h:258:13:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::evalTo(Dest&, Workspace&) const [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Workspace = Eigen::Matrix<std::complex<float>, 1, -1>; VectorsType = Eigen::Matrix<std::complex<float>, -1, -1>; CoeffsType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; int Side = 1]'
..\Eigen/src/SVD/JacobiSVD.h:233:30:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:154:16:   required from 'Eigen::HessenbergDecomposition<_MatrixType>& Eigen::HessenbergDecomposition<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&) [with InputType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:271:3:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> > >, Eigen::internal::mul_assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> > >, Eigen::internal::mul_assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Functor = Eigen::internal::mul_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Functor = Eigen::internal::mul_assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Func = Eigen::internal::mul_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Func = Eigen::internal::mul_assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/SelfCwiseBinaryOp.h:21:28:   required from 'Derived& Eigen::DenseBase<Derived>::operator*=(const Scalar&) [with Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>; Eigen::DenseBase<Derived>::Scalar = double]'
..\Eigen/src/Householder/Householder.h:120:11:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheLeft(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::VectorBlock<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1>; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = double]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:313:5:   required from 'static void Eigen::HessenbergDecomposition<_MatrixType>::_compute(Eigen::HessenbergDecomposition<_MatrixType>::MatrixType&, Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType&, Eigen::HessenbergDecomposition<_MatrixType>::VectorType&) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType = Eigen::Matrix<double, -1, 1>; typename _MatrixType::Scalar = double; Eigen::HessenbergDecomposition<_MatrixType>::VectorType = Eigen::Matrix<double, 1, -1>]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:161:15:   required from 'Eigen::HessenbergDecomposition<_MatrixType>& Eigen::HessenbergDecomposition<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&) [with InputType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:271:3:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false> >, Eigen::internal::add_assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false> >, Eigen::internal::add_assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false>; Functor = Eigen::internal::add_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false>; Functor = Eigen::internal::add_assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false>; Func = Eigen::internal::add_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false>; Func = Eigen::internal::add_assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/CwiseBinaryOp.h:177:18:   required from 'Derived& Eigen::MatrixBase<Derived>::operator+=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false>; Derived = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Householder/Householder.h:127:9:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheLeft(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::VectorBlock<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1>; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = double]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:313:5:   required from 'static void Eigen::HessenbergDecomposition<_MatrixType>::_compute(Eigen::HessenbergDecomposition<_MatrixType>::MatrixType&, Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType&, Eigen::HessenbergDecomposition<_MatrixType>::VectorType&) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType = Eigen::Matrix<double, -1, 1>; typename _MatrixType::Scalar = double; Eigen::HessenbergDecomposition<_MatrixType>::VectorType = Eigen::Matrix<double, 1, -1>]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:161:15:   required from 'Eigen::HessenbergDecomposition<_MatrixType>& Eigen::HessenbergDecomposition<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&) [with InputType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:271:3:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, -1> >, const Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> > > >, Eigen::internal::sub_assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, -1> >, const Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> > > >, Eigen::internal::sub_assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, -1> >, const Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> > >; Functor = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, -1> >, const Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> > >; Functor = Eigen::internal::sub_assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, -1> >, const Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> > >; Func = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, -1> >, const Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> > >; Func = Eigen::internal::sub_assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/CwiseBinaryOp.h:164:18:   required from 'Derived& Eigen::MatrixBase<Derived>::operator-=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, -1> >, const Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> > >; Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false>]'
..\Eigen/src/Householder/Householder.h:128:18:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheLeft(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::VectorBlock<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1>; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = double]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:313:5:   required from 'static void Eigen::HessenbergDecomposition<_MatrixType>::_compute(Eigen::HessenbergDecomposition<_MatrixType>::MatrixType&, Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType&, Eigen::HessenbergDecomposition<_MatrixType>::VectorType&) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType = Eigen::Matrix<double, -1, 1>; typename _MatrixType::Scalar = double; Eigen::HessenbergDecomposition<_MatrixType>::VectorType = Eigen::Matrix<double, 1, -1>]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:161:15:   required from 'Eigen::HessenbergDecomposition<_MatrixType>& Eigen::HessenbergDecomposition<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&) [with InputType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:271:3:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> > >, Eigen::internal::mul_assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> > >, Eigen::internal::mul_assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Functor = Eigen::internal::mul_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Functor = Eigen::internal::mul_assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Func = Eigen::internal::mul_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Func = Eigen::internal::mul_assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/SelfCwiseBinaryOp.h:21:28:   required from 'Derived& Eigen::DenseBase<Derived>::operator*=(const Scalar&) [with Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Eigen::DenseBase<Derived>::Scalar = double]'
..\Eigen/src/Householder/Householder.h:157:11:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheRight(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Eigen::MatrixBase<Derived>::Scalar = double]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:317:5:   required from 'static void Eigen::HessenbergDecomposition<_MatrixType>::_compute(Eigen::HessenbergDecomposition<_MatrixType>::MatrixType&, Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType&, Eigen::HessenbergDecomposition<_MatrixType>::VectorType&) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType = Eigen::Matrix<double, -1, 1>; typename _MatrixType::Scalar = double; Eigen::HessenbergDecomposition<_MatrixType>::VectorType = Eigen::Matrix<double, 1, -1>]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:161:15:   required from 'Eigen::HessenbergDecomposition<_MatrixType>& Eigen::HessenbergDecomposition<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&) [with InputType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:271:3:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, 1, true> >, Eigen::internal::add_assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, 1, true> >, Eigen::internal::add_assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, 1, true>; Functor = Eigen::internal::add_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, 1, true>; Functor = Eigen::internal::add_assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, 1, true>; Func = Eigen::internal::add_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, 1, true>; Func = Eigen::internal::add_assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/CwiseBinaryOp.h:177:18:   required from 'Derived& Eigen::MatrixBase<Derived>::operator+=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, 1, true>; Derived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Householder/Householder.h:164:9:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheRight(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Eigen::MatrixBase<Derived>::Scalar = double]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:317:5:   required from 'static void Eigen::HessenbergDecomposition<_MatrixType>::_compute(Eigen::HessenbergDecomposition<_MatrixType>::MatrixType&, Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType&, Eigen::HessenbergDecomposition<_MatrixType>::VectorType&) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType = Eigen::Matrix<double, -1, 1>; typename _MatrixType::Scalar = double; Eigen::HessenbergDecomposition<_MatrixType>::VectorType = Eigen::Matrix<double, 1, -1>]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:161:15:   required from 'Eigen::HessenbergDecomposition<_MatrixType>& Eigen::HessenbergDecomposition<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&) [with InputType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:271:3:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, 1, true> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > > >, Eigen::internal::sub_assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, 1, true> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > > >, Eigen::internal::sub_assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, 1, true>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >; Functor = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, 1, true>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >; Functor = Eigen::internal::sub_assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, 1, true>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >; Func = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, 1, true>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >; Func = Eigen::internal::sub_assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/CwiseBinaryOp.h:164:18:   required from 'Derived& Eigen::MatrixBase<Derived>::operator-=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >; Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, 1, true>]'
..\Eigen/src/Householder/Householder.h:165:18:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheRight(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Eigen::MatrixBase<Derived>::Scalar = double]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:317:5:   required from 'static void Eigen::HessenbergDecomposition<_MatrixType>::_compute(Eigen::HessenbergDecomposition<_MatrixType>::MatrixType&, Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType&, Eigen::HessenbergDecomposition<_MatrixType>::VectorType&) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType = Eigen::Matrix<double, -1, 1>; typename _MatrixType::Scalar = double; Eigen::HessenbergDecomposition<_MatrixType>::VectorType = Eigen::Matrix<double, 1, -1>]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:161:15:   required from 'Eigen::HessenbergDecomposition<_MatrixType>& Eigen::HessenbergDecomposition<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&) [with InputType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:271:3:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 1, true> >, Eigen::internal::add_assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 1, true> >, Eigen::internal::add_assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 1, true>; Functor = Eigen::internal::add_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 1, true>; Functor = Eigen::internal::add_assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 1, true>; Func = Eigen::internal::add_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 1, true>; Func = Eigen::internal::add_assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/CwiseBinaryOp.h:177:18:   required from 'Derived& Eigen::MatrixBase<Derived>::operator+=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 1, true>; Derived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Householder/Householder.h:164:9:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheRight(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Matrix<double, 2, 1>; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:515:7:   required from 'void Eigen::RealSchur<_MatrixType>::performFrancisQRStep(Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, bool, const Vector3s&, Eigen::RealSchur<_MatrixType>::Scalar*) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::RealSchur<_MatrixType>::Index = long long int; Eigen::RealSchur<_MatrixType>::Vector3s = Eigen::Matrix<double, 3, 1>; typename MatrixType::Scalar = double; Eigen::RealSchur<_MatrixType>::Scalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:337:29:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::computeFromHessenberg(const HessMatrixType&, const OrthMatrixType&, bool) [with HessMatrixType = Eigen::internal::HessenbergDecompositionMatrixHReturnType<Eigen::Matrix<double, -1, -1> >; OrthMatrixType = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:274:24:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 1, true> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > > >, Eigen::internal::sub_assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 1, true> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > > >, Eigen::internal::sub_assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 1, true>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >; Functor = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 1, true>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >; Functor = Eigen::internal::sub_assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 1, true>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >; Func = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 1, true>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >; Func = Eigen::internal::sub_assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/CwiseBinaryOp.h:164:18:   required from 'Derived& Eigen::MatrixBase<Derived>::operator-=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >; Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 1, true>]'
..\Eigen/src/Householder/Householder.h:165:18:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheRight(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Matrix<double, 2, 1>; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:515:7:   required from 'void Eigen::RealSchur<_MatrixType>::performFrancisQRStep(Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, bool, const Vector3s&, Eigen::RealSchur<_MatrixType>::Scalar*) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::RealSchur<_MatrixType>::Index = long long int; Eigen::RealSchur<_MatrixType>::Vector3s = Eigen::Matrix<double, 3, 1>; typename MatrixType::Scalar = double; Eigen::RealSchur<_MatrixType>::Scalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:337:29:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::computeFromHessenberg(const HessMatrixType&, const OrthMatrixType&, bool) [with HessMatrixType = Eigen::internal::HessenbergDecompositionMatrixHReturnType<Eigen::Matrix<double, -1, -1> >; OrthMatrixType = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:274:24:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, 2, 1> >, Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<double, -1, -1>, 2, 1, false> >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, 2, 1> >, Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<double, -1, -1>, 2, 1, false> >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, 2, 1>; SrcXprType = Eigen::Block<Eigen::Matrix<double, -1, -1>, 2, 1, false>; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, 2, 1>; SrcXprType = Eigen::Block<Eigen::Matrix<double, -1, -1>, 2, 1, false>; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, 2, 1>; Src = Eigen::Block<Eigen::Matrix<double, -1, -1>, 2, 1, false>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 2, 1, false>; Derived = Eigen::Matrix<double, 2, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:537:19:   required from 'Eigen::PlainObjectBase<Derived>::PlainObjectBase(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 2, 1, false>; Derived = Eigen::Matrix<double, 2, 1>]'
..\Eigen/src/Core/Matrix.h:379:29:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 2, 1, false>; _Scalar = double; int _Rows = 2; int _Cols = 1; int _Options = 0; int _MaxRows = 2; int _MaxCols = 1]'
..\Eigen/src/Eigenvalues/RealSchur.h:521:24:   required from 'void Eigen::RealSchur<_MatrixType>::performFrancisQRStep(Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, bool, const Vector3s&, Eigen::RealSchur<_MatrixType>::Scalar*) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::RealSchur<_MatrixType>::Index = long long int; Eigen::RealSchur<_MatrixType>::Vector3s = Eigen::Matrix<double, 3, 1>; typename MatrixType::Scalar = double; Eigen::RealSchur<_MatrixType>::Scalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:337:29:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::computeFromHessenberg(const HessMatrixType&, const OrthMatrixType&, bool) [with HessMatrixType = Eigen::internal::HessenbergDecompositionMatrixHReturnType<Eigen::Matrix<double, -1, -1> >; OrthMatrixType = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:274:24:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
In file included from ..\Eigen/Core:473:0,
                 from ..\binary_library.cpp:18:
..\Eigen/src/Core/products/GeneralMatrixVector.h: In instantiation of 'static void Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 0, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::run(Index, Index, const LhsMapper&, const RhsMapper&, Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 0, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::ResScalar*, Index, RhsScalar) [with Index = long long int; LhsScalar = double; LhsMapper = Eigen::internal::const_blas_data_mapper<double, long long int, 0>; bool ConjugateLhs = false; RhsScalar = double; RhsMapper = Eigen::internal::const_blas_data_mapper<double, long long int, 1>; bool ConjugateRhs = false; int Version = 0; Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 0, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::ResScalar = double]':
..\Eigen/src/Core/GeneralProduct.h:239:134:   required from 'static void Eigen::internal::gemv_dense_selector<2, 0, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Dest = Eigen::Matrix<double, -1, 1>; typename Dest::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<double, -1, 1>; Lhs = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Matrix<double, -1, 1>; Lhs = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, 1>; Lhs = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<double, -1, 1>; Lhs = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, 1>; Src = Eigen::Product<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/NoAlias.h:42:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, 0>; ExpressionType = Eigen::Matrix<double, -1, 1>; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Eigenvalues/EigenSolver.h:615:21:   required from 'void Eigen::EigenSolver<_MatrixType>::doComputeEigenvectors() [with _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:447:28:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/products/GeneralMatrixVector.h:186:39: warning: enum constant in boolean context [-Wint-in-bool-context]
   const Index offset1 = (FirstAligned && alignmentStep==1)?3:1;
                         ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/products/GeneralMatrixVector.h:187:39: warning: enum constant in boolean context [-Wint-in-bool-context]
   const Index offset3 = (FirstAligned && alignmentStep==1)?1:3;
                         ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from ..\Eigen/Core:420:0,
                 from ..\binary_library.cpp:18:
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::TriangularView<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> > >, 1> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::TriangularView<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> > >, 1> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/TriangularMatrix.h:736:7:   required from 'class Eigen::internal::triangular_dense_assignment_kernel<1, 0, 1, Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::TriangularView<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> > >, 1> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/TriangularMatrix.h:799:10:   required from 'void Eigen::internal::call_triangular_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with int Mode = 1; bool SetOpposite = true; DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::TriangularView<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> > >, 1>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/TriangularMatrix.h:838:89:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Triangular2Dense>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::TriangularView<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> > >, 1>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::TriangularView<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> > >, 1>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::TriangularView<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> > >, 1>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::TriangularView<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> > >, 1>]'
..\Eigen/src/Core/Assign.h:75:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::TriangularView<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> > >, 1>; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:571:22:   required from 'Derived& Eigen::PlainObjectBase<Derived>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::TriangularView<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> > >, 1>; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:238:29:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::TriangularView<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> > >, 1>; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/SVD/JacobiSVD.h:232:24:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::TriangularView<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 2> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::TriangularView<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 2> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/TriangularMatrix.h:736:7:   required from 'class Eigen::internal::triangular_dense_assignment_kernel<2, 0, 1, Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::TriangularView<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 2> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/TriangularMatrix.h:799:10:   required from 'void Eigen::internal::call_triangular_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with int Mode = 2; bool SetOpposite = true; DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::TriangularView<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 2>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/TriangularMatrix.h:838:89:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Triangular2Dense>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::TriangularView<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 2>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::TriangularView<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 2>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::TriangularView<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 2>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::TriangularView<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 2>]'
..\Eigen/src/Core/Assign.h:75:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::TriangularView<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 2>; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:571:22:   required from 'Derived& Eigen::PlainObjectBase<Derived>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::TriangularView<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 2>; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:238:29:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::TriangularView<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 2>; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/SVD/JacobiSVD.h:175:24:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 1, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:685:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, 2, 2> >, Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, 2, 2> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, 2, 2> >, Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, 2, 2> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, 2, 2>; SrcXprType = Eigen::Matrix<std::complex<float>, 2, 2>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, 2, 2>; SrcXprType = Eigen::Matrix<std::complex<float>, 2, 2>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, 2, 2>; Src = Eigen::Matrix<std::complex<float>, 2, 2>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<std::complex<float>, 2, 2>; Derived = Eigen::Matrix<std::complex<float>, 2, 2>]'
..\Eigen/src/Core/Matrix.h:278:27:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&&) [with _Scalar = std::complex<float>; int _Rows = 2; int _Cols = 2; int _Options = 0; int _MaxRows = 2; int _MaxCols = 2]'
..\Eigen/src/Eigenvalues/ComplexSchur.h:292:29:   required from 'Eigen::ComplexSchur<_MatrixType>::ComplexScalar Eigen::ComplexSchur<_MatrixType>::computeShift(Eigen::ComplexSchur<_MatrixType>::Index, Eigen::ComplexSchur<_MatrixType>::Index) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; Eigen::ComplexSchur<_MatrixType>::ComplexScalar = std::complex<float>; typename Eigen::NumTraits<typename Derived::Scalar>::Real = float; Eigen::ComplexSchur<_MatrixType>::Index = long long int]'
..\Eigen/src/Eigenvalues/ComplexSchur.h:431:39:   required from 'void Eigen::ComplexSchur<_MatrixType>::reduceToTriangularForm(bool) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Eigenvalues/ComplexSchur.h:346:25:   required from 'Eigen::ComplexSchur<MatrixType>& Eigen::ComplexSchur<_MatrixType>::computeFromHessenberg(const HessMatrixType&, const OrthMatrixType&, bool) [with HessMatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; OrthMatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Eigenvalues/ComplexSchur.h:335:24:   required from 'Eigen::ComplexSchur<MatrixType>& Eigen::ComplexSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Eigenvalues/ComplexEigenSolver.h:270:3:   required from 'Eigen::ComplexEigenSolver<MatrixType>& Eigen::ComplexEigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Eigenvalues/ComplexEigenSolver.h:134:14:   required from 'Eigen::ComplexEigenSolver<_MatrixType>::ComplexEigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:954:54:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, 2, 2> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 2, 2> > >, Eigen::internal::div_assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, 2, 2> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 2, 2> > >, Eigen::internal::div_assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, 2, 2>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 2, 2> >; Functor = Eigen::internal::div_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, 2, 2>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 2, 2> >; Functor = Eigen::internal::div_assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, 2, 2>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 2, 2> >; Func = Eigen::internal::div_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, 2, 2>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 2, 2> >; Func = Eigen::internal::div_assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/SelfCwiseBinaryOp.h:45:28:   required from 'Derived& Eigen::DenseBase<Derived>::operator/=(const Scalar&) [with Derived = Eigen::Matrix<std::complex<float>, 2, 2>; Eigen::DenseBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Eigenvalues/ComplexSchur.h:294:5:   required from 'Eigen::ComplexSchur<_MatrixType>::ComplexScalar Eigen::ComplexSchur<_MatrixType>::computeShift(Eigen::ComplexSchur<_MatrixType>::Index, Eigen::ComplexSchur<_MatrixType>::Index) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; Eigen::ComplexSchur<_MatrixType>::ComplexScalar = std::complex<float>; typename Eigen::NumTraits<typename Derived::Scalar>::Real = float; Eigen::ComplexSchur<_MatrixType>::Index = long long int]'
..\Eigen/src/Eigenvalues/ComplexSchur.h:431:39:   required from 'void Eigen::ComplexSchur<_MatrixType>::reduceToTriangularForm(bool) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Eigenvalues/ComplexSchur.h:346:25:   required from 'Eigen::ComplexSchur<MatrixType>& Eigen::ComplexSchur<_MatrixType>::computeFromHessenberg(const HessMatrixType&, const OrthMatrixType&, bool) [with HessMatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; OrthMatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Eigenvalues/ComplexSchur.h:335:24:   required from 'Eigen::ComplexSchur<MatrixType>& Eigen::ComplexSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Eigenvalues/ComplexEigenSolver.h:270:3:   required from 'Eigen::ComplexEigenSolver<MatrixType>& Eigen::ComplexEigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Eigenvalues/ComplexEigenSolver.h:134:14:   required from 'Eigen::ComplexEigenSolver<_MatrixType>::ComplexEigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:954:54:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::Matrix<std::complex<float>, -1, -1>, 1> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::Matrix<std::complex<float>, -1, -1>, 1> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::Matrix<std::complex<float>, -1, -1>, 1>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::Matrix<std::complex<float>, -1, -1>, 1>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::Matrix<std::complex<float>, -1, -1>, 1>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/ProductEvaluators.h:397:29:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 3>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Lhs = Eigen::Matrix<std::complex<float>, -1, -1>; Rhs = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:431:26:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Lhs = Eigen::Matrix<std::complex<float>, -1, -1>; Rhs = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; Lhs = Eigen::Matrix<std::complex<float>, -1, -1>; Rhs = Eigen::Matrix<std::complex<float>, -1, -1>; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::Matrix<std::complex<float>, -1, -1>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::Matrix<std::complex<float>, -1, -1>, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/NoAlias.h:42:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::Matrix<std::complex<float>, -1, -1>, 0>; ExpressionType = Eigen::Matrix<std::complex<float>, -1, -1>; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Eigenvalues/ComplexEigenSolver.h:317:21:   required from 'void Eigen::ComplexEigenSolver<_MatrixType>::doComputeEigenvectors(Eigen::ComplexEigenSolver<_MatrixType>::RealScalar) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; Eigen::ComplexEigenSolver<_MatrixType>::RealScalar = float]'
..\Eigen/src/Eigenvalues/ComplexEigenSolver.h:276:28:   required from 'Eigen::ComplexEigenSolver<MatrixType>& Eigen::ComplexEigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Eigenvalues/ComplexEigenSolver.h:134:14:   required from 'Eigen::ComplexEigenSolver<_MatrixType>::ComplexEigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:954:54:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, 3, 1> >, Eigen::internal::evaluator<Eigen::Matrix<double, 3, 1> >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, 3, 1> >, Eigen::internal::evaluator<Eigen::Matrix<double, 3, 1> >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, 3, 1>; SrcXprType = Eigen::Matrix<double, 3, 1>; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, 3, 1>; SrcXprType = Eigen::Matrix<double, 3, 1>; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, 3, 1>; Src = Eigen::Matrix<double, 3, 1>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<double, 3, 1>; Src = Eigen::Matrix<double, 3, 1>; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, 3, 1>; Src = Eigen::Matrix<double, 3, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 1>; Derived = Eigen::Matrix<double, 3, 1>]'
..\Eigen/src/Core/Matrix.h:208:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&) [with _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1]'
..\Eigen/src/Eigenvalues/RealSchur.h:498:9:   required from 'void Eigen::RealSchur<_MatrixType>::performFrancisQRStep(Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, bool, const Vector3s&, Eigen::RealSchur<_MatrixType>::Scalar*) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::RealSchur<_MatrixType>::Index = long long int; Eigen::RealSchur<_MatrixType>::Vector3s = Eigen::Matrix<double, 3, 1>; typename MatrixType::Scalar = double; Eigen::RealSchur<_MatrixType>::Scalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:337:29:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::computeFromHessenberg(const HessMatrixType&, const OrthMatrixType&, bool) [with HessMatrixType = Eigen::internal::HessenbergDecompositionMatrixHReturnType<Eigen::Matrix<double, -1, -1> >; OrthMatrixType = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:274:24:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, 3, 1> >, Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 1, false> >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, 3, 1> >, Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 1, false> >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, 3, 1>; SrcXprType = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 1, false>; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, 3, 1>; SrcXprType = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 1, false>; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, 3, 1>; Src = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 1, false>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<double, 3, 1>; Src = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 1, false>; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, 3, 1>; Src = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 1, false>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 1, false>; Derived = Eigen::Matrix<double, 3, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 1, false>; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1]'
..\Eigen/src/Eigenvalues/RealSchur.h:500:9:   required from 'void Eigen::RealSchur<_MatrixType>::performFrancisQRStep(Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, bool, const Vector3s&, Eigen::RealSchur<_MatrixType>::Scalar*) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::RealSchur<_MatrixType>::Index = long long int; Eigen::RealSchur<_MatrixType>::Vector3s = Eigen::Matrix<double, 3, 1>; typename MatrixType::Scalar = double; Eigen::RealSchur<_MatrixType>::Scalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:337:29:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::computeFromHessenberg(const HessMatrixType&, const OrthMatrixType&, bool) [with HessMatrixType = Eigen::internal::HessenbergDecompositionMatrixHReturnType<Eigen::Matrix<double, -1, -1> >; OrthMatrixType = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:274:24:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Diagonal<Eigen::Matrix<std::complex<float>, -1, -1>, 0> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Diagonal<Eigen::Matrix<std::complex<float>, -1, -1>, 0> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Diagonal<Eigen::Matrix<std::complex<float>, -1, -1>, 0>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Diagonal<Eigen::Matrix<std::complex<float>, -1, -1>, 0>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Diagonal<Eigen::Matrix<std::complex<float>, -1, -1>, 0>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Diagonal<Eigen::Matrix<std::complex<float>, -1, -1>, 0>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Diagonal<Eigen::Matrix<std::complex<float>, -1, -1>, 0>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Derived = Eigen::Diagonal<Eigen::Matrix<std::complex<float>, -1, -1>, 0>]'
..\Eigen/src/Core/CwiseNullaryOp.h:327:20:   required from 'Derived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Diagonal<Eigen::Matrix<std::complex<float>, -1, -1>, 0>; Eigen::DenseBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/CwiseNullaryOp.h:627:21:   required from 'Derived& Eigen::DenseBase<Derived>::setOnes() [with Derived = Eigen::Diagonal<Eigen::Matrix<std::complex<float>, -1, -1>, 0>]'
..\Eigen/src/Householder/HouseholderSequence.h:249:9:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::evalTo(Dest&, Workspace&) const [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Workspace = Eigen::Matrix<std::complex<float>, 1, -1>; VectorsType = Eigen::Matrix<std::complex<float>, -1, -1>; CoeffsType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; int Side = 1]'
..\Eigen/src/SVD/JacobiSVD.h:233:30:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>]'
..\Eigen/src/Core/CwiseNullaryOp.h:327:20:   required from 'Derived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>; Eigen::DenseBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/CwiseNullaryOp.h:501:21:   required from 'Derived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>]'
..\Eigen/src/Householder/HouseholderSequence.h:262:11:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::evalTo(Dest&, Workspace&) const [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Workspace = Eigen::Matrix<std::complex<float>, 1, -1>; VectorsType = Eigen::Matrix<std::complex<float>, -1, -1>; CoeffsType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; int Side = 1]'
..\Eigen/src/SVD/JacobiSVD.h:233:30:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false> >, Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, 1, -1> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false> >, Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, 1, -1> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; SrcXprType = Eigen::Matrix<std::complex<float>, 1, -1>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; SrcXprType = Eigen::Matrix<std::complex<float>, 1, -1>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Src = Eigen::Matrix<std::complex<float>, 1, -1>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:828:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Src = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Src = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>]'
..\Eigen/src/Householder/BlockHouseholder.h:67:33:   required from 'void Eigen::internal::make_block_householder_triangular_factor(TriangularFactorType&, const VectorsType&, const CoeffsType&) [with TriangularFactorType = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; VectorsType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; CoeffsType = Eigen::VectorBlock<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, -1>]'
..\Eigen/src/Householder/BlockHouseholder.h:85:55:   required from 'void Eigen::internal::apply_block_householder_on_the_left(MatrixType&, const VectorsType&, const CoeffsType&, bool) [with MatrixType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; VectorsType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; CoeffsType = Eigen::VectorBlock<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, -1>]'
..\Eigen/src/Householder/HouseholderSequence.h:333:46:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::applyThisOnTheLeft(Dest&, Workspace&) const [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Workspace = Eigen::Matrix<std::complex<float>, 1, -1>; VectorsType = Eigen::Matrix<std::complex<float>, -1, -1>; CoeffsType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; int Side = 1]'
..\Eigen/src/SVD/JacobiSVD.h:237:9:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false>, 1, -1, false> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, std::complex<float> >, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false>, 1, -1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> > > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false>, 1, -1, false> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, std::complex<float> >, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false>, 1, -1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> > > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false>, 1, -1, false>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, std::complex<float> >, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false>, 1, -1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> > >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false>, 1, -1, false>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, std::complex<float> >, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false>, 1, -1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> > >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false>, 1, -1, false>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, std::complex<float> >, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false>, 1, -1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false>, 1, -1, false>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, std::complex<float> >, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false>, 1, -1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false>, 1, -1, false>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, std::complex<float> >, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false>, 1, -1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> > >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, std::complex<float> >, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false>, 1, -1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> > >; Derived = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false>, 1, -1, false>]'
..\Eigen/src/Householder/Householder.h:91:15:   required from 'void Eigen::MatrixBase<Derived>::makeHouseholder(EssentialPart&, Eigen::MatrixBase<Derived>::Scalar&, Eigen::MatrixBase<Derived>::RealScalar&) const [with EssentialPart = Eigen::VectorBlock<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false>, -1>; Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = std::complex<float>; Eigen::MatrixBase<Derived>::RealScalar = float]'
..\Eigen/src/Householder/Householder.h:45:18:   required from 'void Eigen::MatrixBase<Derived>::makeHouseholderInPlace(Eigen::MatrixBase<Derived>::Scalar&, Eigen::MatrixBase<Derived>::RealScalar&) [with Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = std::complex<float>; Eigen::MatrixBase<Derived>::RealScalar = float]'
..\Eigen/src/QR/CompleteOrthogonalDecomposition.h:447:7:   required from 'void Eigen::CompleteOrthogonalDecomposition<MatrixType>::computeInPlace() [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/QR/CompleteOrthogonalDecomposition.h:187:19:   required from 'Eigen::CompleteOrthogonalDecomposition<MatrixType>& Eigen::CompleteOrthogonalDecomposition<MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/QR/CompleteOrthogonalDecomposition.h:118:12:   required from 'Eigen::CompleteOrthogonalDecomposition<MatrixType>::CompleteOrthogonalDecomposition(const Eigen::EigenBase<OtherDerived>&) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/QR/CompleteOrthogonalDecomposition.h:557:10:   required from 'const Eigen::CompleteOrthogonalDecomposition<typename Eigen::DenseBase<Derived>::PlainObject> Eigen::MatrixBase<Derived>::completeOrthogonalDecomposition() const [with Derived = Eigen::Matrix<std::complex<float>, -1, -1>; typename Eigen::DenseBase<Derived>::PlainObject = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:943:87:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::internal::mul_assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::internal::mul_assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Functor = Eigen::internal::mul_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Functor = Eigen::internal::mul_assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Func = Eigen::internal::mul_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Func = Eigen::internal::mul_assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/SelfCwiseBinaryOp.h:21:28:   required from 'Derived& Eigen::DenseBase<Derived>::operator*=(const Scalar&) [with Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>; Eigen::DenseBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Householder/Householder.h:157:11:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheRight(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> >; Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>; Eigen::MatrixBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:317:5:   required from 'static void Eigen::HessenbergDecomposition<_MatrixType>::_compute(Eigen::HessenbergDecomposition<_MatrixType>::MatrixType&, Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType&, Eigen::HessenbergDecomposition<_MatrixType>::VectorType&) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType = Eigen::Matrix<std::complex<float>, -1, 1>; typename _MatrixType::Scalar = std::complex<float>; Eigen::HessenbergDecomposition<_MatrixType>::VectorType = Eigen::Matrix<std::complex<float>, 1, -1>]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:161:15:   required from 'Eigen::HessenbergDecomposition<_MatrixType>& Eigen::HessenbergDecomposition<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Eigenvalues/ComplexSchur.h:358:5:   required from 'static void Eigen::internal::complex_schur_reduce_to_hessenberg<MatrixType, IsComplex>::run(Eigen::ComplexSchur<MatrixType>&, const MatrixType&, bool) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; bool IsComplex = true]'
..\Eigen/src/Eigenvalues/ComplexSchur.h:334:94:   required from 'Eigen::ComplexSchur<MatrixType>& Eigen::ComplexSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Eigenvalues/ComplexEigenSolver.h:270:3:   required from 'Eigen::ComplexEigenSolver<MatrixType>& Eigen::ComplexEigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Eigenvalues/ComplexEigenSolver.h:134:14:   required from 'Eigen::ComplexEigenSolver<_MatrixType>::ComplexEigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:954:54:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, 1, true> >, Eigen::internal::add_assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, 1, true> >, Eigen::internal::add_assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, 1, true>; Functor = Eigen::internal::add_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, 1, true>; Functor = Eigen::internal::add_assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, 1, true>; Func = Eigen::internal::add_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, 1, true>; Func = Eigen::internal::add_assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/CwiseBinaryOp.h:177:18:   required from 'Derived& Eigen::MatrixBase<Derived>::operator+=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, 1, true>; Derived = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Householder/Householder.h:164:9:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheRight(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> >; Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>; Eigen::MatrixBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:317:5:   required from 'static void Eigen::HessenbergDecomposition<_MatrixType>::_compute(Eigen::HessenbergDecomposition<_MatrixType>::MatrixType&, Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType&, Eigen::HessenbergDecomposition<_MatrixType>::VectorType&) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType = Eigen::Matrix<std::complex<float>, -1, 1>; typename _MatrixType::Scalar = std::complex<float>; Eigen::HessenbergDecomposition<_MatrixType>::VectorType = Eigen::Matrix<std::complex<float>, 1, -1>]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:161:15:   required from 'Eigen::HessenbergDecomposition<_MatrixType>& Eigen::HessenbergDecomposition<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Eigenvalues/ComplexSchur.h:358:5:   required from 'static void Eigen::internal::complex_schur_reduce_to_hessenberg<MatrixType, IsComplex>::run(Eigen::ComplexSchur<MatrixType>&, const MatrixType&, bool) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; bool IsComplex = true]'
..\Eigen/src/Eigenvalues/ComplexSchur.h:334:94:   required from 'Eigen::ComplexSchur<MatrixType>& Eigen::ComplexSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Eigenvalues/ComplexEigenSolver.h:270:3:   required from 'Eigen::ComplexEigenSolver<MatrixType>& Eigen::ComplexEigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Eigenvalues/ComplexEigenSolver.h:134:14:   required from 'Eigen::ComplexEigenSolver<_MatrixType>::ComplexEigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:954:54:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, 1, true> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > > >, Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, 1, true> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > > >, Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, 1, true>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >; Functor = Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, 1, true>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >; Functor = Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, 1, true>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >; Func = Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, 1, true>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >; Func = Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/CwiseBinaryOp.h:164:18:   required from 'Derived& Eigen::MatrixBase<Derived>::operator-=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >; Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, 1, true>]'
..\Eigen/src/Householder/Householder.h:165:18:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheRight(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> >; Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>; Eigen::MatrixBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:317:5:   required from 'static void Eigen::HessenbergDecomposition<_MatrixType>::_compute(Eigen::HessenbergDecomposition<_MatrixType>::MatrixType&, Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType&, Eigen::HessenbergDecomposition<_MatrixType>::VectorType&) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType = Eigen::Matrix<std::complex<float>, -1, 1>; typename _MatrixType::Scalar = std::complex<float>; Eigen::HessenbergDecomposition<_MatrixType>::VectorType = Eigen::Matrix<std::complex<float>, 1, -1>]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:161:15:   required from 'Eigen::HessenbergDecomposition<_MatrixType>& Eigen::HessenbergDecomposition<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Eigenvalues/ComplexSchur.h:358:5:   required from 'static void Eigen::internal::complex_schur_reduce_to_hessenberg<MatrixType, IsComplex>::run(Eigen::ComplexSchur<MatrixType>&, const MatrixType&, bool) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; bool IsComplex = true]'
..\Eigen/src/Eigenvalues/ComplexSchur.h:334:94:   required from 'Eigen::ComplexSchur<MatrixType>& Eigen::ComplexSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Eigenvalues/ComplexEigenSolver.h:270:3:   required from 'Eigen::ComplexEigenSolver<MatrixType>& Eigen::ComplexEigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Eigenvalues/ComplexEigenSolver.h:134:14:   required from 'Eigen::ComplexEigenSolver<_MatrixType>::ComplexEigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:954:54:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, 2, 2> >, Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 2, 2, false> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, 2, 2> >, Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 2, 2, false> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, 2, 2>; SrcXprType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 2, 2, false>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, 2, 2>; SrcXprType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 2, 2, false>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, 2, 2>; Src = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 2, 2, false>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 2, 2, false>; Derived = Eigen::Matrix<std::complex<float>, 2, 2>]'
..\Eigen/src/Core/PlainObjectBase.h:537:19:   required from 'Eigen::PlainObjectBase<Derived>::PlainObjectBase(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 2, 2, false>; Derived = Eigen::Matrix<std::complex<float>, 2, 2>]'
..\Eigen/src/Core/Matrix.h:379:29:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 2, 2, false>; _Scalar = std::complex<float>; int _Rows = 2; int _Cols = 2; int _Options = 0; int _MaxRows = 2; int _MaxCols = 2]'
..\Eigen/src/Eigenvalues/ComplexSchur.h:292:29:   required from 'Eigen::ComplexSchur<_MatrixType>::ComplexScalar Eigen::ComplexSchur<_MatrixType>::computeShift(Eigen::ComplexSchur<_MatrixType>::Index, Eigen::ComplexSchur<_MatrixType>::Index) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; Eigen::ComplexSchur<_MatrixType>::ComplexScalar = std::complex<float>; typename Eigen::NumTraits<typename Derived::Scalar>::Real = float; Eigen::ComplexSchur<_MatrixType>::Index = long long int]'
..\Eigen/src/Eigenvalues/ComplexSchur.h:431:39:   required from 'void Eigen::ComplexSchur<_MatrixType>::reduceToTriangularForm(bool) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Eigenvalues/ComplexSchur.h:346:25:   required from 'Eigen::ComplexSchur<MatrixType>& Eigen::ComplexSchur<_MatrixType>::computeFromHessenberg(const HessMatrixType&, const OrthMatrixType&, bool) [with HessMatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; OrthMatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Eigenvalues/ComplexSchur.h:335:24:   required from 'Eigen::ComplexSchur<MatrixType>& Eigen::ComplexSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Eigenvalues/ComplexEigenSolver.h:270:3:   required from 'Eigen::ComplexEigenSolver<MatrixType>& Eigen::ComplexEigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Eigenvalues/ComplexEigenSolver.h:134:14:   required from 'Eigen::ComplexEigenSolver<_MatrixType>::ComplexEigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:954:54:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, 1> >, Eigen::internal::evaluator<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_mean<double>, 1> >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, 1> >, Eigen::internal::evaluator<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_mean<double>, 1> >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, 1>; SrcXprType = Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_mean<double>, 1>; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, 1>; SrcXprType = Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_mean<double>, 1>; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, 1>; Src = Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_mean<double>, 1>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_mean<double>, 1>; Derived = Eigen::Matrix<double, -1, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_mean<double>, 1>; OtherDerived = Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_mean<double>, 1>; Derived = Eigen::Matrix<double, -1, 1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_mean<double>, 1>; _Scalar = double; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Core/CoreEvaluators.h:1192:49:   required from 'Eigen::internal::unary_evaluator<Eigen::Replicate<ArgType, RowFactor, ColFactor> >::unary_evaluator(const XprType&) [with ArgType = Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_mean<double>, 1>; int RowFactor = -1; int ColFactor = -1; typename Eigen::Replicate<ArgType, RowFactor, ColFactor>::Scalar = double; typename Eigen::internal::evaluator_traits<typename Eigen::Replicate<ArgType, RowFactor, ColFactor>::NestedExpression>::Kind = Eigen::internal::IndexBased; Eigen::internal::unary_evaluator<Eigen::Replicate<ArgType, RowFactor, ColFactor> >::XprType = Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_mean<double>, 1>, -1, -1>]'
..\Eigen/src/Core/CoreEvaluators.h:93:64:   required from 'Eigen::internal::evaluator<T>::evaluator(const T&) [with T = Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_mean<double>, 1>, -1, -1>]'
..\Eigen/src/Core/AssignEvaluator.h:753:19:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_mean<double>, 1>, -1, -1>; Functor = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_mean<double>, 1>, -1, -1>; Functor = Eigen::internal::sub_assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_mean<double>, 1>, -1, -1>; Func = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_mean<double>, 1>, -1, -1>; Func = Eigen::internal::sub_assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/CwiseBinaryOp.h:164:18:   required from 'Derived& Eigen::MatrixBase<Derived>::operator-=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_mean<double>, 1>, -1, -1>; Derived = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >]'
..\binary_library.cpp:144:43:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 1> >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 1> >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 1>; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 1>; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 1>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/ProductEvaluators.h:397:29:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 3>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:431:26:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 0>; OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 0>; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 0>; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 0>]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 0>; Derived = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >]'
..\binary_library.cpp:166:15:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> > > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> > > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> > >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> > >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> > >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> > >; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> > >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> > >; Derived = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>]'
..\Eigen/src/Householder/Householder.h:91:15:   required from 'void Eigen::MatrixBase<Derived>::makeHouseholder(EssentialPart&, Eigen::MatrixBase<Derived>::Scalar&, Eigen::MatrixBase<Derived>::RealScalar&) const [with EssentialPart = Eigen::VectorBlock<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, -1>; Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Eigen::MatrixBase<Derived>::Scalar = double; Eigen::MatrixBase<Derived>::RealScalar = double]'
..\Eigen/src/Householder/Householder.h:45:18:   required from 'void Eigen::MatrixBase<Derived>::makeHouseholderInPlace(Eigen::MatrixBase<Derived>::Scalar&, Eigen::MatrixBase<Derived>::RealScalar&) [with Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Eigen::MatrixBase<Derived>::Scalar = double; Eigen::MatrixBase<Derived>::RealScalar = double]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:305:5:   required from 'static void Eigen::HessenbergDecomposition<_MatrixType>::_compute(Eigen::HessenbergDecomposition<_MatrixType>::MatrixType&, Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType&, Eigen::HessenbergDecomposition<_MatrixType>::VectorType&) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType = Eigen::Matrix<double, -1, 1>; typename _MatrixType::Scalar = double; Eigen::HessenbergDecomposition<_MatrixType>::VectorType = Eigen::Matrix<double, 1, -1>]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:161:15:   required from 'Eigen::HessenbergDecomposition<_MatrixType>& Eigen::HessenbergDecomposition<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&) [with InputType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:271:3:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, 3, 1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 3, 1> > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, 3, 1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 3, 1> > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, 3, 1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 3, 1> >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, 3, 1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 3, 1> >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, 3, 1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 3, 1> >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<double, 3, 1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 3, 1> >; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, 3, 1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 3, 1> >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 3, 1> >; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1]'
..\Eigen/src/Core/CwiseNullaryOp.h:327:20:   required from 'Derived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Matrix<double, 3, 1>; Eigen::DenseBase<Derived>::Scalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:453:7:   required from 'void Eigen::RealSchur<_MatrixType>::computeShift(Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Scalar&, Eigen::RealSchur<_MatrixType>::Vector3s&) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::RealSchur<_MatrixType>::Index = long long int; Eigen::RealSchur<_MatrixType>::Scalar = double; Eigen::RealSchur<_MatrixType>::Vector3s = Eigen::Matrix<double, 3, 1>; typename MatrixType::Scalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:331:21:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::computeFromHessenberg(const HessMatrixType&, const OrthMatrixType&, bool) [with HessMatrixType = Eigen::internal::HessenbergDecompositionMatrixHReturnType<Eigen::Matrix<double, -1, -1> >; OrthMatrixType = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:274:24:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, 2, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Block<const Eigen::Matrix<double, 3, 1>, 2, 1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> > > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, 2, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Block<const Eigen::Matrix<double, 3, 1>, 2, 1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> > > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, 2, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Block<const Eigen::Matrix<double, 3, 1>, 2, 1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> > >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, 2, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Block<const Eigen::Matrix<double, 3, 1>, 2, 1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> > >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, 2, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Block<const Eigen::Matrix<double, 3, 1>, 2, 1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> > >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<double, 2, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Block<const Eigen::Matrix<double, 3, 1>, 2, 1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> > >; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, 2, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Block<const Eigen::Matrix<double, 3, 1>, 2, 1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> > >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Block<const Eigen::Matrix<double, 3, 1>, 2, 1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> > >; Derived = Eigen::Matrix<double, 2, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Block<const Eigen::Matrix<double, 3, 1>, 2, 1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> > >; _Scalar = double; int _Rows = 2; int _Cols = 1; int _Options = 0; int _MaxRows = 2; int _MaxCols = 1]'
..\Eigen/src/Householder/Householder.h:91:15:   required from 'void Eigen::MatrixBase<Derived>::makeHouseholder(EssentialPart&, Eigen::MatrixBase<Derived>::Scalar&, Eigen::MatrixBase<Derived>::RealScalar&) const [with EssentialPart = Eigen::Matrix<double, 2, 1>; Derived = Eigen::Matrix<double, 3, 1>; Eigen::MatrixBase<Derived>::Scalar = double; Eigen::MatrixBase<Derived>::RealScalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:504:5:   required from 'void Eigen::RealSchur<_MatrixType>::performFrancisQRStep(Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, bool, const Vector3s&, Eigen::RealSchur<_MatrixType>::Scalar*) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::RealSchur<_MatrixType>::Index = long long int; Eigen::RealSchur<_MatrixType>::Vector3s = Eigen::Matrix<double, 3, 1>; typename MatrixType::Scalar = double; Eigen::RealSchur<_MatrixType>::Scalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:337:29:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::computeFromHessenberg(const HessMatrixType&, const OrthMatrixType&, bool) [with HessMatrixType = Eigen::internal::HessenbergDecompositionMatrixHReturnType<Eigen::Matrix<double, -1, -1> >; OrthMatrixType = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:274:24:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Product<Eigen::Transpose<const Eigen::Matrix<double, 2, 1> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 2, -1, false>, 1> >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Product<Eigen::Transpose<const Eigen::Matrix<double, 2, 1> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 2, -1, false>, 1> >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Product<Eigen::Transpose<const Eigen::Matrix<double, 2, 1> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 2, -1, false>, 1>; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Product<Eigen::Transpose<const Eigen::Matrix<double, 2, 1> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 2, -1, false>, 1>; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::Transpose<const Eigen::Matrix<double, 2, 1> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 2, -1, false>, 1>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/ProductEvaluators.h:397:29:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 3>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Transpose<const Eigen::Matrix<double, 2, 1> >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 2, -1, false>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Transpose<const Eigen::Matrix<double, 2, 1> >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 2, -1, false>; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Transpose<const Eigen::Matrix<double, 2, 1> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 2, -1, false>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::Transpose<const Eigen::Matrix<double, 2, 1> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 2, -1, false>, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/NoAlias.h:42:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Transpose<const Eigen::Matrix<double, 2, 1> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 2, -1, false>, 0>; ExpressionType = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:126:19:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheLeft(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Matrix<double, 2, 1>; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:514:7:   required from 'void Eigen::RealSchur<_MatrixType>::performFrancisQRStep(Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, bool, const Vector3s&, Eigen::RealSchur<_MatrixType>::Scalar*) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::RealSchur<_MatrixType>::Index = long long int; Eigen::RealSchur<_MatrixType>::Vector3s = Eigen::Matrix<double, 3, 1>; typename MatrixType::Scalar = double; Eigen::RealSchur<_MatrixType>::Scalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:337:29:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::computeFromHessenberg(const HessMatrixType&, const OrthMatrixType&, bool) [with HessMatrixType = Eigen::internal::HessenbergDecompositionMatrixHReturnType<Eigen::Matrix<double, -1, -1> >; OrthMatrixType = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:274:24:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 2, -1, false> >, Eigen::internal::evaluator<Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> >, const Eigen::Matrix<double, 2, 1> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 1> >, Eigen::internal::sub_assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 2, -1, false> >, Eigen::internal::evaluator<Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> >, const Eigen::Matrix<double, 2, 1> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 1> >, Eigen::internal::sub_assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 2, -1, false>; SrcXprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> >, const Eigen::Matrix<double, 2, 1> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 1>; Functor = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 2, -1, false>; SrcXprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> >, const Eigen::Matrix<double, 2, 1> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 1>; Functor = Eigen::internal::sub_assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 2, -1, false>; Src = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> >, const Eigen::Matrix<double, 2, 1> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 1>; Func = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/ProductEvaluators.h:411:29:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 3>::subTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 2, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> >, const Eigen::Matrix<double, 2, 1> >; Rhs = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/ProductEvaluators.h:178:42:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::sub_assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 2, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> >, const Eigen::Matrix<double, 2, 1> >; Rhs = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> >, const Eigen::Matrix<double, 2, 1> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 2, -1, false>; Src = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> >, const Eigen::Matrix<double, 2, 1> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 0>; Func = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/NoAlias.h:58:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator-=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> >, const Eigen::Matrix<double, 2, 1> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 0>; ExpressionType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 2, -1, false>; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:129:22:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheLeft(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Matrix<double, 2, 1>; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:514:7:   required from 'void Eigen::RealSchur<_MatrixType>::performFrancisQRStep(Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, bool, const Vector3s&, Eigen::RealSchur<_MatrixType>::Scalar*) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::RealSchur<_MatrixType>::Index = long long int; Eigen::RealSchur<_MatrixType>::Vector3s = Eigen::Matrix<double, 3, 1>; typename MatrixType::Scalar = double; Eigen::RealSchur<_MatrixType>::Scalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:337:29:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::computeFromHessenberg(const HessMatrixType&, const OrthMatrixType&, bool) [with HessMatrixType = Eigen::internal::HessenbergDecompositionMatrixHReturnType<Eigen::Matrix<double, -1, -1> >; OrthMatrixType = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:274:24:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 2, false>, Eigen::Matrix<double, 2, 1>, 1> >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 2, false>, Eigen::Matrix<double, 2, 1>, 1> >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 2, false>, Eigen::Matrix<double, 2, 1>, 1>; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 2, false>, Eigen::Matrix<double, 2, 1>, 1>; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 2, false>, Eigen::Matrix<double, 2, 1>, 1>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/ProductEvaluators.h:397:29:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 3>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 2, false>; Rhs = Eigen::Matrix<double, 2, 1>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 2, false>; Rhs = Eigen::Matrix<double, 2, 1>; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 2, false>, Eigen::Matrix<double, 2, 1>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 2, false>, Eigen::Matrix<double, 2, 1>, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/NoAlias.h:42:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 2, false>, Eigen::Matrix<double, 2, 1>, 0>; ExpressionType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:163:19:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheRight(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Matrix<double, 2, 1>; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:515:7:   required from 'void Eigen::RealSchur<_MatrixType>::performFrancisQRStep(Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, bool, const Vector3s&, Eigen::RealSchur<_MatrixType>::Scalar*) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::RealSchur<_MatrixType>::Index = long long int; Eigen::RealSchur<_MatrixType>::Vector3s = Eigen::Matrix<double, 3, 1>; typename MatrixType::Scalar = double; Eigen::RealSchur<_MatrixType>::Scalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:337:29:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::computeFromHessenberg(const HessMatrixType&, const OrthMatrixType&, bool) [with HessMatrixType = Eigen::internal::HessenbergDecompositionMatrixHReturnType<Eigen::Matrix<double, -1, -1> >; OrthMatrixType = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:274:24:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 2, false> >, Eigen::internal::evaluator<Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::Transpose<const Eigen::Matrix<double, 2, 1> >, 1> >, Eigen::internal::sub_assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 2, false> >, Eigen::internal::evaluator<Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::Transpose<const Eigen::Matrix<double, 2, 1> >, 1> >, Eigen::internal::sub_assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 2, false>; SrcXprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::Transpose<const Eigen::Matrix<double, 2, 1> >, 1>; Functor = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 2, false>; SrcXprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::Transpose<const Eigen::Matrix<double, 2, 1> >, 1>; Functor = Eigen::internal::sub_assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 2, false>; Src = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::Transpose<const Eigen::Matrix<double, 2, 1> >, 1>; Func = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/ProductEvaluators.h:411:29:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 3>::subTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 2, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >; Rhs = Eigen::Transpose<const Eigen::Matrix<double, 2, 1> >]'
..\Eigen/src/Core/ProductEvaluators.h:178:42:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::sub_assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 2, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >; Rhs = Eigen::Transpose<const Eigen::Matrix<double, 2, 1> >; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::Transpose<const Eigen::Matrix<double, 2, 1> >, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 2, false>; Src = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::Transpose<const Eigen::Matrix<double, 2, 1> >, 0>; Func = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/NoAlias.h:58:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator-=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::Transpose<const Eigen::Matrix<double, 2, 1> >, 0>; ExpressionType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 2, false>; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:166:21:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheRight(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Matrix<double, 2, 1>; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:515:7:   required from 'void Eigen::RealSchur<_MatrixType>::performFrancisQRStep(Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, bool, const Vector3s&, Eigen::RealSchur<_MatrixType>::Scalar*) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::RealSchur<_MatrixType>::Index = long long int; Eigen::RealSchur<_MatrixType>::Vector3s = Eigen::Matrix<double, 3, 1>; typename MatrixType::Scalar = double; Eigen::RealSchur<_MatrixType>::Scalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:337:29:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::computeFromHessenberg(const HessMatrixType&, const OrthMatrixType&, bool) [with HessMatrixType = Eigen::internal::HessenbergDecompositionMatrixHReturnType<Eigen::Matrix<double, -1, -1> >; OrthMatrixType = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:274:24:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, 1, 1, 0, 1, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Block<const Eigen::Matrix<double, 2, 1>, 1, 1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, 1, 1, 0, 1, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Block<const Eigen::Matrix<double, 2, 1>, 1, 1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, 1, 1, 0, 1, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Block<const Eigen::Matrix<double, 2, 1>, 1, 1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, 1, 1, 0, 1, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Block<const Eigen::Matrix<double, 2, 1>, 1, 1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, 1, 1, 0, 1, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Block<const Eigen::Matrix<double, 2, 1>, 1, 1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<double, 1, 1, 0, 1, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Block<const Eigen::Matrix<double, 2, 1>, 1, 1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > >; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, 1, 1, 0, 1, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Block<const Eigen::Matrix<double, 2, 1>, 1, 1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Block<const Eigen::Matrix<double, 2, 1>, 1, 1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > >; Derived = Eigen::Matrix<double, 1, 1, 0, 1, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Block<const Eigen::Matrix<double, 2, 1>, 1, 1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > >; _Scalar = double; int _Rows = 1; int _Cols = 1; int _Options = 0; int _MaxRows = 1; int _MaxCols = 1]'
..\Eigen/src/Householder/Householder.h:91:15:   required from 'void Eigen::MatrixBase<Derived>::makeHouseholder(EssentialPart&, Eigen::MatrixBase<Derived>::Scalar&, Eigen::MatrixBase<Derived>::RealScalar&) const [with EssentialPart = Eigen::Matrix<double, 1, 1, 0, 1, 1>; Derived = Eigen::Matrix<double, 2, 1>; Eigen::MatrixBase<Derived>::Scalar = double; Eigen::MatrixBase<Derived>::RealScalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:524:3:   required from 'void Eigen::RealSchur<_MatrixType>::performFrancisQRStep(Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, bool, const Vector3s&, Eigen::RealSchur<_MatrixType>::Scalar*) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::RealSchur<_MatrixType>::Index = long long int; Eigen::RealSchur<_MatrixType>::Vector3s = Eigen::Matrix<double, 3, 1>; typename MatrixType::Scalar = double; Eigen::RealSchur<_MatrixType>::Scalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:337:29:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::computeFromHessenberg(const HessMatrixType&, const OrthMatrixType&, bool) [with HessMatrixType = Eigen::internal::HessenbergDecompositionMatrixHReturnType<Eigen::Matrix<double, -1, -1> >; OrthMatrixType = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:274:24:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Product<Eigen::Transpose<const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false>, 1> >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Product<Eigen::Transpose<const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false>, 1> >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Product<Eigen::Transpose<const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false>, 1>; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Product<Eigen::Transpose<const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false>, 1>; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::Transpose<const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false>, 1>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/ProductEvaluators.h:397:29:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 3>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Transpose<const Eigen::Matrix<double, 1, 1, 0, 1, 1> >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Transpose<const Eigen::Matrix<double, 1, 1, 0, 1, 1> >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false>; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Transpose<const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::Transpose<const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false>, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/NoAlias.h:42:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Transpose<const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false>, 0>; ExpressionType = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:126:19:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheLeft(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Matrix<double, 1, 1, 0, 1, 1>; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:529:5:   required from 'void Eigen::RealSchur<_MatrixType>::performFrancisQRStep(Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, bool, const Vector3s&, Eigen::RealSchur<_MatrixType>::Scalar*) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::RealSchur<_MatrixType>::Index = long long int; Eigen::RealSchur<_MatrixType>::Vector3s = Eigen::Matrix<double, 3, 1>; typename MatrixType::Scalar = double; Eigen::RealSchur<_MatrixType>::Scalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:337:29:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::computeFromHessenberg(const HessMatrixType&, const OrthMatrixType&, bool) [with HessMatrixType = Eigen::internal::HessenbergDecompositionMatrixHReturnType<Eigen::Matrix<double, -1, -1> >; OrthMatrixType = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:274:24:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false> >, Eigen::internal::evaluator<Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 1> >, Eigen::internal::sub_assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false> >, Eigen::internal::evaluator<Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 1> >, Eigen::internal::sub_assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false>; SrcXprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 1>; Functor = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false>; SrcXprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 1>; Functor = Eigen::internal::sub_assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false>; Src = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 1>; Func = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/ProductEvaluators.h:411:29:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 3>::subTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >; Rhs = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/ProductEvaluators.h:178:42:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::sub_assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >; Rhs = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false>; Src = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 0>; Func = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/NoAlias.h:58:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator-=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 0>; ExpressionType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false>; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:129:22:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheLeft(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Matrix<double, 1, 1, 0, 1, 1>; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:529:5:   required from 'void Eigen::RealSchur<_MatrixType>::performFrancisQRStep(Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, bool, const Vector3s&, Eigen::RealSchur<_MatrixType>::Scalar*) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::RealSchur<_MatrixType>::Index = long long int; Eigen::RealSchur<_MatrixType>::Vector3s = Eigen::Matrix<double, 3, 1>; typename MatrixType::Scalar = double; Eigen::RealSchur<_MatrixType>::Scalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:337:29:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::computeFromHessenberg(const HessMatrixType&, const OrthMatrixType&, bool) [with HessMatrixType = Eigen::internal::HessenbergDecompositionMatrixHReturnType<Eigen::Matrix<double, -1, -1> >; OrthMatrixType = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:274:24:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 1, false>, Eigen::Matrix<double, 1, 1, 0, 1, 1>, 1> >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 1, false>, Eigen::Matrix<double, 1, 1, 0, 1, 1>, 1> >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 1, false>, Eigen::Matrix<double, 1, 1, 0, 1, 1>, 1>; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 1, false>, Eigen::Matrix<double, 1, 1, 0, 1, 1>, 1>; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 1, false>, Eigen::Matrix<double, 1, 1, 0, 1, 1>, 1>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/ProductEvaluators.h:397:29:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 3>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 1, false>; Rhs = Eigen::Matrix<double, 1, 1, 0, 1, 1>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 1, false>; Rhs = Eigen::Matrix<double, 1, 1, 0, 1, 1>; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 1, false>, Eigen::Matrix<double, 1, 1, 0, 1, 1>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 1, false>, Eigen::Matrix<double, 1, 1, 0, 1, 1>, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/NoAlias.h:42:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 1, false>, Eigen::Matrix<double, 1, 1, 0, 1, 1>, 0>; ExpressionType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:163:19:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheRight(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Matrix<double, 1, 1, 0, 1, 1>; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:530:5:   required from 'void Eigen::RealSchur<_MatrixType>::performFrancisQRStep(Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, bool, const Vector3s&, Eigen::RealSchur<_MatrixType>::Scalar*) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::RealSchur<_MatrixType>::Index = long long int; Eigen::RealSchur<_MatrixType>::Vector3s = Eigen::Matrix<double, 3, 1>; typename MatrixType::Scalar = double; Eigen::RealSchur<_MatrixType>::Scalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:337:29:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::computeFromHessenberg(const HessMatrixType&, const OrthMatrixType&, bool) [with HessMatrixType = Eigen::internal::HessenbergDecompositionMatrixHReturnType<Eigen::Matrix<double, -1, -1> >; OrthMatrixType = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:274:24:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 1, false> >, Eigen::internal::evaluator<Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::Transpose<const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, 1> >, Eigen::internal::sub_assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 1, false> >, Eigen::internal::evaluator<Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::Transpose<const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, 1> >, Eigen::internal::sub_assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 1, false>; SrcXprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::Transpose<const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, 1>; Functor = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 1, false>; SrcXprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::Transpose<const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, 1>; Functor = Eigen::internal::sub_assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 1, false>; Src = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::Transpose<const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, 1>; Func = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/ProductEvaluators.h:411:29:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 3>::subTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >; Rhs = Eigen::Transpose<const Eigen::Matrix<double, 1, 1, 0, 1, 1> >]'
..\Eigen/src/Core/ProductEvaluators.h:178:42:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::sub_assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >; Rhs = Eigen::Transpose<const Eigen::Matrix<double, 1, 1, 0, 1, 1> >; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::Transpose<const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 1, false>; Src = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::Transpose<const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, 0>; Func = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/NoAlias.h:58:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator-=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::Transpose<const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, 0>; ExpressionType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, 1, false>; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:166:21:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheRight(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Matrix<double, 1, 1, 0, 1, 1>; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:530:5:   required from 'void Eigen::RealSchur<_MatrixType>::performFrancisQRStep(Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, bool, const Vector3s&, Eigen::RealSchur<_MatrixType>::Scalar*) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::RealSchur<_MatrixType>::Index = long long int; Eigen::RealSchur<_MatrixType>::Vector3s = Eigen::Matrix<double, 3, 1>; typename MatrixType::Scalar = double; Eigen::RealSchur<_MatrixType>::Scalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:337:29:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::computeFromHessenberg(const HessMatrixType&, const OrthMatrixType&, bool) [with HessMatrixType = Eigen::internal::HessenbergDecompositionMatrixHReturnType<Eigen::Matrix<double, -1, -1> >; OrthMatrixType = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:274:24:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 1> >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 1> >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 1>; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 1>; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 1>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/ProductEvaluators.h:397:29:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 3>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Transpose<Eigen::Matrix<double, -1, -1> >; Rhs = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:431:26:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Transpose<Eigen::Matrix<double, -1, -1> >; Rhs = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Transpose<Eigen::Matrix<double, -1, -1> >; Rhs = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 0>; OtherDerived = Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 0>; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 0>; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 0>]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 0>; Derived = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >]'
..\binary_library.cpp:184:25:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, -1>, 1> >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, -1>, 1> >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, -1>, 1>; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, -1>, 1>; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, -1>, 1>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/ProductEvaluators.h:397:29:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 3>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Transpose<Eigen::Matrix<double, -1, -1> >; Rhs = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:431:26:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Transpose<Eigen::Matrix<double, -1, -1> >; Rhs = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Transpose<Eigen::Matrix<double, -1, -1> >; Rhs = Eigen::Matrix<double, -1, -1>; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, -1>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, -1>, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, -1>, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, -1>, 0>; OtherDerived = Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, -1>, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, -1>, 0>; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, -1>, 0>; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, -1>, 0>]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, -1>, 0>; Derived = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >]'
..\binary_library.cpp:185:30:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, std::complex<float> >, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> > > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, std::complex<float> >, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> > > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, std::complex<float> >, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> > >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, std::complex<float> >, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> > >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, std::complex<float> >, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, std::complex<float> >, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, std::complex<float> >, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> > >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, std::complex<float> >, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> > >; Derived = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>]'
..\Eigen/src/Householder/Householder.h:91:15:   required from 'void Eigen::MatrixBase<Derived>::makeHouseholder(EssentialPart&, Eigen::MatrixBase<Derived>::Scalar&, Eigen::MatrixBase<Derived>::RealScalar&) const [with EssentialPart = Eigen::VectorBlock<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>, -1>; Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>; Eigen::MatrixBase<Derived>::Scalar = std::complex<float>; Eigen::MatrixBase<Derived>::RealScalar = float]'
..\Eigen/src/Householder/Householder.h:45:18:   required from 'void Eigen::MatrixBase<Derived>::makeHouseholderInPlace(Eigen::MatrixBase<Derived>::Scalar&, Eigen::MatrixBase<Derived>::RealScalar&) [with Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>; Eigen::MatrixBase<Derived>::Scalar = std::complex<float>; Eigen::MatrixBase<Derived>::RealScalar = float]'
..\Eigen/src/QR/ColPivHouseholderQR.h:538:5:   required from 'void Eigen::ColPivHouseholderQR<MatrixType>::computeInPlace() [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/QR/ColPivHouseholderQR.h:475:17:   required from 'Eigen::ColPivHouseholderQR<_MatrixType>& Eigen::ColPivHouseholderQR<MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:230:7:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
In file included from ..\Eigen/Core:473:0,
                 from ..\binary_library.cpp:18:
..\Eigen/src/Core/products/GeneralMatrixVector.h: In instantiation of 'static void Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 0, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::run(Index, Index, const LhsMapper&, const RhsMapper&, Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 0, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::ResScalar*, Index, RhsScalar) [with Index = long long int; LhsScalar = std::complex<float>; LhsMapper = Eigen::internal::const_blas_data_mapper<std::complex<float>, long long int, 0>; bool ConjugateLhs = false; RhsScalar = std::complex<float>; RhsMapper = Eigen::internal::const_blas_data_mapper<std::complex<float>, long long int, 1>; bool ConjugateRhs = true; int Version = 0; Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 0, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::ResScalar = std::complex<float>]':
..\Eigen/src/Core/GeneralProduct.h:239:134:   required from 'static void Eigen::internal::gemv_dense_selector<2, 0, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; Dest = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; typename Dest::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/NoAlias.h:42:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, 0>; ExpressionType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:163:19:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheRight(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false>; Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Householder/HouseholderSequence.h:255:13:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::evalTo(Dest&, Workspace&) const [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Workspace = Eigen::Matrix<std::complex<float>, 1, -1>; VectorsType = Eigen::Matrix<std::complex<float>, -1, -1>; CoeffsType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; int Side = 1]'
..\Eigen/src/SVD/JacobiSVD.h:233:30:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/products/GeneralMatrixVector.h:186:39: warning: enum constant in boolean context [-Wint-in-bool-context]
   const Index offset1 = (FirstAligned && alignmentStep==1)?3:1;
                         ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/products/GeneralMatrixVector.h:187:39: warning: enum constant in boolean context [-Wint-in-bool-context]
   const Index offset3 = (FirstAligned && alignmentStep==1)?1:3;
                         ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from ..\Eigen/Core:420:0,
                 from ..\binary_library.cpp:18:
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 1> >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 1> >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 1>; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 1>; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 1>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/ProductEvaluators.h:397:29:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 3>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Rhs = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:431:26:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Rhs = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Rhs = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 0>; OtherDerived = Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 0>; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 0>; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 0>]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, 0>; Derived = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >]'
..\binary_library.cpp:1100:53:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, -1>, 1> >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, -1>, 1> >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, -1>, 1>; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, -1>, 1>; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, -1>, 1>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/ProductEvaluators.h:397:29:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 3>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:431:26:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; int Options = 0; Scalar = std::complex<long long int>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:216:17:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 1> >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 1> >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 1>; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 1>; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 1>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/ProductEvaluators.h:397:29:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 3>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >; Rhs = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:431:26:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >; Rhs = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >; Rhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; int Options = 0; Scalar = std::complex<long long int>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:225:25:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::MatrixWrapper<Eigen::Array<std::complex<long long int>, -1, -1> >, 1> >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::MatrixWrapper<Eigen::Array<std::complex<long long int>, -1, -1> >, 1> >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::MatrixWrapper<Eigen::Array<std::complex<long long int>, -1, -1> >, 1>; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::MatrixWrapper<Eigen::Array<std::complex<long long int>, -1, -1> >, 1>; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::MatrixWrapper<Eigen::Array<std::complex<long long int>, -1, -1> >, 1>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/ProductEvaluators.h:397:29:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 3>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::MatrixWrapper<Eigen::Array<std::complex<long long int>, -1, -1> >]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:431:26:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::MatrixWrapper<Eigen::Array<std::complex<long long int>, -1, -1> >]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::MatrixWrapper<Eigen::Array<std::complex<long long int>, -1, -1> >; int Options = 0; Scalar = std::complex<long long int>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::MatrixWrapper<Eigen::Array<std::complex<long long int>, -1, -1> >, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::MatrixWrapper<Eigen::Array<std::complex<long long int>, -1, -1> >, 0>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::MatrixWrapper<Eigen::Array<std::complex<long long int>, -1, -1> >, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::MatrixWrapper<Eigen::Array<std::complex<long long int>, -1, -1> >, 0>; OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::MatrixWrapper<Eigen::Array<std::complex<long long int>, -1, -1> >, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::MatrixWrapper<Eigen::Array<std::complex<long long int>, -1, -1> >, 0>; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::MatrixWrapper<Eigen::Array<std::complex<long long int>, -1, -1> >, 0>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::MatrixWrapper<Eigen::Array<std::complex<long long int>, -1, -1> >, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::MatrixWrapper<Eigen::Array<std::complex<long long int>, -1, -1> >, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::MatrixWrapper<Eigen::Array<std::complex<long long int>, -1, -1> >, 0>; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:242:24:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 1> >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 1> >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 1>; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 1>; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 1>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/ProductEvaluators.h:397:29:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 3>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Lhs = Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >; Rhs = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:431:26:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Lhs = Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >; Rhs = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; Lhs = Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >; Rhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; int Options = 0; Scalar = std::complex<long long int>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; OtherDerived = Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:254:31:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::Matrix<std::complex<float>, -1, -1>, 1> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::Matrix<std::complex<float>, -1, -1>, 1> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::Matrix<std::complex<float>, -1, -1>, 1>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::Matrix<std::complex<float>, -1, -1>, 1>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::Matrix<std::complex<float>, -1, -1>, 1>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/ProductEvaluators.h:397:29:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 3>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >; Rhs = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:431:26:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >; Rhs = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >; Rhs = Eigen::Matrix<std::complex<float>, -1, -1>; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::Matrix<std::complex<float>, -1, -1>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::Matrix<std::complex<float>, -1, -1>, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::Matrix<std::complex<float>, -1, -1>, 0>; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::Matrix<std::complex<float>, -1, -1>, 0>; OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::Matrix<std::complex<float>, -1, -1>, 0>; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::Matrix<std::complex<float>, -1, -1>, 0>; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::Matrix<std::complex<float>, -1, -1>, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::Matrix<std::complex<float>, -1, -1>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::Matrix<std::complex<float>, -1, -1>, 0>; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::Matrix<std::complex<float>, -1, -1>, 0>; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:289:24:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
In file included from ..\Eigen/Core:473:0,
                 from ..\binary_library.cpp:18:
..\Eigen/src/Core/products/GeneralMatrixVector.h: In instantiation of 'static void Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 0, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::run(Index, Index, const LhsMapper&, const RhsMapper&, Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 0, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::ResScalar*, Index, RhsScalar) [with Index = long long int; LhsScalar = std::complex<long long int>; LhsMapper = Eigen::internal::const_blas_data_mapper<std::complex<long long int>, long long int, 0>; bool ConjugateLhs = false; RhsScalar = std::complex<long long int>; RhsMapper = Eigen::internal::const_blas_data_mapper<std::complex<long long int>, long long int, 1>; bool ConjugateRhs = false; int Version = 0; Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 0, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::ResScalar = std::complex<long long int>]':
..\Eigen/src/Core/GeneralProduct.h:239:134:   required from 'static void Eigen::internal::gemv_dense_selector<2, 0, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; Dest = Eigen::Matrix<std::complex<long long int>, -1, 1>; typename Dest::Scalar = std::complex<long long int>]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<std::complex<long long int>, -1, 1>; Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = std::complex<long long int>]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; Derived = Eigen::internal::generic_product_impl<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = std::complex<long long int>]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; Derived = Eigen::internal::generic_product_impl<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; int Options = 0; Scalar = std::complex<long long int>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\binary_library.cpp:428:18:   required from here
..\Eigen/src/Core/products/GeneralMatrixVector.h:186:39: warning: enum constant in boolean context [-Wint-in-bool-context]
   const Index offset1 = (FirstAligned && alignmentStep==1)?3:1;
                         ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/products/GeneralMatrixVector.h:187:39: warning: enum constant in boolean context [-Wint-in-bool-context]
   const Index offset3 = (FirstAligned && alignmentStep==1)?1:3;
                         ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/products/GeneralMatrixVector.h: In instantiation of 'static void Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 1, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::run(Index, Index, const LhsMapper&, const RhsMapper&, Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 1, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::ResScalar*, Index, Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 1, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::ResScalar) [with Index = long long int; LhsScalar = std::complex<long long int>; LhsMapper = Eigen::internal::const_blas_data_mapper<std::complex<long long int>, long long int, 1>; bool ConjugateLhs = true; RhsScalar = std::complex<long long int>; RhsMapper = Eigen::internal::const_blas_data_mapper<std::complex<long long int>, long long int, 0>; bool ConjugateRhs = false; int Version = 0; Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 1, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::ResScalar = std::complex<long long int>]':
..\Eigen/src/Core/GeneralProduct.h:334:132:   required from 'static void Eigen::internal::gemv_dense_selector<2, 1, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; Dest = Eigen::Matrix<std::complex<long long int>, -1, 1>; typename Dest::Scalar = std::complex<long long int>]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<std::complex<long long int>, -1, 1>; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = std::complex<long long int>]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; Derived = Eigen::internal::generic_product_impl<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, 1>, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = std::complex<long long int>]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; Derived = Eigen::internal::generic_product_impl<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, 1>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; int Options = 0; Scalar = std::complex<long long int>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\binary_library.cpp:443:26:   required from here
..\Eigen/src/Core/products/GeneralMatrixVector.h:460:39: warning: enum constant in boolean context [-Wint-in-bool-context]
   const Index offset1 = (FirstAligned && alignmentStep==1)?3:1;
                         ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/products/GeneralMatrixVector.h:461:39: warning: enum constant in boolean context [-Wint-in-bool-context]
   const Index offset3 = (FirstAligned && alignmentStep==1)?1:3;
                         ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/products/GeneralMatrixVector.h: In instantiation of 'static void Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 0, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::run(Index, Index, const LhsMapper&, const RhsMapper&, Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 0, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::ResScalar*, Index, RhsScalar) [with Index = long long int; LhsScalar = long long int; LhsMapper = Eigen::internal::const_blas_data_mapper<long long int, long long int, 0>; bool ConjugateLhs = false; RhsScalar = long long int; RhsMapper = Eigen::internal::const_blas_data_mapper<long long int, long long int, 1>; bool ConjugateRhs = false; int Version = 0; Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 0, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::ResScalar = long long int]':
..\Eigen/src/Core/GeneralProduct.h:239:134:   required from 'static void Eigen::internal::gemv_dense_selector<2, 0, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Matrix<long long int, -1, -1>; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Dest = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; typename Dest::Scalar = long long int]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Lhs = Eigen::Matrix<long long int, -1, -1>; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = long long int]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Lhs = Eigen::Matrix<long long int, -1, -1>; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Derived = Eigen::internal::generic_product_impl<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = long long int]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Lhs = Eigen::Matrix<long long int, -1, -1>; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Derived = Eigen::internal::generic_product_impl<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Lhs = Eigen::Matrix<long long int, -1, -1>; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; int Options = 0; Scalar = long long int; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Func = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Derived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; OtherDerived = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Derived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; _Scalar = long long int; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Func = Eigen::internal::assign_op<long long int, long long int>; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Derived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; _Scalar = long long int; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\binary_library.cpp:517:24:   required from here
..\Eigen/src/Core/products/GeneralMatrixVector.h:186:39: warning: enum constant in boolean context [-Wint-in-bool-context]
   const Index offset1 = (FirstAligned && alignmentStep==1)?3:1;
                         ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/products/GeneralMatrixVector.h:187:39: warning: enum constant in boolean context [-Wint-in-bool-context]
   const Index offset3 = (FirstAligned && alignmentStep==1)?1:3;
                         ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/products/GeneralMatrixVector.h: In instantiation of 'static void Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 1, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::run(Index, Index, const LhsMapper&, const RhsMapper&, Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 1, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::ResScalar*, Index, Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 1, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::ResScalar) [with Index = long long int; LhsScalar = long long int; LhsMapper = Eigen::internal::const_blas_data_mapper<long long int, long long int, 1>; bool ConjugateLhs = false; RhsScalar = long long int; RhsMapper = Eigen::internal::const_blas_data_mapper<long long int, long long int, 0>; bool ConjugateRhs = false; int Version = 0; Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 1, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::ResScalar = long long int]':
..\Eigen/src/Core/GeneralProduct.h:334:132:   required from 'static void Eigen::internal::gemv_dense_selector<2, 1, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Transpose<const Eigen::Matrix<long long int, -1, -1> >; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Dest = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; typename Dest::Scalar = long long int]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Lhs = Eigen::Transpose<const Eigen::Matrix<long long int, -1, -1> >; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = long long int]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Lhs = Eigen::Transpose<const Eigen::Matrix<long long int, -1, -1> >; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Derived = Eigen::internal::generic_product_impl<Eigen::Transpose<const Eigen::Matrix<long long int, -1, -1> >, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = long long int]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Lhs = Eigen::Transpose<const Eigen::Matrix<long long int, -1, -1> >; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Derived = Eigen::internal::generic_product_impl<Eigen::Transpose<const Eigen::Matrix<long long int, -1, -1> >, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Lhs = Eigen::Transpose<const Eigen::Matrix<long long int, -1, -1> >; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; int Options = 0; Scalar = long long int; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Transpose<const Eigen::Matrix<long long int, -1, -1> >, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::Product<Eigen::Transpose<const Eigen::Matrix<long long int, -1, -1> >, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Func = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Transpose<const Eigen::Matrix<long long int, -1, -1> >, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Derived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Transpose<const Eigen::Matrix<long long int, -1, -1> >, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; OtherDerived = Eigen::Product<Eigen::Transpose<const Eigen::Matrix<long long int, -1, -1> >, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Derived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Transpose<const Eigen::Matrix<long long int, -1, -1> >, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; _Scalar = long long int; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::Product<Eigen::Transpose<const Eigen::Matrix<long long int, -1, -1> >, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Func = Eigen::internal::assign_op<long long int, long long int>; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::Product<Eigen::Transpose<const Eigen::Matrix<long long int, -1, -1> >, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Transpose<const Eigen::Matrix<long long int, -1, -1> >, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Derived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Transpose<const Eigen::Matrix<long long int, -1, -1> >, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; _Scalar = long long int; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\binary_library.cpp:518:29:   required from here
..\Eigen/src/Core/products/GeneralMatrixVector.h:460:39: warning: enum constant in boolean context [-Wint-in-bool-context]
   const Index offset1 = (FirstAligned && alignmentStep==1)?3:1;
                         ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/products/GeneralMatrixVector.h:461:39: warning: enum constant in boolean context [-Wint-in-bool-context]
   const Index offset3 = (FirstAligned && alignmentStep==1)?1:3;
                         ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/products/GeneralMatrixVector.h: In instantiation of 'static void Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 1, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::run(Index, Index, const LhsMapper&, const RhsMapper&, Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 1, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::ResScalar*, Index, Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 1, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::ResScalar) [with Index = long long int; LhsScalar = std::complex<float>; LhsMapper = Eigen::internal::const_blas_data_mapper<std::complex<float>, long long int, 1>; bool ConjugateLhs = false; RhsScalar = std::complex<float>; RhsMapper = Eigen::internal::const_blas_data_mapper<std::complex<float>, long long int, 0>; bool ConjugateRhs = true; int Version = 0; Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 1, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::ResScalar = std::complex<float>]':
..\Eigen/src/Core/GeneralProduct.h:334:132:   required from 'static void Eigen::internal::gemv_dense_selector<2, 1, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false> >; Rhs = Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > > >; Dest = Eigen::Transpose<Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> > >; typename Dest::Scalar = std::complex<float>]'
..\Eigen/src/Core/GeneralProduct.h:192:12:   required from 'static void Eigen::internal::gemv_dense_selector<1, StorageOrder, BlasCompatible>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Dest = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; int StorageOrder = 0; bool BlasCompatible = true; typename Dest::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > >, Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > >, Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > >, Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > >, Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/NoAlias.h:42:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > >, Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 0>; ExpressionType = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:126:19:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheLeft(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false>; Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Householder/HouseholderSequence.h:258:13:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::evalTo(Dest&, Workspace&) const [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Workspace = Eigen::Matrix<std::complex<float>, 1, -1>; VectorsType = Eigen::Matrix<std::complex<float>, -1, -1>; CoeffsType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; int Side = 1]'
..\Eigen/src/SVD/JacobiSVD.h:233:30:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/products/GeneralMatrixVector.h:460:39: warning: enum constant in boolean context [-Wint-in-bool-context]
   const Index offset1 = (FirstAligned && alignmentStep==1)?3:1;
                         ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/products/GeneralMatrixVector.h:461:39: warning: enum constant in boolean context [-Wint-in-bool-context]
   const Index offset3 = (FirstAligned && alignmentStep==1)?1:3;
                         ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from ..\Eigen/Core:420:0,
                 from ..\binary_library.cpp:18:
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false>, 1, -1, false> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false>, 1, -1, false> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false>, 1, -1, false>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false>, 1, -1, false>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false>, 1, -1, false>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false>, 1, -1, false>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false>, 1, -1, false>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> >; Derived = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false>, 1, -1, false>]'
..\Eigen/src/Core/CwiseNullaryOp.h:327:20:   required from 'Derived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false>, 1, -1, false>; Eigen::DenseBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/CwiseNullaryOp.h:501:21:   required from 'Derived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false>, 1, -1, false>]'
..\Eigen/src/Householder/Householder.h:84:5:   required from 'void Eigen::MatrixBase<Derived>::makeHouseholder(EssentialPart&, Eigen::MatrixBase<Derived>::Scalar&, Eigen::MatrixBase<Derived>::RealScalar&) const [with EssentialPart = Eigen::VectorBlock<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false>, -1>; Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = std::complex<float>; Eigen::MatrixBase<Derived>::RealScalar = float]'
..\Eigen/src/Householder/Householder.h:45:18:   required from 'void Eigen::MatrixBase<Derived>::makeHouseholderInPlace(Eigen::MatrixBase<Derived>::Scalar&, Eigen::MatrixBase<Derived>::RealScalar&) [with Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = std::complex<float>; Eigen::MatrixBase<Derived>::RealScalar = float]'
..\Eigen/src/QR/CompleteOrthogonalDecomposition.h:447:7:   required from 'void Eigen::CompleteOrthogonalDecomposition<MatrixType>::computeInPlace() [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/QR/CompleteOrthogonalDecomposition.h:187:19:   required from 'Eigen::CompleteOrthogonalDecomposition<MatrixType>& Eigen::CompleteOrthogonalDecomposition<MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/QR/CompleteOrthogonalDecomposition.h:118:12:   required from 'Eigen::CompleteOrthogonalDecomposition<MatrixType>::CompleteOrthogonalDecomposition(const Eigen::EigenBase<OtherDerived>&) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/QR/CompleteOrthogonalDecomposition.h:557:10:   required from 'const Eigen::CompleteOrthogonalDecomposition<typename Eigen::DenseBase<Derived>::PlainObject> Eigen::MatrixBase<Derived>::completeOrthogonalDecomposition() const [with Derived = Eigen::Matrix<std::complex<float>, -1, -1>; typename Eigen::DenseBase<Derived>::PlainObject = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:943:87:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Diagonal<Eigen::Matrix<std::complex<float>, -1, -1>, 0> >, Eigen::internal::evaluator<Eigen::Diagonal<Eigen::Matrix<std::complex<float>, -1, -1>, 0> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Diagonal<Eigen::Matrix<std::complex<float>, -1, -1>, 0> >, Eigen::internal::evaluator<Eigen::Diagonal<Eigen::Matrix<std::complex<float>, -1, -1>, 0> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Diagonal<Eigen::Matrix<std::complex<float>, -1, -1>, 0>; SrcXprType = Eigen::Diagonal<Eigen::Matrix<std::complex<float>, -1, -1>, 0>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Diagonal<Eigen::Matrix<std::complex<float>, -1, -1>, 0>; SrcXprType = Eigen::Diagonal<Eigen::Matrix<std::complex<float>, -1, -1>, 0>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Diagonal<Eigen::Matrix<std::complex<float>, -1, -1>, 0>; Src = Eigen::Diagonal<Eigen::Matrix<std::complex<float>, -1, -1>, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Diagonal<Eigen::Matrix<std::complex<float>, -1, -1>, 0>; Src = Eigen::Diagonal<Eigen::Matrix<std::complex<float>, -1, -1>, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Diagonal<Eigen::Matrix<std::complex<float>, -1, -1>, 0>; Src = Eigen::Diagonal<Eigen::Matrix<std::complex<float>, -1, -1>, 0>]'
..\Eigen/src/Core/Assign.h:57:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::MatrixBase<Derived>&) [with Derived = Eigen::Diagonal<Eigen::Matrix<std::complex<float>, -1, -1>, 0>]'
..\Eigen/src/Core/Diagonal.h:75:5:   required from 'Eigen::Diagonal<MatrixType, Index>& Eigen::Diagonal<MatrixType, Index>::operator=(const Eigen::Diagonal<MatrixType, Index>&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int _DiagIndex = 0]'
..\Eigen/src/Core/DiagonalMatrix.h:329:20:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Diagonal2Dense>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<typename DstXprType::Scalar, typename SrcXprType::Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::DiagonalWrapper<const Eigen::Diagonal<Eigen::Matrix<std::complex<float>, -1, -1>, 0> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename SrcXprType::Scalar = std::complex<float>; typename DstXprType::Scalar = std::complex<float>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::DiagonalWrapper<const Eigen::Diagonal<Eigen::Matrix<std::complex<float>, -1, -1>, 0> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::DiagonalWrapper<const Eigen::Diagonal<Eigen::Matrix<std::complex<float>, -1, -1>, 0> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::DiagonalWrapper<const Eigen::Diagonal<Eigen::Matrix<std::complex<float>, -1, -1>, 0> >]'
..\Eigen/src/Core/Assign.h:75:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::DiagonalWrapper<const Eigen::Diagonal<Eigen::Matrix<std::complex<float>, -1, -1>, 0> >; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:571:22:   required from 'Derived& Eigen::PlainObjectBase<Derived>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::DiagonalWrapper<const Eigen::Diagonal<Eigen::Matrix<std::complex<float>, -1, -1>, 0> >; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:238:29:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::DiagonalWrapper<const Eigen::Diagonal<Eigen::Matrix<std::complex<float>, -1, -1>, 0> >; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:998:43:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 1> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 1> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; SrcXprType = Eigen::Product<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 1>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; SrcXprType = Eigen::Product<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 1>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; Src = Eigen::Product<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 1>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/ProductEvaluators.h:397:29:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 3>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; Lhs = Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:431:26:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; Lhs = Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; Lhs = Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; Src = Eigen::Product<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 0>; Derived = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 0>; OtherDerived = Eigen::Product<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 0>; Derived = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 0>; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 1; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Product<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Product<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 0>; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 0>; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:1006:32:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, -1>, 1> >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, -1>, 1> >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, -1>, 1>; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, -1>, 1>; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, -1>, 1>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/ProductEvaluators.h:397:29:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 3>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:431:26:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Matrix<double, -1, -1>; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, -1>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, -1>, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, -1>, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, -1>, 0>; OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, -1>, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, -1>, 0>; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, -1>, 0>; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, -1>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, -1>, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, -1>, 0>; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:1056:53:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Derived = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>]'
..\Eigen/src/Core/CwiseNullaryOp.h:327:20:   required from 'Derived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>; Eigen::DenseBase<Derived>::Scalar = double]'
..\Eigen/src/Core/CwiseNullaryOp.h:501:21:   required from 'Derived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>]'
..\Eigen/src/Householder/Householder.h:84:5:   required from 'void Eigen::MatrixBase<Derived>::makeHouseholder(EssentialPart&, Eigen::MatrixBase<Derived>::Scalar&, Eigen::MatrixBase<Derived>::RealScalar&) const [with EssentialPart = Eigen::VectorBlock<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, -1>; Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Eigen::MatrixBase<Derived>::Scalar = double; Eigen::MatrixBase<Derived>::RealScalar = double]'
..\Eigen/src/Householder/Householder.h:45:18:   required from 'void Eigen::MatrixBase<Derived>::makeHouseholderInPlace(Eigen::MatrixBase<Derived>::Scalar&, Eigen::MatrixBase<Derived>::RealScalar&) [with Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Eigen::MatrixBase<Derived>::Scalar = double; Eigen::MatrixBase<Derived>::RealScalar = double]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:305:5:   required from 'static void Eigen::HessenbergDecomposition<_MatrixType>::_compute(Eigen::HessenbergDecomposition<_MatrixType>::MatrixType&, Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType&, Eigen::HessenbergDecomposition<_MatrixType>::VectorType&) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType = Eigen::Matrix<double, -1, 1>; typename _MatrixType::Scalar = double; Eigen::HessenbergDecomposition<_MatrixType>::VectorType = Eigen::Matrix<double, 1, -1>]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:161:15:   required from 'Eigen::HessenbergDecomposition<_MatrixType>& Eigen::HessenbergDecomposition<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&) [with InputType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:271:3:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
In file included from ..\Eigen/Core:473:0,
                 from ..\binary_library.cpp:18:
..\Eigen/src/Core/products/GeneralMatrixVector.h: In instantiation of 'static void Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 1, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::run(Index, Index, const LhsMapper&, const RhsMapper&, Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 1, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::ResScalar*, Index, Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 1, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::ResScalar) [with Index = long long int; LhsScalar = double; LhsMapper = Eigen::internal::const_blas_data_mapper<double, long long int, 1>; bool ConjugateLhs = false; RhsScalar = double; RhsMapper = Eigen::internal::const_blas_data_mapper<double, long long int, 0>; bool ConjugateRhs = false; int Version = 0; Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 1, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::ResScalar = double]':
..\Eigen/src/Core/GeneralProduct.h:334:132:   required from 'static void Eigen::internal::gemv_dense_selector<2, 1, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false> >; Rhs = Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> > >; Dest = Eigen::Transpose<Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> > >; typename Dest::Scalar = double]'
..\Eigen/src/Core/GeneralProduct.h:192:12:   required from 'static void Eigen::internal::gemv_dense_selector<1, StorageOrder, BlasCompatible>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>; Dest = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; int StorageOrder = 0; bool BlasCompatible = true; typename Dest::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/NoAlias.h:42:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>, 0>; ExpressionType = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:126:19:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheLeft(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::VectorBlock<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1>; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = double]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:313:5:   required from 'static void Eigen::HessenbergDecomposition<_MatrixType>::_compute(Eigen::HessenbergDecomposition<_MatrixType>::MatrixType&, Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType&, Eigen::HessenbergDecomposition<_MatrixType>::VectorType&) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType = Eigen::Matrix<double, -1, 1>; typename _MatrixType::Scalar = double; Eigen::HessenbergDecomposition<_MatrixType>::VectorType = Eigen::Matrix<double, 1, -1>]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:161:15:   required from 'Eigen::HessenbergDecomposition<_MatrixType>& Eigen::HessenbergDecomposition<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&) [with InputType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:271:3:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/products/GeneralMatrixVector.h:460:39: warning: enum constant in boolean context [-Wint-in-bool-context]
   const Index offset1 = (FirstAligned && alignmentStep==1)?3:1;
                         ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/products/GeneralMatrixVector.h:461:39: warning: enum constant in boolean context [-Wint-in-bool-context]
   const Index offset3 = (FirstAligned && alignmentStep==1)?1:3;
                         ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from ..\Eigen/Core:420:0,
                 from ..\binary_library.cpp:18:
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::TriangularView<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::TriangularView<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/TriangularMatrix.h:736:7:   required from 'class Eigen::internal::triangular_dense_assignment_kernel<1, 0, 0, Eigen::internal::evaluator<Eigen::TriangularView<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/TriangularMatrix.h:799:10:   required from 'void Eigen::internal::call_triangular_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with int Mode = 1; bool SetOpposite = false; DstXprType = Eigen::TriangularView<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/TriangularMatrix.h:847:61:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Triangular>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::TriangularView<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::TriangularView<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/TriangularMatrix.h:560:37:   required from 'Eigen::TriangularView<MatrixType, _Mode>& Eigen::TriangularViewImpl<_MatrixType, _Mode, Eigen::Dense>::operator=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; _MatrixType = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>; unsigned int _Mode = 1]'
..\Eigen/src/Core/TriangularMatrix.h:394:20:   required from 'Eigen::TriangularViewImpl<_MatrixType, _Mode, Eigen::Dense>::TriangularViewType& Eigen::TriangularViewImpl<_MatrixType, _Mode, Eigen::Dense>::setConstant(const Scalar&) [with _MatrixType = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>; unsigned int _Mode = 1; Eigen::TriangularViewImpl<_MatrixType, _Mode, Eigen::Dense>::TriangularViewType = Eigen::TriangularView<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1>; Eigen::TriangularViewImpl<_MatrixType, _Mode, Eigen::Dense>::Scalar = double]'
..\Eigen/src/Core/TriangularMatrix.h:397:55:   required from 'Eigen::TriangularViewImpl<_MatrixType, _Mode, Eigen::Dense>::TriangularViewType& Eigen::TriangularViewImpl<_MatrixType, _Mode, Eigen::Dense>::setZero() [with _MatrixType = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>; unsigned int _Mode = 1; Eigen::TriangularViewImpl<_MatrixType, _Mode, Eigen::Dense>::TriangularViewType = Eigen::TriangularView<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1>]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:360:9:   required from 'void Eigen::internal::HessenbergDecompositionMatrixHReturnType<MatrixType>::evalTo(ResultType&) const [with ResultType = Eigen::Matrix<double, -1, -1>; MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/ReturnByValue.h:62:7:   required from 'void Eigen::ReturnByValue<Derived>::evalTo(Dest&) const [with Dest = Eigen::Matrix<double, -1, -1>; Derived = Eigen::internal::HessenbergDecompositionMatrixHReturnType<Eigen::Matrix<double, -1, -1> >]'
..\Eigen/src/Core/Assign.h:84:3:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::ReturnByValue<OtherDerived>&) [with OtherDerived = Eigen::internal::HessenbergDecompositionMatrixHReturnType<Eigen::Matrix<double, -1, -1> >; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:476:29:   required from 'Derived& Eigen::PlainObjectBase<Derived>::operator=(const Eigen::ReturnByValue<OtherDerived>&) [with OtherDerived = Eigen::internal::HessenbergDecompositionMatrixHReturnType<Eigen::Matrix<double, -1, -1> >; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:245:29:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::ReturnByValue<OtherDerived>&) [with OtherDerived = Eigen::internal::HessenbergDecompositionMatrixHReturnType<Eigen::Matrix<double, -1, -1> >; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Eigenvalues/RealSchur.h:286:10:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::computeFromHessenberg(const HessMatrixType&, const OrthMatrixType&, bool) [with HessMatrixType = Eigen::internal::HessenbergDecompositionMatrixHReturnType<Eigen::Matrix<double, -1, -1> >; OrthMatrixType = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:274:24:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, 2, 1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 2, 1> > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, 2, 1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 2, 1> > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, 2, 1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 2, 1> >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, 2, 1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 2, 1> >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, 2, 1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 2, 1> >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<double, 2, 1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 2, 1> >; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, 2, 1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 2, 1> >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 2, 1> >; Derived = Eigen::Matrix<double, 2, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 2, 1> >; _Scalar = double; int _Rows = 2; int _Cols = 1; int _Options = 0; int _MaxRows = 2; int _MaxCols = 1]'
..\Eigen/src/Core/CwiseNullaryOp.h:327:20:   required from 'Derived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Matrix<double, 2, 1>; Eigen::DenseBase<Derived>::Scalar = double]'
..\Eigen/src/Core/CwiseNullaryOp.h:501:21:   required from 'Derived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Matrix<double, 2, 1>]'
..\Eigen/src/Householder/Householder.h:84:5:   required from 'void Eigen::MatrixBase<Derived>::makeHouseholder(EssentialPart&, Eigen::MatrixBase<Derived>::Scalar&, Eigen::MatrixBase<Derived>::RealScalar&) const [with EssentialPart = Eigen::Matrix<double, 2, 1>; Derived = Eigen::Matrix<double, 3, 1>; Eigen::MatrixBase<Derived>::Scalar = double; Eigen::MatrixBase<Derived>::RealScalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:504:5:   required from 'void Eigen::RealSchur<_MatrixType>::performFrancisQRStep(Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, bool, const Vector3s&, Eigen::RealSchur<_MatrixType>::Scalar*) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::RealSchur<_MatrixType>::Index = long long int; Eigen::RealSchur<_MatrixType>::Vector3s = Eigen::Matrix<double, 3, 1>; typename MatrixType::Scalar = double; Eigen::RealSchur<_MatrixType>::Scalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:337:29:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::computeFromHessenberg(const HessMatrixType&, const OrthMatrixType&, bool) [with HessMatrixType = Eigen::internal::HessenbergDecompositionMatrixHReturnType<Eigen::Matrix<double, -1, -1> >; OrthMatrixType = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:274:24:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, 1, 1, 0, 1, 1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 1, 1, 0, 1, 1> > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, 1, 1, 0, 1, 1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 1, 1, 0, 1, 1> > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, 1, 1, 0, 1, 1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 1, 1, 0, 1, 1> >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, 1, 1, 0, 1, 1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 1, 1, 0, 1, 1> >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, 1, 1, 0, 1, 1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 1, 1, 0, 1, 1> >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<double, 1, 1, 0, 1, 1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 1, 1, 0, 1, 1> >; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, 1, 1, 0, 1, 1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 1, 1, 0, 1, 1> >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 1, 1, 0, 1, 1> >; Derived = Eigen::Matrix<double, 1, 1, 0, 1, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 1, 1, 0, 1, 1> >; _Scalar = double; int _Rows = 1; int _Cols = 1; int _Options = 0; int _MaxRows = 1; int _MaxCols = 1]'
..\Eigen/src/Core/CwiseNullaryOp.h:327:20:   required from 'Derived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Matrix<double, 1, 1, 0, 1, 1>; Eigen::DenseBase<Derived>::Scalar = double]'
..\Eigen/src/Core/CwiseNullaryOp.h:501:21:   required from 'Derived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Matrix<double, 1, 1, 0, 1, 1>]'
..\Eigen/src/Householder/Householder.h:84:5:   required from 'void Eigen::MatrixBase<Derived>::makeHouseholder(EssentialPart&, Eigen::MatrixBase<Derived>::Scalar&, Eigen::MatrixBase<Derived>::RealScalar&) const [with EssentialPart = Eigen::Matrix<double, 1, 1, 0, 1, 1>; Derived = Eigen::Matrix<double, 2, 1>; Eigen::MatrixBase<Derived>::Scalar = double; Eigen::MatrixBase<Derived>::RealScalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:524:3:   required from 'void Eigen::RealSchur<_MatrixType>::performFrancisQRStep(Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, bool, const Vector3s&, Eigen::RealSchur<_MatrixType>::Scalar*) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::RealSchur<_MatrixType>::Index = long long int; Eigen::RealSchur<_MatrixType>::Vector3s = Eigen::Matrix<double, 3, 1>; typename MatrixType::Scalar = double; Eigen::RealSchur<_MatrixType>::Scalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:337:29:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::computeFromHessenberg(const HessMatrixType&, const OrthMatrixType&, bool) [with HessMatrixType = Eigen::internal::HessenbergDecompositionMatrixHReturnType<Eigen::Matrix<double, -1, -1> >; OrthMatrixType = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:274:24:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> > > >, Eigen::internal::add_assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> > > >, Eigen::internal::add_assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> > >; Functor = Eigen::internal::add_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> > >; Functor = Eigen::internal::add_assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> > >; Func = Eigen::internal::add_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<double, -1, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> > >; Func = Eigen::internal::add_assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/CwiseBinaryOp.h:177:18:   required from 'Derived& Eigen::MatrixBase<Derived>::operator+=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> > >; Derived = Eigen::Matrix<double, -1, 1>]'
..\Eigen/src/Core/GeneralProduct.h:282:25:   required from 'static void Eigen::internal::gemv_dense_selector<2, 0, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Dest = Eigen::Matrix<double, -1, 1>; typename Dest::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<double, -1, 1>; Lhs = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Matrix<double, -1, 1>; Lhs = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, 1>; Lhs = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<double, -1, 1>; Lhs = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, 1>; Src = Eigen::Product<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/NoAlias.h:42:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, 0>; ExpressionType = Eigen::Matrix<double, -1, 1>; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Eigenvalues/EigenSolver.h:615:21:   required from 'void Eigen::EigenSolver<_MatrixType>::doComputeEigenvectors() [with _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:447:28:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
In file included from ..\Eigen/Core:473:0,
                 from ..\binary_library.cpp:18:
..\Eigen/src/Core/products/GeneralMatrixVector.h: In instantiation of 'static void Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 1, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::run(Index, Index, const LhsMapper&, const RhsMapper&, Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 1, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::ResScalar*, Index, Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 1, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::ResScalar) [with Index = long long int; LhsScalar = std::complex<long long int>; LhsMapper = Eigen::internal::const_blas_data_mapper<std::complex<long long int>, long long int, 1>; bool ConjugateLhs = false; RhsScalar = std::complex<long long int>; RhsMapper = Eigen::internal::const_blas_data_mapper<std::complex<long long int>, long long int, 0>; bool ConjugateRhs = true; int Version = 0; Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 1, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::ResScalar = std::complex<long long int>]':
..\Eigen/src/Core/GeneralProduct.h:334:132:   required from 'static void Eigen::internal::gemv_dense_selector<2, 1, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> >; Rhs = Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > > >; Dest = Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, 1, -1> >; typename Dest::Scalar = std::complex<long long int>]'
..\Eigen/src/Core/GeneralProduct.h:192:12:   required from 'static void Eigen::internal::gemv_dense_selector<1, StorageOrder, BlasCompatible>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >; Rhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Dest = Eigen::Matrix<std::complex<long long int>, 1, -1>; int StorageOrder = 0; bool BlasCompatible = true; typename Dest::Scalar = std::complex<long long int>]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<std::complex<long long int>, 1, -1>; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >; Rhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = std::complex<long long int>]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Matrix<std::complex<long long int>, 1, -1>; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >; Rhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Derived = Eigen::internal::generic_product_impl<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = std::complex<long long int>]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<long long int>, 1, -1>; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >; Rhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Derived = Eigen::internal::generic_product_impl<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, 1, -1>; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >; Rhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; int Options = 0; Scalar = std::complex<long long int>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, 1, -1>; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, 1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, 1, -1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; _Scalar = std::complex<long long int>; int _Rows = 1; int _Cols = -1; int _Options = 1; int _MaxRows = 1; int _MaxCols = -1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, 1, -1>; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<long long int>, 1, -1>; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, 1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; _Scalar = std::complex<long long int>; int _Rows = 1; int _Cols = -1; int _Options = 1; int _MaxRows = 1; int _MaxCols = -1]'
..\binary_library.cpp:436:23:   required from here
..\Eigen/src/Core/products/GeneralMatrixVector.h:460:39: warning: enum constant in boolean context [-Wint-in-bool-context]
   const Index offset1 = (FirstAligned && alignmentStep==1)?3:1;
                         ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/products/GeneralMatrixVector.h:461:39: warning: enum constant in boolean context [-Wint-in-bool-context]
   const Index offset3 = (FirstAligned && alignmentStep==1)?1:3;
                         ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from ..\Eigen/Core:420:0,
                 from ..\binary_library.cpp:18:
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Derived = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>]'
..\Eigen/src/Core/CwiseNullaryOp.h:327:20:   required from 'Derived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>; Eigen::DenseBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/CwiseNullaryOp.h:501:21:   required from 'Derived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>, -1, 1, false>]'
..\Eigen/src/Householder/Householder.h:84:5:   required from 'void Eigen::MatrixBase<Derived>::makeHouseholder(EssentialPart&, Eigen::MatrixBase<Derived>::Scalar&, Eigen::MatrixBase<Derived>::RealScalar&) const [with EssentialPart = Eigen::VectorBlock<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>, -1>; Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>; Eigen::MatrixBase<Derived>::Scalar = std::complex<float>; Eigen::MatrixBase<Derived>::RealScalar = float]'
..\Eigen/src/Householder/Householder.h:45:18:   required from 'void Eigen::MatrixBase<Derived>::makeHouseholderInPlace(Eigen::MatrixBase<Derived>::Scalar&, Eigen::MatrixBase<Derived>::RealScalar&) [with Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false>; Eigen::MatrixBase<Derived>::Scalar = std::complex<float>; Eigen::MatrixBase<Derived>::RealScalar = float]'
..\Eigen/src/QR/ColPivHouseholderQR.h:538:5:   required from 'void Eigen::ColPivHouseholderQR<MatrixType>::computeInPlace() [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/QR/ColPivHouseholderQR.h:475:17:   required from 'Eigen::ColPivHouseholderQR<_MatrixType>& Eigen::ColPivHouseholderQR<MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:230:7:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
In file included from ..\Eigen/Core:473:0,
                 from ..\binary_library.cpp:18:
..\Eigen/src/Core/products/GeneralMatrixVector.h: In instantiation of 'static void Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 0, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::run(Index, Index, const LhsMapper&, const RhsMapper&, Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 0, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::ResScalar*, Index, RhsScalar) [with Index = long long int; LhsScalar = std::complex<float>; LhsMapper = Eigen::internal::const_blas_data_mapper<std::complex<float>, long long int, 0>; bool ConjugateLhs = false; RhsScalar = std::complex<float>; RhsMapper = Eigen::internal::const_blas_data_mapper<std::complex<float>, long long int, 1>; bool ConjugateRhs = false; int Version = 0; Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 0, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::ResScalar = std::complex<float>]':
..\Eigen/src/Core/GeneralProduct.h:239:134:   required from 'static void Eigen::internal::gemv_dense_selector<2, 0, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > >; Dest = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; typename Dest::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > >; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > >; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > >, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > >; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > >, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > >; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > >, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > >, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/NoAlias.h:42:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > >, 0>; ExpressionType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:163:19:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheRight(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> >; Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>; Eigen::MatrixBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:317:5:   required from 'static void Eigen::HessenbergDecomposition<_MatrixType>::_compute(Eigen::HessenbergDecomposition<_MatrixType>::MatrixType&, Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType&, Eigen::HessenbergDecomposition<_MatrixType>::VectorType&) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType = Eigen::Matrix<std::complex<float>, -1, 1>; typename _MatrixType::Scalar = std::complex<float>; Eigen::HessenbergDecomposition<_MatrixType>::VectorType = Eigen::Matrix<std::complex<float>, 1, -1>]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:161:15:   required from 'Eigen::HessenbergDecomposition<_MatrixType>& Eigen::HessenbergDecomposition<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Eigenvalues/ComplexSchur.h:358:5:   required from 'static void Eigen::internal::complex_schur_reduce_to_hessenberg<MatrixType, IsComplex>::run(Eigen::ComplexSchur<MatrixType>&, const MatrixType&, bool) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; bool IsComplex = true]'
..\Eigen/src/Eigenvalues/ComplexSchur.h:334:94:   required from 'Eigen::ComplexSchur<MatrixType>& Eigen::ComplexSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Eigenvalues/ComplexEigenSolver.h:270:3:   required from 'Eigen::ComplexEigenSolver<MatrixType>& Eigen::ComplexEigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Eigenvalues/ComplexEigenSolver.h:134:14:   required from 'Eigen::ComplexEigenSolver<_MatrixType>::ComplexEigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:954:54:   required from here
..\Eigen/src/Core/products/GeneralMatrixVector.h:186:39: warning: enum constant in boolean context [-Wint-in-bool-context]
   const Index offset1 = (FirstAligned && alignmentStep==1)?3:1;
                         ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/products/GeneralMatrixVector.h:187:39: warning: enum constant in boolean context [-Wint-in-bool-context]
   const Index offset3 = (FirstAligned && alignmentStep==1)?1:3;
                         ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from ..\Eigen/Core:420:0,
                 from ..\binary_library.cpp:18:
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/TriangularMatrix.h:736:7:   required from 'class Eigen::internal::triangular_dense_assignment_kernel<1, 0, 0, Eigen::internal::evaluator<Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/TriangularMatrix.h:799:10:   required from 'void Eigen::internal::call_triangular_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with int Mode = 1; bool SetOpposite = false; DstXprType = Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/TriangularMatrix.h:847:61:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Triangular>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/TriangularMatrix.h:560:37:   required from 'Eigen::TriangularView<MatrixType, _Mode>& Eigen::TriangularViewImpl<_MatrixType, _Mode, Eigen::Dense>::operator=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; _MatrixType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; unsigned int _Mode = 1]'
..\Eigen/src/Core/TriangularMatrix.h:394:20:   required from 'Eigen::TriangularViewImpl<_MatrixType, _Mode, Eigen::Dense>::TriangularViewType& Eigen::TriangularViewImpl<_MatrixType, _Mode, Eigen::Dense>::setConstant(const Scalar&) [with _MatrixType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; unsigned int _Mode = 1; Eigen::TriangularViewImpl<_MatrixType, _Mode, Eigen::Dense>::TriangularViewType = Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 1>; Eigen::TriangularViewImpl<_MatrixType, _Mode, Eigen::Dense>::Scalar = std::complex<float>]'
..\Eigen/src/Core/TriangularMatrix.h:397:55:   required from 'Eigen::TriangularViewImpl<_MatrixType, _Mode, Eigen::Dense>::TriangularViewType& Eigen::TriangularViewImpl<_MatrixType, _Mode, Eigen::Dense>::setZero() [with _MatrixType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; unsigned int _Mode = 1; Eigen::TriangularViewImpl<_MatrixType, _Mode, Eigen::Dense>::TriangularViewType = Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 1>]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:360:9:   required from 'void Eigen::internal::HessenbergDecompositionMatrixHReturnType<MatrixType>::evalTo(ResultType&) const [with ResultType = Eigen::Matrix<std::complex<float>, -1, -1>; MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/ReturnByValue.h:62:7:   required from 'void Eigen::ReturnByValue<Derived>::evalTo(Dest&) const [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Derived = Eigen::internal::HessenbergDecompositionMatrixHReturnType<Eigen::Matrix<std::complex<float>, -1, -1> >]'
..\Eigen/src/Core/Assign.h:84:3:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::ReturnByValue<OtherDerived>&) [with OtherDerived = Eigen::internal::HessenbergDecompositionMatrixHReturnType<Eigen::Matrix<std::complex<float>, -1, -1> >; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:476:29:   required from 'Derived& Eigen::PlainObjectBase<Derived>::operator=(const Eigen::ReturnByValue<OtherDerived>&) [with OtherDerived = Eigen::internal::HessenbergDecompositionMatrixHReturnType<Eigen::Matrix<std::complex<float>, -1, -1> >; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:245:29:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::ReturnByValue<OtherDerived>&) [with OtherDerived = Eigen::internal::HessenbergDecompositionMatrixHReturnType<Eigen::Matrix<std::complex<float>, -1, -1> >; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Eigenvalues/ComplexSchur.h:359:18:   required from 'static void Eigen::internal::complex_schur_reduce_to_hessenberg<MatrixType, IsComplex>::run(Eigen::ComplexSchur<MatrixType>&, const MatrixType&, bool) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; bool IsComplex = true]'
..\Eigen/src/Eigenvalues/ComplexSchur.h:334:94:   required from 'Eigen::ComplexSchur<MatrixType>& Eigen::ComplexSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Eigenvalues/ComplexEigenSolver.h:270:3:   required from 'Eigen::ComplexEigenSolver<MatrixType>& Eigen::ComplexEigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Eigenvalues/ComplexEigenSolver.h:134:14:   required from 'Eigen::ComplexEigenSolver<_MatrixType>::ComplexEigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:954:54:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, 1> >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, 1> >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, 1>; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, 1>; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, 1>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/ProductEvaluators.h:397:29:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 3>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Rhs = Eigen::Transpose<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:431:26:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Rhs = Eigen::Transpose<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >]'
..\Eigen/src/Core/ProductEvaluators.h:124:75:   required from 'Eigen::internal::product_evaluator<Eigen::Product<Lhs, Rhs, Option>, ProductTag, LhsShape, RhsShape>::product_evaluator(const XprType&) [with Lhs = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Rhs = Eigen::Transpose<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >; int Options = 0; int ProductTag = 8; LhsShape = Eigen::DenseShape; RhsShape = Eigen::DenseShape; typename Eigen::internal::traits<typename Eigen::Product<Lhs, Rhs, Option>::Rhs>::Scalar = double; typename Eigen::internal::traits<typename Eigen::Product<Lhs, Rhs, Option>::Lhs>::Scalar = double; Eigen::internal::product_evaluator<Eigen::Product<Lhs, Rhs, Option>, ProductTag, LhsShape, RhsShape>::XprType = Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, 0>]'
..\Eigen/src/Core/ProductEvaluators.h:35:70:   required from 'Eigen::internal::evaluator<Eigen::Product<Lhs, Rhs, Option> >::evaluator(const XprType&) [with Lhs = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Rhs = Eigen::Transpose<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >; int Options = 0; Eigen::internal::evaluator<Eigen::Product<Lhs, Rhs, Option> >::XprType = Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, 0>]'
..\Eigen/src/Core/CoreEvaluators.h:103:54:   required from 'Eigen::internal::evaluator<const T>::evaluator(const T&) [with T = Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, 0>]'
..\Eigen/src/Core/CoreEvaluators.h:702:26:   required from 'Eigen::internal::binary_evaluator<Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs>, Eigen::internal::IndexBased, Eigen::internal::IndexBased>::binary_evaluator(const XprType&) [with BinaryOp = Eigen::internal::scalar_quotient_op<double, double>; Lhs = const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, 0>; Rhs = const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> >; typename Eigen::internal::traits<typename Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs>::Rhs>::Scalar = double; typename Eigen::internal::traits<typename Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs>::Lhs>::Scalar = double; Eigen::internal::binary_evaluator<Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs>, Eigen::internal::IndexBased, Eigen::internal::IndexBased>::XprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >]'
..\Eigen/src/Core/CoreEvaluators.h:671:70:   required from 'Eigen::internal::evaluator<Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs> >::evaluator(const XprType&) [with BinaryOp = Eigen::internal::scalar_quotient_op<double, double>; Lhs = const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, 0>; Rhs = const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> >; Eigen::internal::evaluator<Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs> >::XprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >]'
..\Eigen/src/Core/AssignEvaluator.h:753:19:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:537:19:   required from 'Eigen::PlainObjectBase<Derived>::PlainObjectBase(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:379:29:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:147:40:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, 1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, 1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, 1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<double, -1, 1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, -1, 1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Derived = Eigen::Matrix<double, -1, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; _Scalar = double; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Core/CwiseNullaryOp.h:327:20:   required from 'Derived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Matrix<double, -1, 1>; Eigen::DenseBase<Derived>::Scalar = double]'
..\Eigen/src/Core/CwiseNullaryOp.h:501:21:   required from 'Derived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Matrix<double, -1, 1>]'
..\Eigen/src/Core/ProductEvaluators.h:349:5:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, 1>; Lhs = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<double, -1, 1>; Lhs = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, 1>; Src = Eigen::Product<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/NoAlias.h:42:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, 0>; ExpressionType = Eigen::Matrix<double, -1, 1>; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Eigenvalues/EigenSolver.h:615:21:   required from 'void Eigen::EigenSolver<_MatrixType>::doComputeEigenvectors() [with _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:447:28:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Matrix<double, -1, 1> >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Matrix<double, -1, 1> >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Matrix<double, -1, 1>; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Matrix<double, -1, 1>; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> >; Src = Eigen::Matrix<double, -1, 1>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> >; Src = Eigen::Matrix<double, -1, 1>; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> >; Src = Eigen::Matrix<double, -1, 1>]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, -1, 1>; Derived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/GeneralProduct.h:268:50:   required from 'static void Eigen::internal::gemv_dense_selector<2, 0, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Dest = Eigen::Matrix<double, -1, 1>; typename Dest::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<double, -1, 1>; Lhs = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Matrix<double, -1, 1>; Lhs = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, 1>; Lhs = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<double, -1, 1>; Lhs = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, 1>; Src = Eigen::Product<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/NoAlias.h:42:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, 0>; ExpressionType = Eigen::Matrix<double, -1, 1>; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Eigenvalues/EigenSolver.h:615:21:   required from 'void Eigen::EigenSolver<_MatrixType>::doComputeEigenvectors() [with _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:447:28:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 1> >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 1> >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 1>; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 1>; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 1>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/ProductEvaluators.h:397:29:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 3>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:431:26:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/EigenBase.h:104:9:   required from 'void Eigen::EigenBase<Derived>::applyThisOnTheRight(Dest&) const [with Dest = Eigen::Matrix<double, -1, -1>; Derived = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>]'
..\Eigen/src/Core/MatrixBase.h:500:3:   required from 'Derived& Eigen::MatrixBase<Derived>::operator*=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:179:42:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >, 1> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >, 1> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >, 1>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >, 1>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >, 1>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/ProductEvaluators.h:397:29:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 3>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Lhs = Eigen::Matrix<std::complex<float>, -1, -1>; Rhs = Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:431:26:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Lhs = Eigen::Matrix<std::complex<float>, -1, -1>; Rhs = Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >]'
..\Eigen/src/Core/ProductEvaluators.h:124:75:   required from 'Eigen::internal::product_evaluator<Eigen::Product<Lhs, Rhs, Option>, ProductTag, LhsShape, RhsShape>::product_evaluator(const XprType&) [with Lhs = Eigen::Matrix<std::complex<float>, -1, -1>; Rhs = Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >; int Options = 0; int ProductTag = 8; LhsShape = Eigen::DenseShape; RhsShape = Eigen::DenseShape; typename Eigen::internal::traits<typename Eigen::Product<Lhs, Rhs, Option>::Rhs>::Scalar = std::complex<float>; typename Eigen::internal::traits<typename Eigen::Product<Lhs, Rhs, Option>::Lhs>::Scalar = std::complex<float>; Eigen::internal::product_evaluator<Eigen::Product<Lhs, Rhs, Option>, ProductTag, LhsShape, RhsShape>::XprType = Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >, 0>]'
..\Eigen/src/Core/ProductEvaluators.h:35:70:   required from 'Eigen::internal::evaluator<Eigen::Product<Lhs, Rhs, Option> >::evaluator(const XprType&) [with Lhs = Eigen::Matrix<std::complex<float>, -1, -1>; Rhs = Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >; int Options = 0; Eigen::internal::evaluator<Eigen::Product<Lhs, Rhs, Option> >::XprType = Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >, 0>]'
..\Eigen/src/Core/CoreEvaluators.h:103:54:   required from 'Eigen::internal::evaluator<const T>::evaluator(const T&) [with T = Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >, 0>]'
..\Eigen/src/Core/CoreEvaluators.h:702:26:   required from 'Eigen::internal::binary_evaluator<Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs>, Eigen::internal::IndexBased, Eigen::internal::IndexBased>::binary_evaluator(const XprType&) [with BinaryOp = Eigen::internal::scalar_quotient_op<std::complex<float>, float>; Lhs = const Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >, 0>; Rhs = const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, const Eigen::Matrix<float, -1, -1> >; typename Eigen::internal::traits<typename Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs>::Rhs>::Scalar = float; typename Eigen::internal::traits<typename Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs>::Lhs>::Scalar = std::complex<float>; Eigen::internal::binary_evaluator<Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs>, Eigen::internal::IndexBased, Eigen::internal::IndexBased>::XprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, float>, const Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, const Eigen::Matrix<float, -1, -1> > >]'
..\Eigen/src/Core/CoreEvaluators.h:671:70:   required from 'Eigen::internal::evaluator<Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs> >::evaluator(const XprType&) [with BinaryOp = Eigen::internal::scalar_quotient_op<std::complex<float>, float>; Lhs = const Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >, 0>; Rhs = const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, const Eigen::Matrix<float, -1, -1> >; Eigen::internal::evaluator<Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs> >::XprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, float>, const Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, const Eigen::Matrix<float, -1, -1> > >]'
..\Eigen/src/Core/AssignEvaluator.h:753:19:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, float>, const Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, const Eigen::Matrix<float, -1, -1> > >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, float>, const Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, const Eigen::Matrix<float, -1, -1> > >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, float>, const Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, const Eigen::Matrix<float, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, float>, const Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, const Eigen::Matrix<float, -1, -1> > >; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:537:19:   required from 'Eigen::PlainObjectBase<Derived>::PlainObjectBase(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, float>, const Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, const Eigen::Matrix<float, -1, -1> > >; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:379:29:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<float>, float>, const Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<float>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<float>, const Eigen::Matrix<float, -1, -1> > >; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:315:43:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, 1> >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, 1> >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, 1>; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, 1>; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, 1>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/ProductEvaluators.h:397:29:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 3>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:431:26:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >]'
..\Eigen/src/Core/ProductEvaluators.h:124:75:   required from 'Eigen::internal::product_evaluator<Eigen::Product<Lhs, Rhs, Option>, ProductTag, LhsShape, RhsShape>::product_evaluator(const XprType&) [with Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >; int Options = 0; int ProductTag = 8; LhsShape = Eigen::DenseShape; RhsShape = Eigen::DenseShape; typename Eigen::internal::traits<typename Eigen::Product<Lhs, Rhs, Option>::Rhs>::Scalar = std::complex<long long int>; typename Eigen::internal::traits<typename Eigen::Product<Lhs, Rhs, Option>::Lhs>::Scalar = std::complex<long long int>; Eigen::internal::product_evaluator<Eigen::Product<Lhs, Rhs, Option>, ProductTag, LhsShape, RhsShape>::XprType = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, 0>]'
..\Eigen/src/Core/ProductEvaluators.h:35:70:   required from 'Eigen::internal::evaluator<Eigen::Product<Lhs, Rhs, Option> >::evaluator(const XprType&) [with Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >; int Options = 0; Eigen::internal::evaluator<Eigen::Product<Lhs, Rhs, Option> >::XprType = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, 0>]'
..\Eigen/src/Core/CoreEvaluators.h:103:54:   required from 'Eigen::internal::evaluator<const T>::evaluator(const T&) [with T = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, 0>]'
..\Eigen/src/Core/CoreEvaluators.h:702:26:   required from 'Eigen::internal::binary_evaluator<Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs>, Eigen::internal::IndexBased, Eigen::internal::IndexBased>::binary_evaluator(const XprType&) [with BinaryOp = Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>; Lhs = const Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, 0>; Rhs = const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> >; typename Eigen::internal::traits<typename Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs>::Rhs>::Scalar = long long int; typename Eigen::internal::traits<typename Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs>::Lhs>::Scalar = std::complex<long long int>; Eigen::internal::binary_evaluator<Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs>, Eigen::internal::IndexBased, Eigen::internal::IndexBased>::XprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> > >]'
..\Eigen/src/Core/CoreEvaluators.h:671:70:   required from 'Eigen::internal::evaluator<Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs> >::evaluator(const XprType&) [with BinaryOp = Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>; Lhs = const Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, 0>; Rhs = const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> >; Eigen::internal::evaluator<Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs> >::XprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> > >]'
..\Eigen/src/Core/AssignEvaluator.h:753:19:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> > >; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> > >; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> > >; Derived = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:537:19:   required from 'Eigen::PlainObjectBase<Derived>::PlainObjectBase(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> > >; Derived = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:379:29:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, -1> > >; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:414:47:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, -1>, 1> >, Eigen::internal::assign_op<long long int, long long int> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, -1>, 1> >, Eigen::internal::assign_op<long long int, long long int>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<long long int, -1, -1>; SrcXprType = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, -1>, 1>; Functor = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<long long int, -1, -1>; SrcXprType = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, -1>, 1>; Functor = Eigen::internal::assign_op<long long int, long long int>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<long long int, -1, -1>; Src = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, -1>, 1>; Func = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/ProductEvaluators.h:397:29:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 3>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<long long int, -1, -1>; Lhs = Eigen::Matrix<long long int, -1, -1>; Rhs = Eigen::Matrix<long long int, -1, -1>]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:431:26:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<long long int, -1, -1>; Lhs = Eigen::Matrix<long long int, -1, -1>; Rhs = Eigen::Matrix<long long int, -1, -1>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<long long int, -1, -1>; Lhs = Eigen::Matrix<long long int, -1, -1>; Rhs = Eigen::Matrix<long long int, -1, -1>; int Options = 0; Scalar = long long int; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, -1>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<long long int, -1, -1>; Src = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, -1>, 0>; Func = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, -1>, 0>; Derived = Eigen::Matrix<long long int, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, -1>, 0>; OtherDerived = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, -1>, 0>; Derived = Eigen::Matrix<long long int, -1, -1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, -1>, 0>; _Scalar = long long int; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<long long int, -1, -1>; Src = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, -1>, 0>; Func = Eigen::internal::assign_op<long long int, long long int>; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<long long int, -1, -1>; Src = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, -1>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, -1>, 0>; Derived = Eigen::Matrix<long long int, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, -1>, 0>; _Scalar = long long int; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/EigenBase.h:104:9:   required from 'void Eigen::EigenBase<Derived>::applyThisOnTheRight(Dest&) const [with Dest = Eigen::Matrix<long long int, -1, -1>; Derived = Eigen::Matrix<long long int, -1, -1>]'
..\Eigen/src/Core/MatrixBase.h:500:3:   required from 'Derived& Eigen::MatrixBase<Derived>::operator*=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<long long int, -1, -1>; Derived = Eigen::Matrix<long long int, -1, -1>]'
..\binary_library.cpp:545:12:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >; Derived = Eigen::Matrix<std::complex<float>, -1, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >; Derived = Eigen::Matrix<std::complex<float>, -1, 1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Core/ProductEvaluators.h:275:58:   required from 'void Eigen::internal::outer_product_selector_run(Dst&, const Lhs&, const Rhs&, const Func&, const Eigen::internal::false_type&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >; Rhs = Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; Func = Eigen::internal::generic_product_impl<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, Eigen::DenseShape, Eigen::DenseShape, 5>::sub]'
..\Eigen/src/Core/ProductEvaluators.h:329:41:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 5>::subTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >; Rhs = Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >]'
..\Eigen/src/Core/ProductEvaluators.h:178:42:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::sub_assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >; Rhs = Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Src = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, 0>; Func = Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/NoAlias.h:58:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator-=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, 0>; ExpressionType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:166:21:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheRight(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false>; Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Householder/HouseholderSequence.h:255:13:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::evalTo(Dest&, Workspace&) const [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Workspace = Eigen::Matrix<std::complex<float>, 1, -1>; VectorsType = Eigen::Matrix<std::complex<float>, -1, -1>; CoeffsType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; int Side = 1]'
..\Eigen/src/SVD/JacobiSVD.h:233:30:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, -1, 1, true> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Matrix<std::complex<float>, -1, 1> > >, Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, -1, 1, true> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Matrix<std::complex<float>, -1, 1> > >, Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, -1, 1, true>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; Functor = Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, -1, 1, true>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; Functor = Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, -1, 1, true>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; Func = Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, -1, 1, true>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; Func = Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/CwiseBinaryOp.h:164:18:   required from 'Derived& Eigen::MatrixBase<Derived>::operator-=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; Derived = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, -1, 1, true>]'
..\Eigen/src/Core/ProductEvaluators.h:305:135:   required from 'void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 5>::sub::operator()(const Dst&, const Src&) const [with Dst = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, -1, 1, true>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >; Rhs = Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >]'
..\Eigen/src/Core/ProductEvaluators.h:280:9:   required from 'void Eigen::internal::outer_product_selector_run(Dst&, const Lhs&, const Rhs&, const Func&, const Eigen::internal::false_type&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >; Rhs = Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; Func = Eigen::internal::generic_product_impl<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, Eigen::DenseShape, Eigen::DenseShape, 5>::sub]'
..\Eigen/src/Core/ProductEvaluators.h:329:41:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 5>::subTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >; Rhs = Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >]'
..\Eigen/src/Core/ProductEvaluators.h:178:42:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::sub_assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >; Rhs = Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Src = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, 0>; Func = Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/NoAlias.h:58:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator-=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, 0>; ExpressionType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:166:21:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheRight(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false>; Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Householder/HouseholderSequence.h:255:13:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::evalTo(Dest&, Workspace&) const [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Workspace = Eigen::Matrix<std::complex<float>, 1, -1>; VectorsType = Eigen::Matrix<std::complex<float>, -1, -1>; CoeffsType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; int Side = 1]'
..\Eigen/src/SVD/JacobiSVD.h:233:30:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; Derived = Eigen::Matrix<std::complex<float>, -1, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; Derived = Eigen::Matrix<std::complex<float>, -1, 1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Core/ProductEvaluators.h:275:58:   required from 'void Eigen::internal::outer_product_selector_run(Dst&, const Lhs&, const Rhs&, const Func&, const Eigen::internal::false_type&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; Rhs = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Func = Eigen::internal::generic_product_impl<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::DenseShape, Eigen::DenseShape, 5>::sub]'
..\Eigen/src/Core/ProductEvaluators.h:329:41:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 5>::subTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; Rhs = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/ProductEvaluators.h:178:42:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::sub_assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; Rhs = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Src = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >, 0>; Func = Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/NoAlias.h:58:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator-=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >, 0>; ExpressionType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:129:22:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheLeft(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false>; Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Householder/HouseholderSequence.h:258:13:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::evalTo(Dest&, Workspace&) const [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Workspace = Eigen::Matrix<std::complex<float>, 1, -1>; VectorsType = Eigen::Matrix<std::complex<float>, -1, -1>; CoeffsType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; int Side = 1]'
..\Eigen/src/SVD/JacobiSVD.h:233:30:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
In file included from ..\Eigen/Core:473:0,
                 from ..\binary_library.cpp:18:
..\Eigen/src/Core/products/GeneralMatrixVector.h: In instantiation of 'static void Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 1, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::run(Index, Index, const LhsMapper&, const RhsMapper&, Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 1, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::ResScalar*, Index, Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 1, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::ResScalar) [with Index = long long int; LhsScalar = std::complex<float>; LhsMapper = Eigen::internal::const_blas_data_mapper<std::complex<float>, long long int, 1>; bool ConjugateLhs = false; RhsScalar = std::complex<float>; RhsMapper = Eigen::internal::const_blas_data_mapper<std::complex<float>, long long int, 1>; bool ConjugateRhs = true; int Version = 1; Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 1, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::ResScalar = std::complex<float>]':
..\Eigen/src/Core/products/TriangularMatrixVector.h:145:123:   required from 'static void Eigen::internal::triangular_matrix_vector_product<Index, Mode, LhsScalar, ConjLhs, RhsScalar, ConjRhs, 1, Version>::run(Index, Index, const LhsScalar*, Index, const RhsScalar*, Index, Eigen::internal::triangular_matrix_vector_product<Index, Mode, LhsScalar, ConjLhs, RhsScalar, ConjRhs, 1, Version>::ResScalar*, Index, const ResScalar&) [with Index = long long int; int Mode = 6; LhsScalar = std::complex<float>; bool ConjLhs = false; RhsScalar = std::complex<float>; bool ConjRhs = true; int Version = 0; Eigen::internal::triangular_matrix_vector_product<Index, Mode, LhsScalar, ConjLhs, RhsScalar, ConjRhs, 1, Version>::ResScalar = std::complex<float>]'
..\Eigen/src/Core/products/TriangularMatrixVector.h:324:12:   required from 'static void Eigen::internal::trmv_selector<Mode, 1>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Transpose<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false> >; Rhs = Eigen::Transpose<const Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > > >; Dest = Eigen::Transpose<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false> >; int Mode = 6; typename Dest::Scalar = std::complex<float>]'
..\Eigen/src/Core/products/TriangularMatrixVector.h:194:18:   required from 'static void Eigen::internal::triangular_product_impl<Mode, false, Lhs, true, Rhs, false>::run(Dest&, const Lhs&, const Rhs&, const typename Dest::Scalar&) [with Dest = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; int Mode = 5; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >; Rhs = const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; typename Dest::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:725:113:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::TriangularShape, ProductTag>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >; Rhs = Eigen::TriangularView<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 5>; int ProductTag = 7; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::TriangularShape, ProductTag>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >; Rhs = Eigen::TriangularView<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 5>; Derived = Eigen::internal::generic_product_impl<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >, Eigen::TriangularView<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 5>, Eigen::DenseShape, Eigen::TriangularShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >; Rhs = Eigen::TriangularView<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 5>; Derived = Eigen::internal::generic_product_impl<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >, Eigen::TriangularView<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 5>, Eigen::DenseShape, Eigen::TriangularShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >; Rhs = Eigen::TriangularView<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 5>; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >, Eigen::TriangularView<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 5>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Src = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >, Eigen::TriangularView<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 5>, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/NoAlias.h:42:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >, Eigen::TriangularView<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 5>, 0>; ExpressionType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/BlockHouseholder.h:63:43:   required from 'void Eigen::internal::make_block_householder_triangular_factor(TriangularFactorType&, const VectorsType&, const CoeffsType&) [with TriangularFactorType = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; VectorsType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; CoeffsType = Eigen::VectorBlock<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, -1>]'
..\Eigen/src/Householder/BlockHouseholder.h:85:55:   required from 'void Eigen::internal::apply_block_householder_on_the_left(MatrixType&, const VectorsType&, const CoeffsType&, bool) [with MatrixType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; VectorsType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; CoeffsType = Eigen::VectorBlock<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, -1>]'
..\Eigen/src/Householder/HouseholderSequence.h:333:46:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::applyThisOnTheLeft(Dest&, Workspace&) const [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Workspace = Eigen::Matrix<std::complex<float>, 1, -1>; VectorsType = Eigen::Matrix<std::complex<float>, -1, -1>; CoeffsType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; int Side = 1]'
..\Eigen/src/SVD/JacobiSVD.h:237:9:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/products/GeneralMatrixVector.h:460:39: warning: enum constant in boolean context [-Wint-in-bool-context]
   const Index offset1 = (FirstAligned && alignmentStep==1)?3:1;
                         ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/products/GeneralMatrixVector.h:461:39: warning: enum constant in boolean context [-Wint-in-bool-context]
   const Index offset3 = (FirstAligned && alignmentStep==1)?1:3;
                         ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/products/GeneralMatrixVector.h: In instantiation of 'static void Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 1, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::run(Index, Index, const LhsMapper&, const RhsMapper&, Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 1, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::ResScalar*, Index, Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 1, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::ResScalar) [with Index = long long int; LhsScalar = std::complex<float>; LhsMapper = Eigen::internal::const_blas_data_mapper<std::complex<float>, long long int, 1>; bool ConjugateLhs = false; RhsScalar = std::complex<float>; RhsMapper = Eigen::internal::const_blas_data_mapper<std::complex<float>, long long int, 1>; bool ConjugateRhs = true; int Version = 0; Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 1, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::ResScalar = std::complex<float>]':
..\Eigen/src/Core/products/TriangularMatrixVector.h:154:113:   required from 'static void Eigen::internal::triangular_matrix_vector_product<Index, Mode, LhsScalar, ConjLhs, RhsScalar, ConjRhs, 1, Version>::run(Index, Index, const LhsScalar*, Index, const RhsScalar*, Index, Eigen::internal::triangular_matrix_vector_product<Index, Mode, LhsScalar, ConjLhs, RhsScalar, ConjRhs, 1, Version>::ResScalar*, Index, const ResScalar&) [with Index = long long int; int Mode = 6; LhsScalar = std::complex<float>; bool ConjLhs = false; RhsScalar = std::complex<float>; bool ConjRhs = true; int Version = 0; Eigen::internal::triangular_matrix_vector_product<Index, Mode, LhsScalar, ConjLhs, RhsScalar, ConjRhs, 1, Version>::ResScalar = std::complex<float>]'
..\Eigen/src/Core/products/TriangularMatrixVector.h:324:12:   required from 'static void Eigen::internal::trmv_selector<Mode, 1>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Transpose<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false> >; Rhs = Eigen::Transpose<const Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > > >; Dest = Eigen::Transpose<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false> >; int Mode = 6; typename Dest::Scalar = std::complex<float>]'
..\Eigen/src/Core/products/TriangularMatrixVector.h:194:18:   required from 'static void Eigen::internal::triangular_product_impl<Mode, false, Lhs, true, Rhs, false>::run(Dest&, const Lhs&, const Rhs&, const typename Dest::Scalar&) [with Dest = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; int Mode = 5; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >; Rhs = const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; typename Dest::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:725:113:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::TriangularShape, ProductTag>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >; Rhs = Eigen::TriangularView<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 5>; int ProductTag = 7; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::TriangularShape, ProductTag>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >; Rhs = Eigen::TriangularView<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 5>; Derived = Eigen::internal::generic_product_impl<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >, Eigen::TriangularView<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 5>, Eigen::DenseShape, Eigen::TriangularShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >; Rhs = Eigen::TriangularView<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 5>; Derived = Eigen::internal::generic_product_impl<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >, Eigen::TriangularView<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 5>, Eigen::DenseShape, Eigen::TriangularShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >; Rhs = Eigen::TriangularView<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 5>; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >, Eigen::TriangularView<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 5>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Src = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >, Eigen::TriangularView<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 5>, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/NoAlias.h:42:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >, Eigen::TriangularView<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 5>, 0>; ExpressionType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/BlockHouseholder.h:63:43:   required from 'void Eigen::internal::make_block_householder_triangular_factor(TriangularFactorType&, const VectorsType&, const CoeffsType&) [with TriangularFactorType = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; VectorsType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; CoeffsType = Eigen::VectorBlock<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, -1>]'
..\Eigen/src/Householder/BlockHouseholder.h:85:55:   required from 'void Eigen::internal::apply_block_householder_on_the_left(MatrixType&, const VectorsType&, const CoeffsType&, bool) [with MatrixType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; VectorsType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; CoeffsType = Eigen::VectorBlock<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, -1>]'
..\Eigen/src/Householder/HouseholderSequence.h:333:46:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::applyThisOnTheLeft(Dest&, Workspace&) const [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Workspace = Eigen::Matrix<std::complex<float>, 1, -1>; VectorsType = Eigen::Matrix<std::complex<float>, -1, -1>; CoeffsType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; int Side = 1]'
..\Eigen/src/SVD/JacobiSVD.h:237:9:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/products/GeneralMatrixVector.h:460:39: warning: enum constant in boolean context [-Wint-in-bool-context]
   const Index offset1 = (FirstAligned && alignmentStep==1)?3:1;
                         ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/products/GeneralMatrixVector.h:461:39: warning: enum constant in boolean context [-Wint-in-bool-context]
   const Index offset3 = (FirstAligned && alignmentStep==1)?1:3;
                         ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from ..\Eigen/Core:420:0,
                 from ..\binary_library.cpp:18:
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 1> >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 1> >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 1>; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 1>; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 1>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/ProductEvaluators.h:397:29:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 3>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Rhs = Eigen::Transpose<Eigen::Matrix<double, -1, -1> >]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:431:26:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Rhs = Eigen::Transpose<Eigen::Matrix<double, -1, -1> >]'
..\Eigen/src/Core/ProductEvaluators.h:124:75:   required from 'Eigen::internal::product_evaluator<Eigen::Product<Lhs, Rhs, Option>, ProductTag, LhsShape, RhsShape>::product_evaluator(const XprType&) [with Lhs = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Rhs = Eigen::Transpose<Eigen::Matrix<double, -1, -1> >; int Options = 0; int ProductTag = 8; LhsShape = Eigen::DenseShape; RhsShape = Eigen::DenseShape; typename Eigen::internal::traits<typename Eigen::Product<Lhs, Rhs, Option>::Rhs>::Scalar = double; typename Eigen::internal::traits<typename Eigen::Product<Lhs, Rhs, Option>::Lhs>::Scalar = double; Eigen::internal::product_evaluator<Eigen::Product<Lhs, Rhs, Option>, ProductTag, LhsShape, RhsShape>::XprType = Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 0>]'
..\Eigen/src/Core/ProductEvaluators.h:35:70:   required from 'Eigen::internal::evaluator<Eigen::Product<Lhs, Rhs, Option> >::evaluator(const XprType&) [with Lhs = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Rhs = Eigen::Transpose<Eigen::Matrix<double, -1, -1> >; int Options = 0; Eigen::internal::evaluator<Eigen::Product<Lhs, Rhs, Option> >::XprType = Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 0>]'
..\Eigen/src/Core/CoreEvaluators.h:103:54:   required from 'Eigen::internal::evaluator<const T>::evaluator(const T&) [with T = Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 0>]'
..\Eigen/src/Core/CoreEvaluators.h:702:26:   required from 'Eigen::internal::binary_evaluator<Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs>, Eigen::internal::IndexBased, Eigen::internal::IndexBased>::binary_evaluator(const XprType&) [with BinaryOp = Eigen::internal::scalar_quotient_op<double, double>; Lhs = const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 0>; Rhs = const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> >; typename Eigen::internal::traits<typename Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs>::Rhs>::Scalar = double; typename Eigen::internal::traits<typename Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs>::Lhs>::Scalar = double; Eigen::internal::binary_evaluator<Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs>, Eigen::internal::IndexBased, Eigen::internal::IndexBased>::XprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >]'
..\Eigen/src/Core/CoreEvaluators.h:671:70:   required from 'Eigen::internal::evaluator<Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs> >::evaluator(const XprType&) [with BinaryOp = Eigen::internal::scalar_quotient_op<double, double>; Lhs = const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 0>; Rhs = const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> >; Eigen::internal::evaluator<Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs> >::XprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >]'
..\Eigen/src/Core/AssignEvaluator.h:753:19:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:171:27:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >, 1> >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >, 1> >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >, 1>; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >, 1>; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >, 1>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/ProductEvaluators.h:397:29:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 3>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:431:26:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >]'
..\Eigen/src/Core/ProductEvaluators.h:124:75:   required from 'Eigen::internal::product_evaluator<Eigen::Product<Lhs, Rhs, Option>, ProductTag, LhsShape, RhsShape>::product_evaluator(const XprType&) [with Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >; int Options = 0; int ProductTag = 8; LhsShape = Eigen::DenseShape; RhsShape = Eigen::DenseShape; typename Eigen::internal::traits<typename Eigen::Product<Lhs, Rhs, Option>::Rhs>::Scalar = double; typename Eigen::internal::traits<typename Eigen::Product<Lhs, Rhs, Option>::Lhs>::Scalar = double; Eigen::internal::product_evaluator<Eigen::Product<Lhs, Rhs, Option>, ProductTag, LhsShape, RhsShape>::XprType = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >, 0>]'
..\Eigen/src/Core/ProductEvaluators.h:35:70:   required from 'Eigen::internal::evaluator<Eigen::Product<Lhs, Rhs, Option> >::evaluator(const XprType&) [with Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >; int Options = 0; Eigen::internal::evaluator<Eigen::Product<Lhs, Rhs, Option> >::XprType = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >, 0>]'
..\Eigen/src/Core/CoreEvaluators.h:103:54:   required from 'Eigen::internal::evaluator<const T>::evaluator(const T&) [with T = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >, 0>]'
..\Eigen/src/Core/CoreEvaluators.h:702:26:   required from 'Eigen::internal::binary_evaluator<Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs>, Eigen::internal::IndexBased, Eigen::internal::IndexBased>::binary_evaluator(const XprType&) [with BinaryOp = Eigen::internal::scalar_quotient_op<double, double>; Lhs = const Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >, 0>; Rhs = const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> >; typename Eigen::internal::traits<typename Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs>::Rhs>::Scalar = double; typename Eigen::internal::traits<typename Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs>::Lhs>::Scalar = double; Eigen::internal::binary_evaluator<Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs>, Eigen::internal::IndexBased, Eigen::internal::IndexBased>::XprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >]'
..\Eigen/src/Core/CoreEvaluators.h:671:70:   required from 'Eigen::internal::evaluator<Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs> >::evaluator(const XprType&) [with BinaryOp = Eigen::internal::scalar_quotient_op<double, double>; Lhs = const Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >, 0>; Rhs = const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> >; Eigen::internal::evaluator<Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs> >::XprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >]'
..\Eigen/src/Core/AssignEvaluator.h:753:19:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:173:38:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >; Derived = Eigen::Matrix<double, -1, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >; Derived = Eigen::Matrix<double, -1, 1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >; _Scalar = double; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Core/ProductEvaluators.h:275:58:   required from 'void Eigen::internal::outer_product_selector_run(Dst&, const Lhs&, const Rhs&, const Func&, const Eigen::internal::false_type&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >; Rhs = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; Func = Eigen::internal::generic_product_impl<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::DenseShape, Eigen::DenseShape, 5>::sub]'
..\Eigen/src/Core/ProductEvaluators.h:329:41:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 5>::subTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >; Rhs = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/ProductEvaluators.h:178:42:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::sub_assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >; Rhs = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>; Src = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 0>; Func = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/NoAlias.h:58:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator-=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 0>; ExpressionType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:129:22:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheLeft(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::VectorBlock<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1>; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = double]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:313:5:   required from 'static void Eigen::HessenbergDecomposition<_MatrixType>::_compute(Eigen::HessenbergDecomposition<_MatrixType>::MatrixType&, Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType&, Eigen::HessenbergDecomposition<_MatrixType>::VectorType&) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType = Eigen::Matrix<double, -1, 1>; typename _MatrixType::Scalar = double; Eigen::HessenbergDecomposition<_MatrixType>::VectorType = Eigen::Matrix<double, 1, -1>]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:161:15:   required from 'Eigen::HessenbergDecomposition<_MatrixType>& Eigen::HessenbergDecomposition<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&) [with InputType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:271:3:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>, -1, 1, true> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Matrix<double, -1, 1> > >, Eigen::internal::sub_assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>, -1, 1, true> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Matrix<double, -1, 1> > >, Eigen::internal::sub_assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>, -1, 1, true>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Matrix<double, -1, 1> >; Functor = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>, -1, 1, true>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Matrix<double, -1, 1> >; Functor = Eigen::internal::sub_assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>, -1, 1, true>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Matrix<double, -1, 1> >; Func = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>, -1, 1, true>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Matrix<double, -1, 1> >; Func = Eigen::internal::sub_assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/CwiseBinaryOp.h:164:18:   required from 'Derived& Eigen::MatrixBase<Derived>::operator-=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Matrix<double, -1, 1> >; Derived = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>, -1, 1, true>]'
..\Eigen/src/Core/ProductEvaluators.h:305:135:   required from 'void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 5>::sub::operator()(const Dst&, const Src&) const [with Dst = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>, -1, 1, true>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Matrix<double, -1, 1> >; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >; Rhs = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/ProductEvaluators.h:280:9:   required from 'void Eigen::internal::outer_product_selector_run(Dst&, const Lhs&, const Rhs&, const Func&, const Eigen::internal::false_type&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >; Rhs = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; Func = Eigen::internal::generic_product_impl<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::DenseShape, Eigen::DenseShape, 5>::sub]'
..\Eigen/src/Core/ProductEvaluators.h:329:41:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 5>::subTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >; Rhs = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/ProductEvaluators.h:178:42:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::sub_assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >; Rhs = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>; Src = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 0>; Func = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/NoAlias.h:58:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator-=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 0>; ExpressionType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:129:22:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheLeft(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::VectorBlock<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1>; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = double]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:313:5:   required from 'static void Eigen::HessenbergDecomposition<_MatrixType>::_compute(Eigen::HessenbergDecomposition<_MatrixType>::MatrixType&, Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType&, Eigen::HessenbergDecomposition<_MatrixType>::VectorType&) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType = Eigen::Matrix<double, -1, 1>; typename _MatrixType::Scalar = double; Eigen::HessenbergDecomposition<_MatrixType>::VectorType = Eigen::Matrix<double, 1, -1>]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:161:15:   required from 'Eigen::HessenbergDecomposition<_MatrixType>& Eigen::HessenbergDecomposition<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&) [with InputType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:271:3:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >; Derived = Eigen::Matrix<double, -1, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >; Derived = Eigen::Matrix<double, -1, 1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >; _Scalar = double; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Core/ProductEvaluators.h:275:58:   required from 'void Eigen::internal::outer_product_selector_run(Dst&, const Lhs&, const Rhs&, const Func&, const Eigen::internal::false_type&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >; Rhs = Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >; Func = Eigen::internal::generic_product_impl<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::DenseShape, Eigen::DenseShape, 5>::sub]'
..\Eigen/src/Core/ProductEvaluators.h:329:41:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 5>::subTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >; Rhs = Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >]'
..\Eigen/src/Core/ProductEvaluators.h:178:42:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::sub_assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >; Rhs = Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>; Src = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >, 0>; Func = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/NoAlias.h:58:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator-=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >, 0>; ExpressionType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:166:21:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheRight(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Eigen::MatrixBase<Derived>::Scalar = double]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:317:5:   required from 'static void Eigen::HessenbergDecomposition<_MatrixType>::_compute(Eigen::HessenbergDecomposition<_MatrixType>::MatrixType&, Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType&, Eigen::HessenbergDecomposition<_MatrixType>::VectorType&) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType = Eigen::Matrix<double, -1, 1>; typename _MatrixType::Scalar = double; Eigen::HessenbergDecomposition<_MatrixType>::VectorType = Eigen::Matrix<double, 1, -1>]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:161:15:   required from 'Eigen::HessenbergDecomposition<_MatrixType>& Eigen::HessenbergDecomposition<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&) [with InputType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:271:3:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>, -1, 1, true> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Matrix<double, -1, 1> > >, Eigen::internal::sub_assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>, -1, 1, true> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Matrix<double, -1, 1> > >, Eigen::internal::sub_assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>, -1, 1, true>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Matrix<double, -1, 1> >; Functor = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>, -1, 1, true>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Matrix<double, -1, 1> >; Functor = Eigen::internal::sub_assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>, -1, 1, true>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Matrix<double, -1, 1> >; Func = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>, -1, 1, true>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Matrix<double, -1, 1> >; Func = Eigen::internal::sub_assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/CwiseBinaryOp.h:164:18:   required from 'Derived& Eigen::MatrixBase<Derived>::operator-=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Matrix<double, -1, 1> >; Derived = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>, -1, 1, true>]'
..\Eigen/src/Core/ProductEvaluators.h:305:135:   required from 'void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 5>::sub::operator()(const Dst&, const Src&) const [with Dst = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>, -1, 1, true>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Matrix<double, -1, 1> >; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >; Rhs = Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >]'
..\Eigen/src/Core/ProductEvaluators.h:280:9:   required from 'void Eigen::internal::outer_product_selector_run(Dst&, const Lhs&, const Rhs&, const Func&, const Eigen::internal::false_type&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >; Rhs = Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >; Func = Eigen::internal::generic_product_impl<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::DenseShape, Eigen::DenseShape, 5>::sub]'
..\Eigen/src/Core/ProductEvaluators.h:329:41:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 5>::subTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >; Rhs = Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >]'
..\Eigen/src/Core/ProductEvaluators.h:178:42:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::sub_assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >; Rhs = Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>; Src = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >, 0>; Func = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/NoAlias.h:58:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator-=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >, 0>; ExpressionType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:166:21:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheRight(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Eigen::MatrixBase<Derived>::Scalar = double]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:317:5:   required from 'static void Eigen::HessenbergDecomposition<_MatrixType>::_compute(Eigen::HessenbergDecomposition<_MatrixType>::MatrixType&, Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType&, Eigen::HessenbergDecomposition<_MatrixType>::VectorType&) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType = Eigen::Matrix<double, -1, 1>; typename _MatrixType::Scalar = double; Eigen::HessenbergDecomposition<_MatrixType>::VectorType = Eigen::Matrix<double, 1, -1>]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:161:15:   required from 'Eigen::HessenbergDecomposition<_MatrixType>& Eigen::HessenbergDecomposition<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&) [with InputType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:271:3:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, 1> >, Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, 1> >, Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, 1>; SrcXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, 1>; SrcXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, 1>; Src = Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<double, -1, 1>; Src = Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> >; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, -1, 1>; Src = Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> >; Derived = Eigen::Matrix<double, -1, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> >; _Scalar = double; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Core/GeneralProduct.h:284:16:   required from 'static void Eigen::internal::gemv_dense_selector<2, 0, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Dest = Eigen::Matrix<double, -1, 1>; typename Dest::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<double, -1, 1>; Lhs = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Matrix<double, -1, 1>; Lhs = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, 1>; Lhs = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<double, -1, 1>; Lhs = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, 1>; Src = Eigen::Product<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/NoAlias.h:42:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, 0>; ExpressionType = Eigen::Matrix<double, -1, 1>; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Eigenvalues/EigenSolver.h:615:21:   required from 'void Eigen::EigenSolver<_MatrixType>::doComputeEigenvectors() [with _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:447:28:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, 1, 1, 0, 1, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, 1, 1, 0, 1, 1> > > >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, 1, 1, 0, 1, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, 1, 1, 0, 1, 1> > > >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, 1, 1, 0, 1, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, 1, 1, 0, 1, 1> > >; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, 1, 1, 0, 1, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, 1, 1, 0, 1, 1> > >; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, 1, 1, 0, 1, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, 1, 1, 0, 1, 1> > >; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, 1, 1, 0, 1, 1> > >; Derived = Eigen::Matrix<std::complex<long long int>, 1, 1, 0, 1, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, 1, 1, 0, 1, 1> > >; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, 1, 1, 0, 1, 1> > >; Derived = Eigen::Matrix<std::complex<long long int>, 1, 1, 0, 1, 1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, 1, 1, 0, 1, 1> > >; _Scalar = std::complex<long long int>; int _Rows = 1; int _Cols = 1; int _Options = 0; int _MaxRows = 1; int _MaxCols = 1]'
..\Eigen/src/Core/ProductEvaluators.h:451:34:   required from 'Eigen::internal::product_evaluator<Eigen::Product<Lhs, Rhs, 1>, ProductTag, Eigen::DenseShape, Eigen::DenseShape>::product_evaluator(const XprType&) [with Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> >; Rhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, 1, 1, 0, 1, 1> > >; int ProductTag = 3; typename Eigen::internal::traits<typename Eigen::Product<Lhs, Rhs, 1>::Rhs>::Scalar = std::complex<long long int>; typename Eigen::internal::traits<typename Eigen::Product<Lhs, Rhs, 1>::Lhs>::Scalar = std::complex<long long int>; Eigen::internal::product_evaluator<Eigen::Product<Lhs, Rhs, 1>, ProductTag, Eigen::DenseShape, Eigen::DenseShape>::XprType = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, 1, 1, 0, 1, 1> > >, 1>]'
..\Eigen/src/Core/ProductEvaluators.h:607:44:   required from 'Eigen::internal::product_evaluator<Eigen::Product<Lhs, Rhs, 0>, 4, Eigen::DenseShape, Eigen::DenseShape>::product_evaluator(const XprType&) [with Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> >; Rhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, 1, 1, 0, 1, 1> > >; typename Eigen::internal::traits<typename Eigen::Product<Lhs, Rhs, 0>::Rhs>::Scalar = std::complex<long long int>; typename Eigen::internal::traits<typename Eigen::Product<Lhs, Rhs, 0>::Lhs>::Scalar = std::complex<long long int>; Eigen::internal::product_evaluator<Eigen::Product<Lhs, Rhs, 0>, 4, Eigen::DenseShape, Eigen::DenseShape>::XprType = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, 1, 1, 0, 1, 1> > >, 0>]'
..\Eigen/src/Core/ProductEvaluators.h:35:70:   required from 'Eigen::internal::evaluator<Eigen::Product<Lhs, Rhs, Option> >::evaluator(const XprType&) [with Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> >; Rhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, 1, 1, 0, 1, 1> > >; int Options = 0; Eigen::internal::evaluator<Eigen::Product<Lhs, Rhs, Option> >::XprType = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, 1, 1, 0, 1, 1> > >, 0>]'
..\Eigen/src/Core/CoreEvaluators.h:103:54:   required from 'Eigen::internal::evaluator<const T>::evaluator(const T&) [with T = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, 1, 1, 0, 1, 1> > >, 0>]'
..\Eigen/src/Core/CoreEvaluators.h:702:26:   required from 'Eigen::internal::binary_evaluator<Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs>, Eigen::internal::IndexBased, Eigen::internal::IndexBased>::binary_evaluator(const XprType&) [with BinaryOp = Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>; Lhs = const Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, 1, 1, 0, 1, 1> > >, 0>; Rhs = const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >; typename Eigen::internal::traits<typename Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs>::Rhs>::Scalar = long long int; typename Eigen::internal::traits<typename Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs>::Lhs>::Scalar = std::complex<long long int>; Eigen::internal::binary_evaluator<Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs>, Eigen::internal::IndexBased, Eigen::internal::IndexBased>::XprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, 1, 1, 0, 1, 1> > >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> > >]'
..\Eigen/src/Core/CoreEvaluators.h:671:70:   required from 'Eigen::internal::evaluator<Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs> >::evaluator(const XprType&) [with BinaryOp = Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>; Lhs = const Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, 1, 1, 0, 1, 1> > >, 0>; Rhs = const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >; Eigen::internal::evaluator<Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs> >::XprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, 1, 1, 0, 1, 1> > >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> > >]'
..\Eigen/src/Core/AssignEvaluator.h:753:19:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, 1, 1, 0, 1, 1> > >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> > >; Functor = Eigen::internal::sub_assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, 1, 1, 0, 1, 1> > >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> > >; Functor = Eigen::internal::sub_assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, 1, 1, 0, 1, 1> > >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> > >; Func = Eigen::internal::sub_assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, 1, 1, 0, 1, 1> > >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> > >; Func = Eigen::internal::sub_assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/CwiseBinaryOp.h:164:18:   required from 'Derived& Eigen::MatrixBase<Derived>::operator-=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<std::complex<long long int>, long long int>, const Eigen::Product<Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, 1, 1, 0, 1, 1> > >, 0>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> > >; Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\binary_library.cpp:442:58:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> >; Derived = Eigen::Matrix<std::complex<float>, -1, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> >; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> >; Derived = Eigen::Matrix<std::complex<float>, -1, 1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> >; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Core/ProductEvaluators.h:275:58:   required from 'void Eigen::internal::outer_product_selector_run(Dst&, const Lhs&, const Rhs&, const Func&, const Eigen::internal::false_type&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> >; Rhs = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Func = Eigen::internal::generic_product_impl<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::DenseShape, Eigen::DenseShape, 5>::sub]'
..\Eigen/src/Core/ProductEvaluators.h:329:41:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 5>::subTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> >; Rhs = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/ProductEvaluators.h:178:42:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::sub_assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> >; Rhs = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Src = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >, 0>; Func = Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/NoAlias.h:58:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator-=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >, 0>; ExpressionType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:129:22:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheLeft(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::VectorBlock<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1>; Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/QR/ColPivHouseholderQR.h:547:5:   required from 'void Eigen::ColPivHouseholderQR<MatrixType>::computeInPlace() [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/QR/ColPivHouseholderQR.h:475:17:   required from 'Eigen::ColPivHouseholderQR<_MatrixType>& Eigen::ColPivHouseholderQR<MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:230:7:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Derived = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/CwiseNullaryOp.h:327:20:   required from 'Derived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Eigen::DenseBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/CwiseNullaryOp.h:501:21:   required from 'Derived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/ProductEvaluators.h:349:5:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/NoAlias.h:42:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, 0>; ExpressionType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:163:19:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheRight(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false>; Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Householder/HouseholderSequence.h:255:13:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::evalTo(Dest&, Workspace&) const [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Workspace = Eigen::Matrix<std::complex<float>, 1, -1>; VectorsType = Eigen::Matrix<std::complex<float>, -1, -1>; CoeffsType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; int Side = 1]'
..\Eigen/src/SVD/JacobiSVD.h:233:30:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> > > >, Eigen::internal::add_assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> > > >, Eigen::internal::add_assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> > >; Functor = Eigen::internal::add_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> > >; Functor = Eigen::internal::add_assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> > >; Func = Eigen::internal::add_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> > >; Func = Eigen::internal::add_assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/CwiseBinaryOp.h:177:18:   required from 'Derived& Eigen::MatrixBase<Derived>::operator+=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> > >; Derived = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/GeneralProduct.h:282:25:   required from 'static void Eigen::internal::gemv_dense_selector<2, 0, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; Dest = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; typename Dest::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/NoAlias.h:42:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, 0>; ExpressionType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:163:19:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheRight(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false>; Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Householder/HouseholderSequence.h:255:13:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::evalTo(Dest&, Workspace&) const [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Workspace = Eigen::Matrix<std::complex<float>, 1, -1>; VectorsType = Eigen::Matrix<std::complex<float>, -1, -1>; CoeffsType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; int Side = 1]'
..\Eigen/src/SVD/JacobiSVD.h:233:30:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> >; Derived = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/CwiseNullaryOp.h:327:20:   required from 'Derived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Eigen::DenseBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/CwiseNullaryOp.h:501:21:   required from 'Derived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/ProductEvaluators.h:349:5:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > >, Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > >, Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > >, Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/NoAlias.h:42:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > >, Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 0>; ExpressionType = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:126:19:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheLeft(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false>; Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Householder/HouseholderSequence.h:258:13:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::evalTo(Dest&, Workspace&) const [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Workspace = Eigen::Matrix<std::complex<float>, 1, -1>; VectorsType = Eigen::Matrix<std::complex<float>, -1, -1>; CoeffsType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; int Side = 1]'
..\Eigen/src/SVD/JacobiSVD.h:233:30:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; SrcXprType = Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:537:19:   required from 'Eigen::PlainObjectBase<Derived>::PlainObjectBase(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:379:29:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:464:69:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; Lhs = Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::Scalar = std::complex<float>]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:435:20:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; Lhs = Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; Lhs = Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; Src = Eigen::Product<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 0>; Derived = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 0>; OtherDerived = Eigen::Product<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 0>; Derived = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 0>; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 1; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Product<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Product<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 0>; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 0>; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:1006:32:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 1, -1> > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 1, -1> > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 1, -1> >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 1, -1> >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 1, -1> >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 1, -1> >; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 1, -1> >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 1, -1> >; Derived = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/CwiseNullaryOp.h:327:20:   required from 'Derived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; Eigen::DenseBase<Derived>::Scalar = double]'
..\Eigen/src/Core/CwiseNullaryOp.h:501:21:   required from 'Derived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/ProductEvaluators.h:349:5:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/NoAlias.h:42:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>, 0>; ExpressionType = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:126:19:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheLeft(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::VectorBlock<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1>; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = double]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:313:5:   required from 'static void Eigen::HessenbergDecomposition<_MatrixType>::_compute(Eigen::HessenbergDecomposition<_MatrixType>::MatrixType&, Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType&, Eigen::HessenbergDecomposition<_MatrixType>::VectorType&) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType = Eigen::Matrix<double, -1, 1>; typename _MatrixType::Scalar = double; Eigen::HessenbergDecomposition<_MatrixType>::VectorType = Eigen::Matrix<double, 1, -1>]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:161:15:   required from 'Eigen::HessenbergDecomposition<_MatrixType>& Eigen::HessenbergDecomposition<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&) [with InputType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:271:3:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Derived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/CwiseNullaryOp.h:327:20:   required from 'Derived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Eigen::DenseBase<Derived>::Scalar = double]'
..\Eigen/src/Core/CwiseNullaryOp.h:501:21:   required from 'Derived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/ProductEvaluators.h:349:5:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/NoAlias.h:42:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, 0>; ExpressionType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:163:19:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheRight(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Eigen::MatrixBase<Derived>::Scalar = double]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:317:5:   required from 'static void Eigen::HessenbergDecomposition<_MatrixType>::_compute(Eigen::HessenbergDecomposition<_MatrixType>::MatrixType&, Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType&, Eigen::HessenbergDecomposition<_MatrixType>::VectorType&) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType = Eigen::Matrix<double, -1, 1>; typename _MatrixType::Scalar = double; Eigen::HessenbergDecomposition<_MatrixType>::VectorType = Eigen::Matrix<double, 1, -1>]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:161:15:   required from 'Eigen::HessenbergDecomposition<_MatrixType>& Eigen::HessenbergDecomposition<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&) [with InputType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:271:3:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> > > >, Eigen::internal::add_assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> > > >, Eigen::internal::add_assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> > >; Functor = Eigen::internal::add_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> > >; Functor = Eigen::internal::add_assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> > >; Func = Eigen::internal::add_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> > >; Func = Eigen::internal::add_assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/CwiseBinaryOp.h:177:18:   required from 'Derived& Eigen::MatrixBase<Derived>::operator+=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> > >; Derived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/GeneralProduct.h:282:25:   required from 'static void Eigen::internal::gemv_dense_selector<2, 0, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Dest = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; typename Dest::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/NoAlias.h:42:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, 0>; ExpressionType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:163:19:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheRight(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Eigen::MatrixBase<Derived>::Scalar = double]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:317:5:   required from 'static void Eigen::HessenbergDecomposition<_MatrixType>::_compute(Eigen::HessenbergDecomposition<_MatrixType>::MatrixType&, Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType&, Eigen::HessenbergDecomposition<_MatrixType>::VectorType&) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType = Eigen::Matrix<double, -1, 1>; typename _MatrixType::Scalar = double; Eigen::HessenbergDecomposition<_MatrixType>::VectorType = Eigen::Matrix<double, 1, -1>]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:161:15:   required from 'Eigen::HessenbergDecomposition<_MatrixType>& Eigen::HessenbergDecomposition<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&) [with InputType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:271:3:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> >; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> >; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> >; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> >; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> >; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Derived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/CwiseNullaryOp.h:327:20:   required from 'Derived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> >; Eigen::DenseBase<Derived>::Scalar = double]'
..\Eigen/src/Core/CwiseNullaryOp.h:501:21:   required from 'Derived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/GeneralProduct.h:264:11:   required from 'static void Eigen::internal::gemv_dense_selector<2, 0, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Dest = Eigen::Matrix<double, -1, 1>; typename Dest::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<double, -1, 1>; Lhs = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Matrix<double, -1, 1>; Lhs = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, 1>; Lhs = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<double, -1, 1>; Lhs = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, 1>; Src = Eigen::Product<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/NoAlias.h:42:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, 0>; ExpressionType = Eigen::Matrix<double, -1, 1>; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Eigenvalues/EigenSolver.h:615:21:   required from 'void Eigen::EigenSolver<_MatrixType>::doComputeEigenvectors() [with _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:447:28:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1, 1, -1, -1> >, Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1, 1, -1, -1> >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1, 1, -1, -1> >, Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1, 1, -1, -1> >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1, 1, -1, -1>; SrcXprType = Eigen::Matrix<double, -1, -1, 1, -1, -1>; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1, 1, -1, -1>; SrcXprType = Eigen::Matrix<double, -1, -1, 1, -1, -1>; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1, 1, -1, -1>; Src = Eigen::Matrix<double, -1, -1, 1, -1, -1>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, -1, -1, 1, -1, -1>; Derived = Eigen::Matrix<double, -1, -1, 1, -1, -1>]'
..\Eigen/src/Core/Matrix.h:278:27:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&&) [with _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 1; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:465:69:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::Scalar = double]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:435:20:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/EigenBase.h:104:9:   required from 'void Eigen::EigenBase<Derived>::applyThisOnTheRight(Dest&) const [with Dest = Eigen::Matrix<double, -1, -1>; Derived = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>]'
..\Eigen/src/Core/MatrixBase.h:500:3:   required from 'Derived& Eigen::MatrixBase<Derived>::operator*=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:179:42:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<long long int>, std::complex<long long int> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 1, Eigen::Stride<0, 0> > > >, Eigen::internal::add_assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<long long int>, std::complex<long long int> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 1, Eigen::Stride<0, 0> > > >, Eigen::internal::add_assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<long long int>, std::complex<long long int> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 1, Eigen::Stride<0, 0> > >; Functor = Eigen::internal::add_assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<long long int>, std::complex<long long int> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 1, Eigen::Stride<0, 0> > >; Functor = Eigen::internal::add_assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<long long int>, std::complex<long long int> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 1, Eigen::Stride<0, 0> > >; Func = Eigen::internal::add_assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<long long int>, std::complex<long long int> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 1, Eigen::Stride<0, 0> > >; Func = Eigen::internal::add_assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/CwiseBinaryOp.h:177:18:   required from 'Derived& Eigen::MatrixBase<Derived>::operator+=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<long long int>, std::complex<long long int> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, const Eigen::Matrix<std::complex<long long int>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 1, Eigen::Stride<0, 0> > >; Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\Eigen/src/Core/GeneralProduct.h:282:25:   required from 'static void Eigen::internal::gemv_dense_selector<2, 0, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; Dest = Eigen::Matrix<std::complex<long long int>, -1, 1>; typename Dest::Scalar = std::complex<long long int>]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<std::complex<long long int>, -1, 1>; Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = std::complex<long long int>]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; Derived = Eigen::internal::generic_product_impl<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = std::complex<long long int>]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; Derived = Eigen::internal::generic_product_impl<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; int Options = 0; Scalar = std::complex<long long int>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\binary_library.cpp:428:18:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<long long int, long long int>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, const Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 1, Eigen::Stride<0, 0> > > >, Eigen::internal::add_assign_op<long long int, long long int> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<long long int, long long int>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, const Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 1, Eigen::Stride<0, 0> > > >, Eigen::internal::add_assign_op<long long int, long long int>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<long long int, long long int>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, const Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 1, Eigen::Stride<0, 0> > >; Functor = Eigen::internal::add_assign_op<long long int, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<long long int, long long int>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, const Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 1, Eigen::Stride<0, 0> > >; Functor = Eigen::internal::add_assign_op<long long int, long long int>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<long long int, long long int>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, const Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 1, Eigen::Stride<0, 0> > >; Func = Eigen::internal::add_assign_op<long long int, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<long long int, long long int>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, const Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 1, Eigen::Stride<0, 0> > >; Func = Eigen::internal::add_assign_op<long long int, long long int>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/CwiseBinaryOp.h:177:18:   required from 'Derived& Eigen::MatrixBase<Derived>::operator+=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<long long int, long long int>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, const Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, const Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 1, Eigen::Stride<0, 0> > >; Derived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>]'
..\Eigen/src/Core/GeneralProduct.h:282:25:   required from 'static void Eigen::internal::gemv_dense_selector<2, 0, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Matrix<long long int, -1, -1>; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Dest = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; typename Dest::Scalar = long long int]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Lhs = Eigen::Matrix<long long int, -1, -1>; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = long long int]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Lhs = Eigen::Matrix<long long int, -1, -1>; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Derived = Eigen::internal::generic_product_impl<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = long long int]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Lhs = Eigen::Matrix<long long int, -1, -1>; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Derived = Eigen::internal::generic_product_impl<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Lhs = Eigen::Matrix<long long int, -1, -1>; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; int Options = 0; Scalar = long long int; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Func = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Derived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; OtherDerived = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Derived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; _Scalar = long long int; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Func = Eigen::internal::assign_op<long long int, long long int>; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Derived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; _Scalar = long long int; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\binary_library.cpp:517:24:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> >; Src = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> >; Src = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> >; Src = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Derived = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/GeneralProduct.h:268:50:   required from 'static void Eigen::internal::gemv_dense_selector<2, 0, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; Dest = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; typename Dest::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/NoAlias.h:42:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, 0>; ExpressionType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:163:19:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheRight(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false>; Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Householder/HouseholderSequence.h:255:13:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::evalTo(Dest&, Workspace&) const [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Workspace = Eigen::Matrix<std::complex<float>, 1, -1>; VectorsType = Eigen::Matrix<std::complex<float>, -1, -1>; CoeffsType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; int Side = 1]'
..\Eigen/src/SVD/JacobiSVD.h:233:30:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> >; Derived = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/GeneralProduct.h:284:16:   required from 'static void Eigen::internal::gemv_dense_selector<2, 0, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; Dest = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; typename Dest::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/NoAlias.h:42:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, 0>; ExpressionType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:163:19:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheRight(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false>; Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Householder/HouseholderSequence.h:255:13:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::evalTo(Dest&, Workspace&) const [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Workspace = Eigen::Matrix<std::complex<float>, 1, -1>; VectorsType = Eigen::Matrix<std::complex<float>, -1, -1>; CoeffsType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; int Side = 1]'
..\Eigen/src/SVD/JacobiSVD.h:233:30:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> >; Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>]'
..\Eigen/src/Core/CwiseNullaryOp.h:327:20:   required from 'Derived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Eigen::DenseBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/CwiseNullaryOp.h:501:21:   required from 'Derived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>]'
..\Eigen/src/Core/ProductEvaluators.h:349:5:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >; Rhs = Eigen::TriangularView<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 5>; Derived = Eigen::internal::generic_product_impl<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >, Eigen::TriangularView<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 5>, Eigen::DenseShape, Eigen::TriangularShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >; Rhs = Eigen::TriangularView<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 5>; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >, Eigen::TriangularView<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 5>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Src = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >, Eigen::TriangularView<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 5>, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/NoAlias.h:42:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >, Eigen::TriangularView<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 5>, 0>; ExpressionType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/BlockHouseholder.h:63:43:   required from 'void Eigen::internal::make_block_householder_triangular_factor(TriangularFactorType&, const VectorsType&, const CoeffsType&) [with TriangularFactorType = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; VectorsType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; CoeffsType = Eigen::VectorBlock<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, -1>]'
..\Eigen/src/Householder/BlockHouseholder.h:85:55:   required from 'void Eigen::internal::apply_block_householder_on_the_left(MatrixType&, const VectorsType&, const CoeffsType&, bool) [with MatrixType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; VectorsType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; CoeffsType = Eigen::VectorBlock<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, -1>]'
..\Eigen/src/Householder/HouseholderSequence.h:333:46:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::applyThisOnTheLeft(Dest&, Workspace&) const [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Workspace = Eigen::Matrix<std::complex<float>, 1, -1>; VectorsType = Eigen::Matrix<std::complex<float>, -1, -1>; CoeffsType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; int Side = 1]'
..\Eigen/src/SVD/JacobiSVD.h:237:9:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, -1, false>, -1, 1, true> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Matrix<std::complex<float>, -1, 1> > >, Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, -1, false>, -1, 1, true> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Matrix<std::complex<float>, -1, 1> > >, Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, -1, false>, -1, 1, true>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; Functor = Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, -1, false>, -1, 1, true>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; Functor = Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, -1, false>, -1, 1, true>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; Func = Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, -1, false>, -1, 1, true>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; Func = Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/CwiseBinaryOp.h:164:18:   required from 'Derived& Eigen::MatrixBase<Derived>::operator-=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; Derived = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, -1, false>, -1, 1, true>]'
..\Eigen/src/Core/ProductEvaluators.h:305:135:   required from 'void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 5>::sub::operator()(const Dst&, const Src&) const [with Dst = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, -1, false>, -1, 1, true>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >; Rhs = Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > >]'
..\Eigen/src/Core/ProductEvaluators.h:280:9:   required from 'void Eigen::internal::outer_product_selector_run(Dst&, const Lhs&, const Rhs&, const Func&, const Eigen::internal::false_type&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >; Rhs = Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > >; Func = Eigen::internal::generic_product_impl<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > >, Eigen::DenseShape, Eigen::DenseShape, 5>::sub]'
..\Eigen/src/Core/ProductEvaluators.h:329:41:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 5>::subTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >; Rhs = Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > >]'
..\Eigen/src/Core/ProductEvaluators.h:178:42:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::sub_assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >; Rhs = Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > >; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > >, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, -1, false>; Src = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > >, 0>; Func = Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/NoAlias.h:58:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator-=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > >, 0>; ExpressionType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>, -1, -1, false>; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:166:21:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheRight(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> >; Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, true>; Eigen::MatrixBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:317:5:   required from 'static void Eigen::HessenbergDecomposition<_MatrixType>::_compute(Eigen::HessenbergDecomposition<_MatrixType>::MatrixType&, Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType&, Eigen::HessenbergDecomposition<_MatrixType>::VectorType&) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType = Eigen::Matrix<std::complex<float>, -1, 1>; typename _MatrixType::Scalar = std::complex<float>; Eigen::HessenbergDecomposition<_MatrixType>::VectorType = Eigen::Matrix<std::complex<float>, 1, -1>]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:161:15:   required from 'Eigen::HessenbergDecomposition<_MatrixType>& Eigen::HessenbergDecomposition<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Eigenvalues/ComplexSchur.h:358:5:   required from 'static void Eigen::internal::complex_schur_reduce_to_hessenberg<MatrixType, IsComplex>::run(Eigen::ComplexSchur<MatrixType>&, const MatrixType&, bool) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; bool IsComplex = true]'
..\Eigen/src/Eigenvalues/ComplexSchur.h:334:94:   required from 'Eigen::ComplexSchur<MatrixType>& Eigen::ComplexSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Eigenvalues/ComplexEigenSolver.h:270:3:   required from 'Eigen::ComplexEigenSolver<MatrixType>& Eigen::ComplexEigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Eigenvalues/ComplexEigenSolver.h:134:14:   required from 'Eigen::ComplexEigenSolver<_MatrixType>::ComplexEigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:954:54:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> >; Src = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> >; Src = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> >; Src = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Derived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/GeneralProduct.h:268:50:   required from 'static void Eigen::internal::gemv_dense_selector<2, 0, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Dest = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; typename Dest::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/NoAlias.h:42:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, 0>; ExpressionType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:163:19:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheRight(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Eigen::MatrixBase<Derived>::Scalar = double]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:317:5:   required from 'static void Eigen::HessenbergDecomposition<_MatrixType>::_compute(Eigen::HessenbergDecomposition<_MatrixType>::MatrixType&, Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType&, Eigen::HessenbergDecomposition<_MatrixType>::VectorType&) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType = Eigen::Matrix<double, -1, 1>; typename _MatrixType::Scalar = double; Eigen::HessenbergDecomposition<_MatrixType>::VectorType = Eigen::Matrix<double, 1, -1>]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:161:15:   required from 'Eigen::HessenbergDecomposition<_MatrixType>& Eigen::HessenbergDecomposition<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&) [with InputType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:271:3:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> >; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 2, Eigen::Stride<0, 0> >; Derived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/GeneralProduct.h:284:16:   required from 'static void Eigen::internal::gemv_dense_selector<2, 0, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Dest = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; typename Dest::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/NoAlias.h:42:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>, -1, -1, false>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>, 0>; ExpressionType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:163:19:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheRight(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, true>; Eigen::MatrixBase<Derived>::Scalar = double]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:317:5:   required from 'static void Eigen::HessenbergDecomposition<_MatrixType>::_compute(Eigen::HessenbergDecomposition<_MatrixType>::MatrixType&, Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType&, Eigen::HessenbergDecomposition<_MatrixType>::VectorType&) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType = Eigen::Matrix<double, -1, 1>; typename _MatrixType::Scalar = double; Eigen::HessenbergDecomposition<_MatrixType>::VectorType = Eigen::Matrix<double, 1, -1>]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:161:15:   required from 'Eigen::HessenbergDecomposition<_MatrixType>& Eigen::HessenbergDecomposition<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&) [with InputType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:271:3:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::TriangularView<Eigen::Matrix<double, -1, -1>, 10> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::TriangularView<Eigen::Matrix<double, -1, -1>, 10> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/TriangularMatrix.h:736:7:   required from 'class Eigen::internal::triangular_dense_assignment_kernel<2, 8, 0, Eigen::internal::evaluator<Eigen::TriangularView<Eigen::Matrix<double, -1, -1>, 10> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/TriangularMatrix.h:799:10:   required from 'void Eigen::internal::call_triangular_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with int Mode = 10; bool SetOpposite = false; DstXprType = Eigen::TriangularView<Eigen::Matrix<double, -1, -1>, 10>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/TriangularMatrix.h:847:61:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Triangular>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::TriangularView<Eigen::Matrix<double, -1, -1>, 10>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::TriangularView<Eigen::Matrix<double, -1, -1>, 10>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/TriangularMatrix.h:560:37:   required from 'Eigen::TriangularView<MatrixType, _Mode>& Eigen::TriangularViewImpl<_MatrixType, _Mode, Eigen::Dense>::operator=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; _MatrixType = Eigen::Matrix<double, -1, -1>; unsigned int _Mode = 10]'
..\Eigen/src/Core/TriangularMatrix.h:394:20:   required from 'Eigen::TriangularViewImpl<_MatrixType, _Mode, Eigen::Dense>::TriangularViewType& Eigen::TriangularViewImpl<_MatrixType, _Mode, Eigen::Dense>::setConstant(const Scalar&) [with _MatrixType = Eigen::Matrix<double, -1, -1>; unsigned int _Mode = 10; Eigen::TriangularViewImpl<_MatrixType, _Mode, Eigen::Dense>::TriangularViewType = Eigen::TriangularView<Eigen::Matrix<double, -1, -1>, 10>; Eigen::TriangularViewImpl<_MatrixType, _Mode, Eigen::Dense>::Scalar = double]'
..\Eigen/src/Core/TriangularMatrix.h:397:55:   required from 'Eigen::TriangularViewImpl<_MatrixType, _Mode, Eigen::Dense>::TriangularViewType& Eigen::TriangularViewImpl<_MatrixType, _Mode, Eigen::Dense>::setZero() [with _MatrixType = Eigen::Matrix<double, -1, -1>; unsigned int _Mode = 10; Eigen::TriangularViewImpl<_MatrixType, _Mode, Eigen::Dense>::TriangularViewType = Eigen::TriangularView<Eigen::Matrix<double, -1, -1>, 10>]'
..\Eigen/src/Householder/HouseholderSequence.h:250:9:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::evalTo(Dest&, Workspace&) const [with Dest = Eigen::Matrix<double, -1, -1>; Workspace = Eigen::Matrix<double, -1, 1>; VectorsType = Eigen::Matrix<double, -1, -1>; CoeffsType = Eigen::Matrix<double, -1, 1>; int Side = 1]'
..\Eigen/src/Householder/HouseholderSequence.h:237:13:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::evalTo(DestType&) const [with DestType = Eigen::Matrix<double, -1, -1>; VectorsType = Eigen::Matrix<double, -1, -1>; CoeffsType = Eigen::Matrix<double, -1, 1>; int Side = 1]'
..\Eigen/src/Core/AssignEvaluator.h:932:3:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::EigenBase2EigenBase, Weak>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<typename DstXprType::Scalar, typename SrcXprType::Scalar>&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; Functor = Eigen::internal::assign_op<double, double>; Weak = void; typename SrcXprType::Scalar = double; typename DstXprType::Scalar = double]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>]'
..\Eigen/src/Core/Assign.h:75:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:571:22:   required from 'Derived& Eigen::PlainObjectBase<Derived>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:238:29:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Eigenvalues/RealSchur.h:288:12:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::computeFromHessenberg(const HessMatrixType&, const OrthMatrixType&, bool) [with HessMatrixType = Eigen::internal::HessenbergDecompositionMatrixHReturnType<Eigen::Matrix<double, -1, -1> >; OrthMatrixType = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:274:24:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, 1> >; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, 1> >; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, 1> >; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, 1> >; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, 1> >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, 1> >; Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, 1> >; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Core/CwiseNullaryOp.h:327:20:   required from 'Derived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>; Eigen::DenseBase<Derived>::Scalar = std::complex<long long int>]'
..\Eigen/src/Core/CwiseNullaryOp.h:501:21:   required from 'Derived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\Eigen/src/Core/ProductEvaluators.h:349:5:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; Derived = Eigen::internal::generic_product_impl<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; int Options = 0; Scalar = std::complex<long long int>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\binary_library.cpp:428:18:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 1, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 1, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 1, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 1, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 1, Eigen::Stride<0, 0> >; Src = Eigen::Matrix<std::complex<long long int>, -1, 1>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 1, Eigen::Stride<0, 0> >; Src = Eigen::Matrix<std::complex<long long int>, -1, 1>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 1, Eigen::Stride<0, 0> >; Src = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<std::complex<long long int>, -1, 1>; Derived = Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 1, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/GeneralProduct.h:268:50:   required from 'static void Eigen::internal::gemv_dense_selector<2, 0, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; Dest = Eigen::Matrix<std::complex<long long int>, -1, 1>; typename Dest::Scalar = std::complex<long long int>]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<std::complex<long long int>, -1, 1>; Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = std::complex<long long int>]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; Derived = Eigen::internal::generic_product_impl<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = std::complex<long long int>]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; Derived = Eigen::internal::generic_product_impl<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; int Options = 0; Scalar = std::complex<long long int>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\binary_library.cpp:428:18:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, 1, -1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, 1, -1> > >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, 1, -1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, 1, -1> > >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, 1, -1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, 1, -1> >; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, 1, -1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, 1, -1> >; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, 1, -1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, 1, -1> >; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, 1, -1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, 1, -1> >; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<long long int>, 1, -1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, 1, -1> >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, 1, -1> >; Derived = Eigen::Matrix<std::complex<long long int>, 1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, 1, -1> >; _Scalar = std::complex<long long int>; int _Rows = 1; int _Cols = -1; int _Options = 1; int _MaxRows = 1; int _MaxCols = -1]'
..\Eigen/src/Core/CwiseNullaryOp.h:327:20:   required from 'Derived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Matrix<std::complex<long long int>, 1, -1>; Eigen::DenseBase<Derived>::Scalar = std::complex<long long int>]'
..\Eigen/src/Core/CwiseNullaryOp.h:501:21:   required from 'Derived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Matrix<std::complex<long long int>, 1, -1>]'
..\Eigen/src/Core/ProductEvaluators.h:349:5:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<long long int>, 1, -1>; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >; Rhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Derived = Eigen::internal::generic_product_impl<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, 1, -1>; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >; Rhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; int Options = 0; Scalar = std::complex<long long int>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, 1, -1>; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, 1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, 1, -1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; _Scalar = std::complex<long long int>; int _Rows = 1; int _Cols = -1; int _Options = 1; int _MaxRows = 1; int _MaxCols = -1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, 1, -1>; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<long long int>, 1, -1>; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, 1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; _Scalar = std::complex<long long int>; int _Rows = 1; int _Cols = -1; int _Options = 1; int _MaxRows = 1; int _MaxCols = -1]'
..\binary_library.cpp:436:23:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Matrix<std::complex<long long int>, -1, 1>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Matrix<std::complex<long long int>, -1, 1>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<std::complex<long long int>, -1, 1>; Derived = Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/GeneralProduct.h:328:87:   required from 'static void Eigen::internal::gemv_dense_selector<2, 1, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; Dest = Eigen::Matrix<std::complex<long long int>, -1, 1>; typename Dest::Scalar = std::complex<long long int>]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<std::complex<long long int>, -1, 1>; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = std::complex<long long int>]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; Derived = Eigen::internal::generic_product_impl<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, 1>, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = std::complex<long long int>]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; Derived = Eigen::internal::generic_product_impl<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, 1>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; int Options = 0; Scalar = std::complex<long long int>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\binary_library.cpp:443:26:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1> > >, Eigen::internal::assign_op<long long int, long long int> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1> > >, Eigen::internal::assign_op<long long int, long long int>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >; Functor = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >; Functor = Eigen::internal::assign_op<long long int, long long int>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >; Func = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >; Func = Eigen::internal::assign_op<long long int, long long int>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >; Derived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >; _Scalar = long long int; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Core/CwiseNullaryOp.h:327:20:   required from 'Derived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Eigen::DenseBase<Derived>::Scalar = long long int]'
..\Eigen/src/Core/CwiseNullaryOp.h:501:21:   required from 'Derived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>]'
..\Eigen/src/Core/ProductEvaluators.h:349:5:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Lhs = Eigen::Matrix<long long int, -1, -1>; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Derived = Eigen::internal::generic_product_impl<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Lhs = Eigen::Matrix<long long int, -1, -1>; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; int Options = 0; Scalar = long long int; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Func = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Derived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; OtherDerived = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Derived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; _Scalar = long long int; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Func = Eigen::internal::assign_op<long long int, long long int>; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Derived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; _Scalar = long long int; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\binary_library.cpp:517:24:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 1, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, Eigen::internal::assign_op<long long int, long long int> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 1, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, Eigen::internal::assign_op<long long int, long long int>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 1, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Functor = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 1, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Functor = Eigen::internal::assign_op<long long int, long long int>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 1, Eigen::Stride<0, 0> >; Src = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Func = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 1, Eigen::Stride<0, 0> >; Src = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Func = Eigen::internal::assign_op<long long int, long long int>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 1, Eigen::Stride<0, 0> >; Src = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Derived = Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 1, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/GeneralProduct.h:268:50:   required from 'static void Eigen::internal::gemv_dense_selector<2, 0, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Matrix<long long int, -1, -1>; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Dest = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; typename Dest::Scalar = long long int]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Lhs = Eigen::Matrix<long long int, -1, -1>; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = long long int]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Lhs = Eigen::Matrix<long long int, -1, -1>; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Derived = Eigen::internal::generic_product_impl<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = long long int]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Lhs = Eigen::Matrix<long long int, -1, -1>; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Derived = Eigen::internal::generic_product_impl<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Lhs = Eigen::Matrix<long long int, -1, -1>; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; int Options = 0; Scalar = long long int; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Func = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Derived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; OtherDerived = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Derived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; _Scalar = long long int; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Func = Eigen::internal::assign_op<long long int, long long int>; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Derived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; _Scalar = long long int; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\binary_library.cpp:517:24:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, Eigen::internal::assign_op<long long int, long long int> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, Eigen::internal::assign_op<long long int, long long int>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Functor = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Functor = Eigen::internal::assign_op<long long int, long long int>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Func = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Func = Eigen::internal::assign_op<long long int, long long int>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Derived = Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/GeneralProduct.h:328:87:   required from 'static void Eigen::internal::gemv_dense_selector<2, 1, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Transpose<const Eigen::Matrix<long long int, -1, -1> >; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Dest = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; typename Dest::Scalar = long long int]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Lhs = Eigen::Transpose<const Eigen::Matrix<long long int, -1, -1> >; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = long long int]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Lhs = Eigen::Transpose<const Eigen::Matrix<long long int, -1, -1> >; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Derived = Eigen::internal::generic_product_impl<Eigen::Transpose<const Eigen::Matrix<long long int, -1, -1> >, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = long long int]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Lhs = Eigen::Transpose<const Eigen::Matrix<long long int, -1, -1> >; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Derived = Eigen::internal::generic_product_impl<Eigen::Transpose<const Eigen::Matrix<long long int, -1, -1> >, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Lhs = Eigen::Transpose<const Eigen::Matrix<long long int, -1, -1> >; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; int Options = 0; Scalar = long long int; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Transpose<const Eigen::Matrix<long long int, -1, -1> >, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::Product<Eigen::Transpose<const Eigen::Matrix<long long int, -1, -1> >, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Func = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Transpose<const Eigen::Matrix<long long int, -1, -1> >, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Derived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Transpose<const Eigen::Matrix<long long int, -1, -1> >, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; OtherDerived = Eigen::Product<Eigen::Transpose<const Eigen::Matrix<long long int, -1, -1> >, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Derived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Transpose<const Eigen::Matrix<long long int, -1, -1> >, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; _Scalar = long long int; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::Product<Eigen::Transpose<const Eigen::Matrix<long long int, -1, -1> >, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Func = Eigen::internal::assign_op<long long int, long long int>; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::Product<Eigen::Transpose<const Eigen::Matrix<long long int, -1, -1> >, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Transpose<const Eigen::Matrix<long long int, -1, -1> >, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Derived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Transpose<const Eigen::Matrix<long long int, -1, -1> >, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; _Scalar = long long int; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\binary_library.cpp:518:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > >; Derived = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/GeneralProduct.h:328:87:   required from 'static void Eigen::internal::gemv_dense_selector<2, 1, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false> >; Rhs = Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > > >; Dest = Eigen::Transpose<Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> > >; typename Dest::Scalar = std::complex<float>]'
..\Eigen/src/Core/GeneralProduct.h:192:12:   required from 'static void Eigen::internal::gemv_dense_selector<1, StorageOrder, BlasCompatible>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Dest = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; int StorageOrder = 0; bool BlasCompatible = true; typename Dest::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > >, Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > >, Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > >, Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > >, Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/NoAlias.h:42:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> > >, Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 0>; ExpressionType = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:126:19:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheLeft(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false>; Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Householder/HouseholderSequence.h:258:13:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::evalTo(Dest&, Workspace&) const [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Workspace = Eigen::Matrix<std::complex<float>, 1, -1>; VectorsType = Eigen::Matrix<std::complex<float>, -1, -1>; CoeffsType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; int Side = 1]'
..\Eigen/src/SVD/JacobiSVD.h:233:30:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1> >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1> >; Derived = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1> >; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 1; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/CwiseNullaryOp.h:327:20:   required from 'Derived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; Eigen::DenseBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/CwiseNullaryOp.h:501:21:   required from 'Derived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:434:7:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; Lhs = Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; Lhs = Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; Src = Eigen::Product<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 0>; Derived = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 0>; OtherDerived = Eigen::Product<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 0>; Derived = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 0>; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 1; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Product<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Product<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 0>; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Product<Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<std::complex<float> >, const Eigen::ArrayWrapper<const Eigen::Matrix<std::complex<float>, -1, 1> > > > >, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<float>, -1, -1> > >, 0>; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:1006:32:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> > > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> > > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> > >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> > >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> > >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> > >; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> > >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> > >; Derived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/GeneralProduct.h:328:87:   required from 'static void Eigen::internal::gemv_dense_selector<2, 1, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false> >; Rhs = Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> > >; Dest = Eigen::Transpose<Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> > >; typename Dest::Scalar = double]'
..\Eigen/src/Core/GeneralProduct.h:192:12:   required from 'static void Eigen::internal::gemv_dense_selector<1, StorageOrder, BlasCompatible>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>; Dest = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; int StorageOrder = 0; bool BlasCompatible = true; typename Dest::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/NoAlias.h:42:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>, 0>; ExpressionType = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:126:19:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheLeft(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::VectorBlock<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1>; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = double]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:313:5:   required from 'static void Eigen::HessenbergDecomposition<_MatrixType>::_compute(Eigen::HessenbergDecomposition<_MatrixType>::MatrixType&, Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType&, Eigen::HessenbergDecomposition<_MatrixType>::VectorType&) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::HessenbergDecomposition<_MatrixType>::CoeffVectorType = Eigen::Matrix<double, -1, 1>; typename _MatrixType::Scalar = double; Eigen::HessenbergDecomposition<_MatrixType>::VectorType = Eigen::Matrix<double, 1, -1>]'
..\Eigen/src/Eigenvalues/./HessenbergDecomposition.h:161:15:   required from 'Eigen::HessenbergDecomposition<_MatrixType>& Eigen::HessenbergDecomposition<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&) [with InputType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::Matrix<double, -1, -1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, -1> > >; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:271:3:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 1, Eigen::Stride<0, 0> > >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, 1> >, Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 1, Eigen::Stride<0, 0> > >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; SrcXprType = Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 1, Eigen::Stride<0, 0> >; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; SrcXprType = Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 1, Eigen::Stride<0, 0> >; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 1, Eigen::Stride<0, 0> >; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 1, Eigen::Stride<0, 0> >; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 1, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 1, Eigen::Stride<0, 0> >; Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 1, Eigen::Stride<0, 0> >; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Core/GeneralProduct.h:284:16:   required from 'static void Eigen::internal::gemv_dense_selector<2, 0, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; Dest = Eigen::Matrix<std::complex<long long int>, -1, 1>; typename Dest::Scalar = std::complex<long long int>]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<std::complex<long long int>, -1, 1>; Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = std::complex<long long int>]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; Derived = Eigen::internal::generic_product_impl<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = std::complex<long long int>]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; Derived = Eigen::internal::generic_product_impl<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; int Options = 0; Scalar = std::complex<long long int>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\binary_library.cpp:428:18:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Transpose<const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > > >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Transpose<const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > > >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Transpose<const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Transpose<const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Transpose<const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Transpose<const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Transpose<const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Transpose<const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >; Derived = Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/GeneralProduct.h:328:87:   required from 'static void Eigen::internal::gemv_dense_selector<2, 1, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> >; Rhs = Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > > >; Dest = Eigen::Transpose<Eigen::Matrix<std::complex<long long int>, 1, -1> >; typename Dest::Scalar = std::complex<long long int>]'
..\Eigen/src/Core/GeneralProduct.h:192:12:   required from 'static void Eigen::internal::gemv_dense_selector<1, StorageOrder, BlasCompatible>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >; Rhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Dest = Eigen::Matrix<std::complex<long long int>, 1, -1>; int StorageOrder = 0; bool BlasCompatible = true; typename Dest::Scalar = std::complex<long long int>]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<std::complex<long long int>, 1, -1>; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >; Rhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = std::complex<long long int>]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Matrix<std::complex<long long int>, 1, -1>; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >; Rhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Derived = Eigen::internal::generic_product_impl<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = std::complex<long long int>]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<long long int>, 1, -1>; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >; Rhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Derived = Eigen::internal::generic_product_impl<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, 1, -1>; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >; Rhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; int Options = 0; Scalar = std::complex<long long int>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, 1, -1>; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, 1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, 1, -1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; _Scalar = std::complex<long long int>; int _Rows = 1; int _Cols = -1; int _Options = 1; int _MaxRows = 1; int _MaxCols = -1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, 1, -1>; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<long long int>, 1, -1>; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, 1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; _Scalar = std::complex<long long int>; int _Rows = 1; int _Cols = -1; int _Options = 1; int _MaxRows = 1; int _MaxCols = -1]'
..\binary_library.cpp:436:23:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 1, Eigen::Stride<0, 0> > >, Eigen::internal::assign_op<long long int, long long int> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >, Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 1, Eigen::Stride<0, 0> > >, Eigen::internal::assign_op<long long int, long long int>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; SrcXprType = Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 1, Eigen::Stride<0, 0> >; Functor = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; SrcXprType = Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 1, Eigen::Stride<0, 0> >; Functor = Eigen::internal::assign_op<long long int, long long int>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 1, Eigen::Stride<0, 0> >; Func = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 1, Eigen::Stride<0, 0> >; Func = Eigen::internal::assign_op<long long int, long long int>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 1, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 1, Eigen::Stride<0, 0> >; Derived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 1, Eigen::Stride<0, 0> >; _Scalar = long long int; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Core/GeneralProduct.h:284:16:   required from 'static void Eigen::internal::gemv_dense_selector<2, 0, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Matrix<long long int, -1, -1>; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Dest = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; typename Dest::Scalar = long long int]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Lhs = Eigen::Matrix<long long int, -1, -1>; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = long long int]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Lhs = Eigen::Matrix<long long int, -1, -1>; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Derived = Eigen::internal::generic_product_impl<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = long long int]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Lhs = Eigen::Matrix<long long int, -1, -1>; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Derived = Eigen::internal::generic_product_impl<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Lhs = Eigen::Matrix<long long int, -1, -1>; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; int Options = 0; Scalar = long long int; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Func = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Derived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; OtherDerived = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Derived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; _Scalar = long long int; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Func = Eigen::internal::assign_op<long long int, long long int>; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Derived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; _Scalar = long long int; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\binary_library.cpp:517:24:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > >; Derived = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/GeneralProduct.h:328:87:   required from 'static void Eigen::internal::gemv_dense_selector<2, 1, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false> >; Rhs = Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > > >; Dest = Eigen::Transpose<Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> > >; typename Dest::Scalar = std::complex<float>]'
..\Eigen/src/Core/GeneralProduct.h:192:12:   required from 'static void Eigen::internal::gemv_dense_selector<1, StorageOrder, BlasCompatible>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Dest = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; int StorageOrder = 0; bool BlasCompatible = true; typename Dest::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > >, Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > >, Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > >, Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > >, Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/NoAlias.h:42:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1, 1, false> > >, Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 0>; ExpressionType = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:126:19:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheLeft(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::VectorBlock<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, true>, -1>; Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/QR/ColPivHouseholderQR.h:547:5:   required from 'void Eigen::ColPivHouseholderQR<MatrixType>::computeInPlace() [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/QR/ColPivHouseholderQR.h:475:17:   required from 'Eigen::ColPivHouseholderQR<_MatrixType>& Eigen::ColPivHouseholderQR<MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&) [with InputType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:230:7:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> >; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> >; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> >; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> >; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> >; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, 1> >; Derived = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/CwiseNullaryOp.h:327:20:   required from 'Derived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> >; Eigen::DenseBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/CwiseNullaryOp.h:501:21:   required from 'Derived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/GeneralProduct.h:264:11:   required from 'static void Eigen::internal::gemv_dense_selector<2, 0, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; Dest = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; typename Dest::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/NoAlias.h:42:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false> >, 0>; ExpressionType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:163:19:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheRight(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, 1, false>; Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Householder/HouseholderSequence.h:255:13:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::evalTo(Dest&, Workspace&) const [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Workspace = Eigen::Matrix<std::complex<float>, 1, -1>; VectorsType = Eigen::Matrix<std::complex<float>, -1, -1>; CoeffsType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; int Side = 1]'
..\Eigen/src/SVD/JacobiSVD.h:233:30:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > >; Derived = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/products/TriangularMatrixVector.h:316:87:   required from 'static void Eigen::internal::trmv_selector<Mode, 1>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Transpose<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false> >; Rhs = Eigen::Transpose<const Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > > >; Dest = Eigen::Transpose<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false> >; int Mode = 6; typename Dest::Scalar = std::complex<float>]'
..\Eigen/src/Core/products/TriangularMatrixVector.h:194:18:   required from 'static void Eigen::internal::triangular_product_impl<Mode, false, Lhs, true, Rhs, false>::run(Dest&, const Lhs&, const Rhs&, const typename Dest::Scalar&) [with Dest = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; int Mode = 5; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >; Rhs = const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; typename Dest::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:725:113:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::TriangularShape, ProductTag>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >; Rhs = Eigen::TriangularView<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 5>; int ProductTag = 7; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::TriangularShape, ProductTag>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >; Rhs = Eigen::TriangularView<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 5>; Derived = Eigen::internal::generic_product_impl<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >, Eigen::TriangularView<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 5>, Eigen::DenseShape, Eigen::TriangularShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >; Rhs = Eigen::TriangularView<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 5>; Derived = Eigen::internal::generic_product_impl<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >, Eigen::TriangularView<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 5>, Eigen::DenseShape, Eigen::TriangularShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >; Rhs = Eigen::TriangularView<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 5>; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >, Eigen::TriangularView<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 5>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Src = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >, Eigen::TriangularView<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 5>, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/NoAlias.h:42:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, 1, -1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, 1, true>, -1, 1, false> > > >, Eigen::TriangularView<const Eigen::Block<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 5>, 0>; ExpressionType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/BlockHouseholder.h:63:43:   required from 'void Eigen::internal::make_block_householder_triangular_factor(TriangularFactorType&, const VectorsType&, const CoeffsType&) [with TriangularFactorType = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; VectorsType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; CoeffsType = Eigen::VectorBlock<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, -1>]'
..\Eigen/src/Householder/BlockHouseholder.h:85:55:   required from 'void Eigen::internal::apply_block_householder_on_the_left(MatrixType&, const VectorsType&, const CoeffsType&, bool) [with MatrixType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; VectorsType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; CoeffsType = Eigen::VectorBlock<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, -1>]'
..\Eigen/src/Householder/HouseholderSequence.h:333:46:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::applyThisOnTheLeft(Dest&, Workspace&) const [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Workspace = Eigen::Matrix<std::complex<float>, 1, -1>; VectorsType = Eigen::Matrix<std::complex<float>, -1, -1>; CoeffsType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; int Side = 1]'
..\Eigen/src/SVD/JacobiSVD.h:237:9:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Diagonal<Eigen::Matrix<double, -1, -1>, 0> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Diagonal<Eigen::Matrix<double, -1, -1>, 0> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Diagonal<Eigen::Matrix<double, -1, -1>, 0>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Diagonal<Eigen::Matrix<double, -1, -1>, 0>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Diagonal<Eigen::Matrix<double, -1, -1>, 0>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Diagonal<Eigen::Matrix<double, -1, -1>, 0>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Diagonal<Eigen::Matrix<double, -1, -1>, 0>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Derived = Eigen::Diagonal<Eigen::Matrix<double, -1, -1>, 0>]'
..\Eigen/src/Core/CwiseNullaryOp.h:327:20:   required from 'Derived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Diagonal<Eigen::Matrix<double, -1, -1>, 0>; Eigen::DenseBase<Derived>::Scalar = double]'
..\Eigen/src/Core/CwiseNullaryOp.h:627:21:   required from 'Derived& Eigen::DenseBase<Derived>::setOnes() [with Derived = Eigen::Diagonal<Eigen::Matrix<double, -1, -1>, 0>]'
..\Eigen/src/Householder/HouseholderSequence.h:249:9:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::evalTo(Dest&, Workspace&) const [with Dest = Eigen::Matrix<double, -1, -1>; Workspace = Eigen::Matrix<double, -1, 1>; VectorsType = Eigen::Matrix<double, -1, -1>; CoeffsType = Eigen::Matrix<double, -1, 1>; int Side = 1]'
..\Eigen/src/Householder/HouseholderSequence.h:237:13:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::evalTo(DestType&) const [with DestType = Eigen::Matrix<double, -1, -1>; VectorsType = Eigen::Matrix<double, -1, -1>; CoeffsType = Eigen::Matrix<double, -1, 1>; int Side = 1]'
..\Eigen/src/Core/AssignEvaluator.h:932:3:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::EigenBase2EigenBase, Weak>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<typename DstXprType::Scalar, typename SrcXprType::Scalar>&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; Functor = Eigen::internal::assign_op<double, double>; Weak = void; typename SrcXprType::Scalar = double; typename DstXprType::Scalar = double]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>]'
..\Eigen/src/Core/Assign.h:75:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:571:22:   required from 'Derived& Eigen::PlainObjectBase<Derived>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:238:29:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Eigenvalues/RealSchur.h:288:12:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::computeFromHessenberg(const HessMatrixType&, const OrthMatrixType&, bool) [with HessMatrixType = Eigen::internal::HessenbergDecompositionMatrixHReturnType<Eigen::Matrix<double, -1, -1> >; OrthMatrixType = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:274:24:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>]'
..\Eigen/src/Core/CwiseNullaryOp.h:327:20:   required from 'Derived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>; Eigen::DenseBase<Derived>::Scalar = double]'
..\Eigen/src/Core/CwiseNullaryOp.h:501:21:   required from 'Derived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, 1, true>, -1, 1, false>]'
..\Eigen/src/Householder/HouseholderSequence.h:262:11:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::evalTo(Dest&, Workspace&) const [with Dest = Eigen::Matrix<double, -1, -1>; Workspace = Eigen::Matrix<double, -1, 1>; VectorsType = Eigen::Matrix<double, -1, -1>; CoeffsType = Eigen::Matrix<double, -1, 1>; int Side = 1]'
..\Eigen/src/Householder/HouseholderSequence.h:237:13:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::evalTo(DestType&) const [with DestType = Eigen::Matrix<double, -1, -1>; VectorsType = Eigen::Matrix<double, -1, -1>; CoeffsType = Eigen::Matrix<double, -1, 1>; int Side = 1]'
..\Eigen/src/Core/AssignEvaluator.h:932:3:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::EigenBase2EigenBase, Weak>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<typename DstXprType::Scalar, typename SrcXprType::Scalar>&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; Functor = Eigen::internal::assign_op<double, double>; Weak = void; typename SrcXprType::Scalar = double; typename DstXprType::Scalar = double]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>]'
..\Eigen/src/Core/Assign.h:75:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:571:22:   required from 'Derived& Eigen::PlainObjectBase<Derived>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:238:29:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Eigenvalues/RealSchur.h:288:12:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::computeFromHessenberg(const HessMatrixType&, const OrthMatrixType&, bool) [with HessMatrixType = Eigen::internal::HessenbergDecompositionMatrixHReturnType<Eigen::Matrix<double, -1, -1> >; OrthMatrixType = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:274:24:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, 2, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> >, const Eigen::Matrix<double, 2, 1> > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, 2, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> >, const Eigen::Matrix<double, 2, 1> > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, 2, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> >, const Eigen::Matrix<double, 2, 1> >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, 2, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> >, const Eigen::Matrix<double, 2, 1> >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, 2, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> >, const Eigen::Matrix<double, 2, 1> >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> >, const Eigen::Matrix<double, 2, 1> >; Derived = Eigen::Matrix<double, 2, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> >, const Eigen::Matrix<double, 2, 1> >; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> >, const Eigen::Matrix<double, 2, 1> >; Derived = Eigen::Matrix<double, 2, 1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> >, const Eigen::Matrix<double, 2, 1> >; _Scalar = double; int _Rows = 2; int _Cols = 1; int _Options = 0; int _MaxRows = 2; int _MaxCols = 1]'
..\Eigen/src/Core/ProductEvaluators.h:451:34:   required from 'Eigen::internal::product_evaluator<Eigen::Product<Lhs, Rhs, 1>, ProductTag, Eigen::DenseShape, Eigen::DenseShape>::product_evaluator(const XprType&) [with Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> >, const Eigen::Matrix<double, 2, 1> >; Rhs = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; int ProductTag = 4; typename Eigen::internal::traits<typename Eigen::Product<Lhs, Rhs, 1>::Rhs>::Scalar = double; typename Eigen::internal::traits<typename Eigen::Product<Lhs, Rhs, 1>::Lhs>::Scalar = double; Eigen::internal::product_evaluator<Eigen::Product<Lhs, Rhs, 1>, ProductTag, Eigen::DenseShape, Eigen::DenseShape>::XprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> >, const Eigen::Matrix<double, 2, 1> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 1>]'
..\Eigen/src/Core/ProductEvaluators.h:35:70:   required from 'Eigen::internal::evaluator<Eigen::Product<Lhs, Rhs, Option> >::evaluator(const XprType&) [with Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> >, const Eigen::Matrix<double, 2, 1> >; Rhs = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; int Options = 1; Eigen::internal::evaluator<Eigen::Product<Lhs, Rhs, Option> >::XprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> >, const Eigen::Matrix<double, 2, 1> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 1>]'
..\Eigen/src/Core/AssignEvaluator.h:753:19:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 2, -1, false>; SrcXprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> >, const Eigen::Matrix<double, 2, 1> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 1>; Functor = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 2, -1, false>; SrcXprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> >, const Eigen::Matrix<double, 2, 1> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 1>; Functor = Eigen::internal::sub_assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 2, -1, false>; Src = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> >, const Eigen::Matrix<double, 2, 1> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 1>; Func = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/ProductEvaluators.h:411:29:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 3>::subTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 2, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> >, const Eigen::Matrix<double, 2, 1> >; Rhs = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/ProductEvaluators.h:178:42:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::sub_assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 2, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> >, const Eigen::Matrix<double, 2, 1> >; Rhs = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> >, const Eigen::Matrix<double, 2, 1> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 2, -1, false>; Src = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> >, const Eigen::Matrix<double, 2, 1> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 0>; Func = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/NoAlias.h:58:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator-=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 2, 1> >, const Eigen::Matrix<double, 2, 1> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 0>; ExpressionType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 2, -1, false>; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:129:22:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheLeft(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Matrix<double, 2, 1>; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:514:7:   required from 'void Eigen::RealSchur<_MatrixType>::performFrancisQRStep(Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, bool, const Vector3s&, Eigen::RealSchur<_MatrixType>::Scalar*) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::RealSchur<_MatrixType>::Index = long long int; Eigen::RealSchur<_MatrixType>::Vector3s = Eigen::Matrix<double, 3, 1>; typename MatrixType::Scalar = double; Eigen::RealSchur<_MatrixType>::Scalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:337:29:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::computeFromHessenberg(const HessMatrixType&, const OrthMatrixType&, bool) [with HessMatrixType = Eigen::internal::HessenbergDecompositionMatrixHReturnType<Eigen::Matrix<double, -1, -1> >; OrthMatrixType = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:274:24:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, 1, 1, 0, 1, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, 1, 1, 0, 1, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, 1, 1, 0, 1, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, 1, 1, 0, 1, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, 1, 1, 0, 1, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >; Derived = Eigen::Matrix<double, 1, 1, 0, 1, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >; Derived = Eigen::Matrix<double, 1, 1, 0, 1, 1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >; _Scalar = double; int _Rows = 1; int _Cols = 1; int _Options = 0; int _MaxRows = 1; int _MaxCols = 1]'
..\Eigen/src/Core/ProductEvaluators.h:451:34:   required from 'Eigen::internal::product_evaluator<Eigen::Product<Lhs, Rhs, 1>, ProductTag, Eigen::DenseShape, Eigen::DenseShape>::product_evaluator(const XprType&) [with Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >; Rhs = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; int ProductTag = 4; typename Eigen::internal::traits<typename Eigen::Product<Lhs, Rhs, 1>::Rhs>::Scalar = double; typename Eigen::internal::traits<typename Eigen::Product<Lhs, Rhs, 1>::Lhs>::Scalar = double; Eigen::internal::product_evaluator<Eigen::Product<Lhs, Rhs, 1>, ProductTag, Eigen::DenseShape, Eigen::DenseShape>::XprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 1>]'
..\Eigen/src/Core/ProductEvaluators.h:35:70:   required from 'Eigen::internal::evaluator<Eigen::Product<Lhs, Rhs, Option> >::evaluator(const XprType&) [with Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >; Rhs = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; int Options = 1; Eigen::internal::evaluator<Eigen::Product<Lhs, Rhs, Option> >::XprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 1>]'
..\Eigen/src/Core/AssignEvaluator.h:753:19:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false>; SrcXprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 1>; Functor = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false>; SrcXprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 1>; Functor = Eigen::internal::sub_assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false>; Src = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 1>; Func = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/ProductEvaluators.h:411:29:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 3>::subTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >; Rhs = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/ProductEvaluators.h:178:42:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::sub_assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >; Rhs = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false>; Src = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 0>; Func = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/NoAlias.h:58:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator-=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 0>; ExpressionType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, 1, -1, false>; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:129:22:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheLeft(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Matrix<double, 1, 1, 0, 1, 1>; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:529:5:   required from 'void Eigen::RealSchur<_MatrixType>::performFrancisQRStep(Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, Eigen::RealSchur<_MatrixType>::Index, bool, const Vector3s&, Eigen::RealSchur<_MatrixType>::Scalar*) [with _MatrixType = Eigen::Matrix<double, -1, -1>; Eigen::RealSchur<_MatrixType>::Index = long long int; Eigen::RealSchur<_MatrixType>::Vector3s = Eigen::Matrix<double, 3, 1>; typename MatrixType::Scalar = double; Eigen::RealSchur<_MatrixType>::Scalar = double]'
..\Eigen/src/Eigenvalues/RealSchur.h:337:29:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::computeFromHessenberg(const HessMatrixType&, const OrthMatrixType&, bool) [with HessMatrixType = Eigen::internal::HessenbergDecompositionMatrixHReturnType<Eigen::Matrix<double, -1, -1> >; OrthMatrixType = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:274:24:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 1, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 1, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, 1> > >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 1, Eigen::Stride<0, 0> >; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, 1> >; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 1, Eigen::Stride<0, 0> >; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, 1> >; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 1, Eigen::Stride<0, 0> >; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, 1> >; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 1, Eigen::Stride<0, 0> >; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, 1> >; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 1, Eigen::Stride<0, 0> >; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, 1> >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<long long int> >, Eigen::Matrix<std::complex<long long int>, -1, 1> >; Derived = Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 1, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/CwiseNullaryOp.h:327:20:   required from 'Derived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 1, Eigen::Stride<0, 0> >; Eigen::DenseBase<Derived>::Scalar = std::complex<long long int>]'
..\Eigen/src/Core/CwiseNullaryOp.h:501:21:   required from 'Derived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Map<Eigen::Matrix<std::complex<long long int>, -1, 1>, 1, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/GeneralProduct.h:264:11:   required from 'static void Eigen::internal::gemv_dense_selector<2, 0, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; Dest = Eigen::Matrix<std::complex<long long int>, -1, 1>; typename Dest::Scalar = std::complex<long long int>]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<std::complex<long long int>, -1, 1>; Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = std::complex<long long int>]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; Derived = Eigen::internal::generic_product_impl<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = std::complex<long long int>]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; Derived = Eigen::internal::generic_product_impl<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, 1>; Lhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; Rhs = Eigen::Matrix<std::complex<long long int>, -1, 1>; int Options = 0; Scalar = std::complex<long long int>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, 1>; Src = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<std::complex<long long int>, -1, -1>, Eigen::Matrix<std::complex<long long int>, -1, 1>, 0>; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\binary_library.cpp:428:18:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 1, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1> > >, Eigen::internal::assign_op<long long int, long long int> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 1, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1> > >, Eigen::internal::assign_op<long long int, long long int>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 1, Eigen::Stride<0, 0> >; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >; Functor = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 1, Eigen::Stride<0, 0> >; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >; Functor = Eigen::internal::assign_op<long long int, long long int>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 1, Eigen::Stride<0, 0> >; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >; Func = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 1, Eigen::Stride<0, 0> >; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >; Func = Eigen::internal::assign_op<long long int, long long int>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 1, Eigen::Stride<0, 0> >; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<long long int>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1> >; Derived = Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 1, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/CwiseNullaryOp.h:327:20:   required from 'Derived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 1, Eigen::Stride<0, 0> >; Eigen::DenseBase<Derived>::Scalar = long long int]'
..\Eigen/src/Core/CwiseNullaryOp.h:501:21:   required from 'Derived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Map<Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 1, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/GeneralProduct.h:264:11:   required from 'static void Eigen::internal::gemv_dense_selector<2, 0, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Matrix<long long int, -1, -1>; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Dest = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; typename Dest::Scalar = long long int]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Lhs = Eigen::Matrix<long long int, -1, -1>; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = long long int]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Lhs = Eigen::Matrix<long long int, -1, -1>; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Derived = Eigen::internal::generic_product_impl<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = long long int]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Lhs = Eigen::Matrix<long long int, -1, -1>; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Derived = Eigen::internal::generic_product_impl<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Lhs = Eigen::Matrix<long long int, -1, -1>; Rhs = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; int Options = 0; Scalar = long long int; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Func = Eigen::internal::assign_op<long long int, long long int>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Derived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; OtherDerived = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Derived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; _Scalar = long long int; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Func = Eigen::internal::assign_op<long long int, long long int>; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>; Src = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; Derived = Eigen::Matrix<long long int, -1, 1, 0, -1, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<long long int, -1, -1>, Eigen::Matrix<long long int, -1, 1, 0, -1, 1>, 0>; _Scalar = long long int; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\binary_library.cpp:517:24:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
In file included from ..\Eigen/Core:473:0,
                 from ..\binary_library.cpp:18:
..\Eigen/src/Core/products/GeneralMatrixVector.h: In instantiation of 'static void Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 0, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::run(Index, Index, const LhsMapper&, const RhsMapper&, Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 0, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::ResScalar*, Index, RhsScalar) [with Index = long long int; LhsScalar = std::complex<float>; LhsMapper = Eigen::internal::const_blas_data_mapper<std::complex<float>, long long int, 0>; bool ConjugateLhs = false; RhsScalar = std::complex<float>; RhsMapper = Eigen::internal::const_blas_data_mapper<std::complex<float>, long long int, 1>; bool ConjugateRhs = false; int Version = 1; Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 0, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::ResScalar = std::complex<float>]':
..\Eigen/src/Core/products/TriangularMatrixVector.h:74:123:   required from 'static void Eigen::internal::triangular_matrix_vector_product<Index, Mode, LhsScalar, ConjLhs, RhsScalar, ConjRhs, 0, Version>::run(Index, Index, const LhsScalar*, Index, const RhsScalar*, Index, Eigen::internal::triangular_matrix_vector_product<Index, Mode, LhsScalar, ConjLhs, RhsScalar, ConjRhs, 0, Version>::ResScalar*, Index, const RhsScalar&) [with Index = long long int; int Mode = 1; LhsScalar = std::complex<float>; bool ConjLhs = false; RhsScalar = std::complex<float>; bool ConjRhs = false; int Version = 0; Eigen::internal::triangular_matrix_vector_product<Index, Mode, LhsScalar, ConjLhs, RhsScalar, ConjRhs, 0, Version>::ResScalar = std::complex<float>]'
..\Eigen/src/Core/products/TriangularMatrixVector.h:265:12:   required from 'static void Eigen::internal::trmv_selector<Mode, 0>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Transpose<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false> >; Rhs = Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false> >; Dest = Eigen::Transpose<Eigen::Matrix<std::complex<float>, 1, -1> >; int Mode = 1; typename Dest::Scalar = std::complex<float>]'
..\Eigen/src/Core/products/TriangularMatrixVector.h:194:18:   required from 'static void Eigen::internal::triangular_product_impl<Mode, false, Lhs, true, Rhs, false>::run(Dest&, const Lhs&, const Rhs&, const typename Dest::Scalar&) [with Dest = Eigen::Matrix<std::complex<float>, 1, -1>; int Mode = 2; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Rhs = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>; typename Dest::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:725:113:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::TriangularShape, ProductTag>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<std::complex<float>, 1, -1>; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Rhs = Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>; int ProductTag = 7; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::TriangularShape, ProductTag>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Matrix<std::complex<float>, 1, -1>; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Rhs = Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, Eigen::DenseShape, Eigen::TriangularShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<float>, 1, -1>; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Rhs = Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, Eigen::DenseShape, Eigen::TriangularShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<float>, 1, -1>; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Rhs = Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, 1, -1>; Src = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; Derived = Eigen::Matrix<std::complex<float>, 1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; OtherDerived = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; Derived = Eigen::Matrix<std::complex<float>, 1, -1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; _Scalar = std::complex<float>; int _Rows = 1; int _Cols = -1; int _Options = 1; int _MaxRows = 1; int _MaxCols = -1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Src = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Src = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>]'
..\Eigen/src/Householder/BlockHouseholder.h:67:33:   required from 'void Eigen::internal::make_block_householder_triangular_factor(TriangularFactorType&, const VectorsType&, const CoeffsType&) [with TriangularFactorType = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; VectorsType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; CoeffsType = Eigen::VectorBlock<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, -1>]'
..\Eigen/src/Householder/BlockHouseholder.h:85:55:   required from 'void Eigen::internal::apply_block_householder_on_the_left(MatrixType&, const VectorsType&, const CoeffsType&, bool) [with MatrixType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; VectorsType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; CoeffsType = Eigen::VectorBlock<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, -1>]'
..\Eigen/src/Householder/HouseholderSequence.h:333:46:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::applyThisOnTheLeft(Dest&, Workspace&) const [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Workspace = Eigen::Matrix<std::complex<float>, 1, -1>; VectorsType = Eigen::Matrix<std::complex<float>, -1, -1>; CoeffsType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; int Side = 1]'
..\Eigen/src/SVD/JacobiSVD.h:237:9:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/products/GeneralMatrixVector.h:186:39: warning: enum constant in boolean context [-Wint-in-bool-context]
   const Index offset1 = (FirstAligned && alignmentStep==1)?3:1;
                         ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/products/GeneralMatrixVector.h:187:39: warning: enum constant in boolean context [-Wint-in-bool-context]
   const Index offset3 = (FirstAligned && alignmentStep==1)?1:3;
                         ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from ..\Eigen/Core:420:0,
                 from ..\binary_library.cpp:18:
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Diagonal<Eigen::Matrix<std::complex<float>, 8, 8, 0, 8, 8>, 0> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 8, 1, 0, 8, 1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Diagonal<Eigen::Matrix<std::complex<float>, 8, 8, 0, 8, 8>, 0> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 8, 1, 0, 8, 1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Diagonal<Eigen::Matrix<std::complex<float>, 8, 8, 0, 8, 8>, 0>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 8, 1, 0, 8, 1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Diagonal<Eigen::Matrix<std::complex<float>, 8, 8, 0, 8, 8>, 0>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 8, 1, 0, 8, 1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Diagonal<Eigen::Matrix<std::complex<float>, 8, 8, 0, 8, 8>, 0>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 8, 1, 0, 8, 1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Diagonal<Eigen::Matrix<std::complex<float>, 8, 8, 0, 8, 8>, 0>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 8, 1, 0, 8, 1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Diagonal<Eigen::Matrix<std::complex<float>, 8, 8, 0, 8, 8>, 0>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 8, 1, 0, 8, 1> >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 8, 1, 0, 8, 1> >; Derived = Eigen::Diagonal<Eigen::Matrix<std::complex<float>, 8, 8, 0, 8, 8>, 0>]'
..\Eigen/src/Core/CwiseNullaryOp.h:327:20:   required from 'Derived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Diagonal<Eigen::Matrix<std::complex<float>, 8, 8, 0, 8, 8>, 0>; Eigen::DenseBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/CwiseNullaryOp.h:501:21:   required from 'Derived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Diagonal<Eigen::Matrix<std::complex<float>, 8, 8, 0, 8, 8>, 0>]'
..\Eigen/src/Core/products/TriangularMatrixMatrix.h:143:7:   required from 'static void Eigen::internal::product_triangular_matrix_matrix<Scalar, Index, Mode, true, LhsStorageOrder, ConjugateLhs, RhsStorageOrder, ConjugateRhs, 0, Version>::run(Index, Index, Index, const Scalar*, Index, const Scalar*, Index, Scalar*, Index, const Scalar&, Eigen::internal::level3_blocking<Scalar, Scalar>&) [with Scalar = std::complex<float>; Index = long long int; int Mode = 5; int LhsStorageOrder = 0; bool ConjugateLhs = false; int RhsStorageOrder = 0; bool ConjugateRhs = false; int Version = 0]'
..\Eigen/src/Core/products/TriangularMatrixMatrix.h:427:12:   required from 'static void Eigen::internal::triangular_product_impl<Mode, LhsIsTriangular, Lhs, false, Rhs, false>::run(Dest&, const Lhs&, const Rhs&, const typename Dest::Scalar&) [with Dest = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; int Mode = 5; bool LhsIsTriangular = true; Lhs = const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Rhs = Eigen::Matrix<std::complex<float>, -1, -1>; typename Dest::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:712:14:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::TriangularShape, Eigen::DenseShape, ProductTag>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Lhs = Eigen::TriangularView<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 5>; Rhs = Eigen::Matrix<std::complex<float>, -1, -1>; int ProductTag = 8; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::TriangularShape, Eigen::DenseShape, ProductTag>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Lhs = Eigen::TriangularView<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 5>; Rhs = Eigen::Matrix<std::complex<float>, -1, -1>; Derived = Eigen::internal::generic_product_impl<Eigen::TriangularView<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 5>, Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::TriangularShape, Eigen::DenseShape, 8>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:357:18:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::subTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Lhs = Eigen::TriangularView<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 5>; Rhs = Eigen::Matrix<std::complex<float>, -1, -1>; Derived = Eigen::internal::generic_product_impl<Eigen::TriangularView<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 5>, Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::TriangularShape, Eigen::DenseShape, 8>]'
..\Eigen/src/Core/ProductEvaluators.h:178:42:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::sub_assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Lhs = Eigen::TriangularView<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 5>; Rhs = Eigen::Matrix<std::complex<float>, -1, -1>; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::TriangularView<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 5>, Eigen::Matrix<std::complex<float>, -1, -1>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Src = Eigen::Product<Eigen::TriangularView<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 5>, Eigen::Matrix<std::complex<float>, -1, -1>, 0>; Func = Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/NoAlias.h:58:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator-=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::TriangularView<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 5>, Eigen::Matrix<std::complex<float>, -1, -1>, 0>; ExpressionType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/BlockHouseholder.h:96:17:   required from 'void Eigen::internal::apply_block_householder_on_the_left(MatrixType&, const VectorsType&, const CoeffsType&, bool) [with MatrixType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; VectorsType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; CoeffsType = Eigen::VectorBlock<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, -1>]'
..\Eigen/src/Householder/HouseholderSequence.h:333:46:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::applyThisOnTheLeft(Dest&, Workspace&) const [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Workspace = Eigen::Matrix<std::complex<float>, 1, -1>; VectorsType = Eigen::Matrix<std::complex<float>, -1, -1>; CoeffsType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; int Side = 1]'
..\Eigen/src/SVD/JacobiSVD.h:237:9:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>]'
..\Eigen/src/Core/CwiseNullaryOp.h:327:20:   required from 'Derived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Eigen::DenseBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/CwiseNullaryOp.h:501:21:   required from 'Derived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>]'
..\Eigen/src/QR/CompleteOrthogonalDecomposition.h:519:5:   required from 'void Eigen::CompleteOrthogonalDecomposition<MatrixType>::_solve_impl(const RhsType&, DstType&) const [with RhsType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; DstType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Solve.h:147:5:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Solve<DecType, RhsType>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; DecType = Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >; RhsType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Solve<DecType, RhsType>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense>::SrcXprType = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/QR/CompleteOrthogonalDecomposition.h:537:9:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<MatrixType> >, Eigen::internal::assign_op<typename DstXprType::Scalar, typename Eigen::CompleteOrthogonalDecomposition<MatrixType>::Scalar>, Eigen::internal::Dense2Dense>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<typename DstXprType::Scalar, typename Eigen::CompleteOrthogonalDecomposition<MatrixType>::Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; Eigen::internal::Assignment<DstXprType, Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<MatrixType> >, Eigen::internal::assign_op<typename DstXprType::Scalar, typename Eigen::CompleteOrthogonalDecomposition<MatrixType>::Scalar>, Eigen::internal::Dense2Dense>::SrcXprType = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >; typename Eigen::CompleteOrthogonalDecomposition<MatrixType>::Scalar = std::complex<float>; typename DstXprType::Scalar = std::complex<float>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:943:103:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1, 1, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > > >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<long long int>, -1, -1, 1, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > > >, Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1, 1, -1, -1>; SrcXprType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1, 1, -1, -1>; SrcXprType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1, 1, -1, -1>; Src = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >; Derived = Eigen::Matrix<std::complex<long long int>, -1, -1, 1, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >; Derived = Eigen::Matrix<std::complex<long long int>, -1, -1, 1, -1, -1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = -1; int _Options = 1; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/ProductEvaluators.h:451:34:   required from 'Eigen::internal::product_evaluator<Eigen::Product<Lhs, Rhs, 1>, ProductTag, Eigen::DenseShape, Eigen::DenseShape>::product_evaluator(const XprType&) [with Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >; Rhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; int ProductTag = 8; typename Eigen::internal::traits<typename Eigen::Product<Lhs, Rhs, 1>::Rhs>::Scalar = std::complex<long long int>; typename Eigen::internal::traits<typename Eigen::Product<Lhs, Rhs, 1>::Lhs>::Scalar = std::complex<long long int>; Eigen::internal::product_evaluator<Eigen::Product<Lhs, Rhs, 1>, ProductTag, Eigen::DenseShape, Eigen::DenseShape>::XprType = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 1>]'
..\Eigen/src/Core/ProductEvaluators.h:35:70:   required from 'Eigen::internal::evaluator<Eigen::Product<Lhs, Rhs, Option> >::evaluator(const XprType&) [with Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >; Rhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; int Options = 1; Eigen::internal::evaluator<Eigen::Product<Lhs, Rhs, Option> >::XprType = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 1>]'
..\Eigen/src/Core/AssignEvaluator.h:753:19:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 1>; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; SrcXprType = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 1>; Functor = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 1>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/ProductEvaluators.h:397:29:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 3>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >; Rhs = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:431:26:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >; Rhs = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<long long int>, -1, -1>; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >; Rhs = Eigen::Matrix<std::complex<long long int>, -1, -1>; int Options = 0; Scalar = std::complex<long long int>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Func = Eigen::internal::assign_op<std::complex<long long int>, std::complex<long long int> >; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<long long int>, -1, -1>; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; Derived = Eigen::Matrix<std::complex<long long int>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<long long int> >, const Eigen::Transpose<const Eigen::Matrix<std::complex<long long int>, -1, -1> > >, Eigen::Matrix<std::complex<long long int>, -1, -1>, 0>; _Scalar = std::complex<long long int>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:225:25:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, 8, 8, 0, 8, 8> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 8, 8, 0, 8, 8> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, 8, 8, 0, 8, 8> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 8, 8, 0, 8, 8> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, 8, 8, 0, 8, 8>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 8, 8, 0, 8, 8> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, 8, 8, 0, 8, 8>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 8, 8, 0, 8, 8> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, 8, 8, 0, 8, 8>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 8, 8, 0, 8, 8> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, 8, 8, 0, 8, 8>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 8, 8, 0, 8, 8> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, 8, 8, 0, 8, 8>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 8, 8, 0, 8, 8> >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 8, 8, 0, 8, 8> >; Derived = Eigen::Matrix<std::complex<float>, 8, 8, 0, 8, 8>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 8, 8, 0, 8, 8> >; _Scalar = std::complex<float>; int _Rows = 8; int _Cols = 8; int _Options = 0; int _MaxRows = 8; int _MaxCols = 8]'
..\Eigen/src/Core/CwiseNullaryOp.h:327:20:   required from 'Derived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Matrix<std::complex<float>, 8, 8, 0, 8, 8>; Eigen::DenseBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/CwiseNullaryOp.h:501:21:   required from 'Derived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Matrix<std::complex<float>, 8, 8, 0, 8, 8>]'
..\Eigen/src/Core/products/TriangularMatrixMatrix.h:141:5:   required from 'static void Eigen::internal::product_triangular_matrix_matrix<Scalar, Index, Mode, true, LhsStorageOrder, ConjugateLhs, RhsStorageOrder, ConjugateRhs, 0, Version>::run(Index, Index, Index, const Scalar*, Index, const Scalar*, Index, Scalar*, Index, const Scalar&, Eigen::internal::level3_blocking<Scalar, Scalar>&) [with Scalar = std::complex<float>; Index = long long int; int Mode = 5; int LhsStorageOrder = 0; bool ConjugateLhs = false; int RhsStorageOrder = 0; bool ConjugateRhs = false; int Version = 0]'
..\Eigen/src/Core/products/TriangularMatrixMatrix.h:427:12:   required from 'static void Eigen::internal::triangular_product_impl<Mode, LhsIsTriangular, Lhs, false, Rhs, false>::run(Dest&, const Lhs&, const Rhs&, const typename Dest::Scalar&) [with Dest = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; int Mode = 5; bool LhsIsTriangular = true; Lhs = const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Rhs = Eigen::Matrix<std::complex<float>, -1, -1>; typename Dest::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:712:14:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::TriangularShape, Eigen::DenseShape, ProductTag>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Lhs = Eigen::TriangularView<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 5>; Rhs = Eigen::Matrix<std::complex<float>, -1, -1>; int ProductTag = 8; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::TriangularShape, Eigen::DenseShape, ProductTag>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Lhs = Eigen::TriangularView<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 5>; Rhs = Eigen::Matrix<std::complex<float>, -1, -1>; Derived = Eigen::internal::generic_product_impl<Eigen::TriangularView<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 5>, Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::TriangularShape, Eigen::DenseShape, 8>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:357:18:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::subTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Lhs = Eigen::TriangularView<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 5>; Rhs = Eigen::Matrix<std::complex<float>, -1, -1>; Derived = Eigen::internal::generic_product_impl<Eigen::TriangularView<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 5>, Eigen::Matrix<std::complex<float>, -1, -1>, Eigen::TriangularShape, Eigen::DenseShape, 8>]'
..\Eigen/src/Core/ProductEvaluators.h:178:42:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::sub_assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Lhs = Eigen::TriangularView<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 5>; Rhs = Eigen::Matrix<std::complex<float>, -1, -1>; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::TriangularView<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 5>, Eigen::Matrix<std::complex<float>, -1, -1>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Src = Eigen::Product<Eigen::TriangularView<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 5>, Eigen::Matrix<std::complex<float>, -1, -1>, 0>; Func = Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/NoAlias.h:58:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator-=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::TriangularView<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 5>, Eigen::Matrix<std::complex<float>, -1, -1>, 0>; ExpressionType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/BlockHouseholder.h:96:17:   required from 'void Eigen::internal::apply_block_householder_on_the_left(MatrixType&, const VectorsType&, const CoeffsType&, bool) [with MatrixType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; VectorsType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; CoeffsType = Eigen::VectorBlock<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, -1>]'
..\Eigen/src/Householder/HouseholderSequence.h:333:46:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::applyThisOnTheLeft(Dest&, Workspace&) const [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Workspace = Eigen::Matrix<std::complex<float>, 1, -1>; VectorsType = Eigen::Matrix<std::complex<float>, -1, -1>; CoeffsType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; int Side = 1]'
..\Eigen/src/SVD/JacobiSVD.h:237:9:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, 1> >, Eigen::internal::evaluator<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1> >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, 1> >, Eigen::internal::evaluator<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1> >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, 1>; SrcXprType = Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, 1>; SrcXprType = Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, 1>; Src = Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>; Derived = Eigen::Matrix<double, -1, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>; OtherDerived = Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>; Derived = Eigen::Matrix<double, -1, 1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>; _Scalar = double; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Core/CoreEvaluators.h:1192:49:   required from 'Eigen::internal::unary_evaluator<Eigen::Replicate<ArgType, RowFactor, ColFactor> >::unary_evaluator(const XprType&) [with ArgType = Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>; int RowFactor = -1; int ColFactor = -1; typename Eigen::Replicate<ArgType, RowFactor, ColFactor>::Scalar = double; typename Eigen::internal::evaluator_traits<typename Eigen::Replicate<ArgType, RowFactor, ColFactor>::NestedExpression>::Kind = Eigen::internal::IndexBased; Eigen::internal::unary_evaluator<Eigen::Replicate<ArgType, RowFactor, ColFactor> >::XprType = Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>, -1, -1>]'
..\Eigen/src/Core/CoreEvaluators.h:93:64:   required from 'Eigen::internal::evaluator<T>::evaluator(const T&) [with T = Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>, -1, -1>]'
..\Eigen/src/Core/CoreEvaluators.h:1326:88:   required from 'Eigen::internal::evaluator_wrapper_base<XprType>::evaluator_wrapper_base(const ArgType&) [with XprType = Eigen::ArrayWrapper<const Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>, -1, -1> >; Eigen::internal::evaluator_wrapper_base<XprType>::ArgType = Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>, -1, -1>]'
..\Eigen/src/Core/CoreEvaluators.h:1405:81:   required from 'Eigen::internal::unary_evaluator<Eigen::ArrayWrapper<Derived> >::unary_evaluator(const XprType&) [with TArgType = const Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>, -1, -1>; typename Eigen::ArrayWrapper<Derived>::Scalar = double; typename Eigen::internal::evaluator_traits<typename Eigen::ArrayWrapper<Derived>::NestedExpression>::Kind = Eigen::internal::IndexBased; Eigen::internal::unary_evaluator<Eigen::ArrayWrapper<Derived> >::XprType = Eigen::ArrayWrapper<const Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>, -1, -1> >]'
..\Eigen/src/Core/CoreEvaluators.h:93:64:   required from 'Eigen::internal::evaluator<T>::evaluator(const T&) [with T = Eigen::ArrayWrapper<const Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>, -1, -1> >]'
..\Eigen/src/Core/CoreEvaluators.h:103:54:   required from 'Eigen::internal::evaluator<const T>::evaluator(const T&) [with T = Eigen::ArrayWrapper<const Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>, -1, -1> >]'
..\Eigen/src/Core/CoreEvaluators.h:702:26:   required from 'Eigen::internal::binary_evaluator<Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs>, Eigen::internal::IndexBased, Eigen::internal::IndexBased>::binary_evaluator(const XprType&) [with BinaryOp = Eigen::internal::scalar_quotient_op<double, double>; Lhs = const Eigen::ArrayWrapper<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >; Rhs = const Eigen::ArrayWrapper<const Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>, -1, -1> >; typename Eigen::internal::traits<typename Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs>::Rhs>::Scalar = double; typename Eigen::internal::traits<typename Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs>::Lhs>::Scalar = double; Eigen::internal::binary_evaluator<Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs>, Eigen::internal::IndexBased, Eigen::internal::IndexBased>::XprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::ArrayWrapper<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, const Eigen::ArrayWrapper<const Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>, -1, -1> > >]'
..\Eigen/src/Core/CoreEvaluators.h:671:70:   required from 'Eigen::internal::evaluator<Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs> >::evaluator(const XprType&) [with BinaryOp = Eigen::internal::scalar_quotient_op<double, double>; Lhs = const Eigen::ArrayWrapper<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >; Rhs = const Eigen::ArrayWrapper<const Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>, -1, -1> >; Eigen::internal::evaluator<Eigen::CwiseBinaryOp<BinaryOp, Lhs, Rhs> >::XprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::ArrayWrapper<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, const Eigen::ArrayWrapper<const Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>, -1, -1> > >]'
..\Eigen/src/Core/CoreEvaluators.h:1326:88:   required from 'Eigen::internal::evaluator_wrapper_base<XprType>::evaluator_wrapper_base(const ArgType&) [with XprType = Eigen::MatrixWrapper<const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::ArrayWrapper<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, const Eigen::ArrayWrapper<const Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>, -1, -1> > > >; Eigen::internal::evaluator_wrapper_base<XprType>::ArgType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::ArrayWrapper<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, const Eigen::ArrayWrapper<const Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>, -1, -1> > >]'
..\Eigen/src/Core/CoreEvaluators.h:1394:82:   required from 'Eigen::internal::unary_evaluator<Eigen::MatrixWrapper<TArgType> >::unary_evaluator(const XprType&) [with TArgType = const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::ArrayWrapper<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, const Eigen::ArrayWrapper<const Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>, -1, -1> > >; typename Eigen::MatrixWrapper<TArgType>::Scalar = double; typename Eigen::internal::evaluator_traits<typename Eigen::MatrixWrapper<TArgType>::NestedExpression>::Kind = Eigen::internal::IndexBased; Eigen::internal::unary_evaluator<Eigen::MatrixWrapper<TArgType> >::XprType = Eigen::MatrixWrapper<const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::ArrayWrapper<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, const Eigen::ArrayWrapper<const Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>, -1, -1> > > >]'
..\Eigen/src/Core/CoreEvaluators.h:93:64:   required from 'Eigen::internal::evaluator<T>::evaluator(const T&) [with T = Eigen::MatrixWrapper<const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::ArrayWrapper<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, const Eigen::ArrayWrapper<const Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>, -1, -1> > > >]'
..\Eigen/src/Core/AssignEvaluator.h:753:19:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::MatrixWrapper<const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::ArrayWrapper<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, const Eigen::ArrayWrapper<const Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>, -1, -1> > > >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::MatrixWrapper<const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::ArrayWrapper<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, const Eigen::ArrayWrapper<const Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>, -1, -1> > > >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::MatrixWrapper<const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::ArrayWrapper<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, const Eigen::ArrayWrapper<const Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>, -1, -1> > > >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::MatrixWrapper<const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::ArrayWrapper<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, const Eigen::ArrayWrapper<const Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>, -1, -1> > > >; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::MatrixWrapper<const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::ArrayWrapper<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, const Eigen::ArrayWrapper<const Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>, -1, -1> > > >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::MatrixWrapper<const Eigen::CwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, const Eigen::ArrayWrapper<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> > >, const Eigen::ArrayWrapper<const Eigen::Replicate<Eigen::PartialReduxExpr<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::internal::member_norm<double>, 1>, -1, -1> > > >; Derived = Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >]'
..\binary_library.cpp:145:73:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1, 1, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 1> >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1, 1, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 1> >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1, 1, -1, -1>; SrcXprType = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 1>; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1, 1, -1, -1>; SrcXprType = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 1>; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1, 1, -1, -1>; Src = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 1>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/ProductEvaluators.h:397:29:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 3>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, -1, 1, -1, -1>; Lhs = Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>; Rhs = Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:431:26:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, -1, 1, -1, -1>; Lhs = Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>; Rhs = Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<double, -1, -1, 1, -1, -1>; Lhs = Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>; Rhs = Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1, 1, -1, -1>; Src = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; Derived = Eigen::Matrix<double, -1, -1, 1, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:537:19:   required from 'Eigen::PlainObjectBase<Derived>::PlainObjectBase(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; Derived = Eigen::Matrix<double, -1, -1, 1, -1, -1>]'
..\Eigen/src/Core/Matrix.h:379:29:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 1; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:465:69:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::Scalar = double]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:435:20:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/EigenBase.h:104:9:   required from 'void Eigen::EigenBase<Derived>::applyThisOnTheRight(Dest&) const [with Dest = Eigen::Matrix<double, -1, -1>; Derived = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>]'
..\Eigen/src/Core/MatrixBase.h:500:3:   required from 'Derived& Eigen::MatrixBase<Derived>::operator*=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:179:42:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Diagonal<Eigen::Matrix<std::complex<float>, 8, 8, 1, 8, 8>, 0> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 8, 1, 0, 8, 1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Diagonal<Eigen::Matrix<std::complex<float>, 8, 8, 1, 8, 8>, 0> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 8, 1, 0, 8, 1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Diagonal<Eigen::Matrix<std::complex<float>, 8, 8, 1, 8, 8>, 0>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 8, 1, 0, 8, 1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Diagonal<Eigen::Matrix<std::complex<float>, 8, 8, 1, 8, 8>, 0>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 8, 1, 0, 8, 1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Diagonal<Eigen::Matrix<std::complex<float>, 8, 8, 1, 8, 8>, 0>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 8, 1, 0, 8, 1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Diagonal<Eigen::Matrix<std::complex<float>, 8, 8, 1, 8, 8>, 0>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 8, 1, 0, 8, 1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Diagonal<Eigen::Matrix<std::complex<float>, 8, 8, 1, 8, 8>, 0>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 8, 1, 0, 8, 1> >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 8, 1, 0, 8, 1> >; Derived = Eigen::Diagonal<Eigen::Matrix<std::complex<float>, 8, 8, 1, 8, 8>, 0>]'
..\Eigen/src/Core/CwiseNullaryOp.h:327:20:   required from 'Derived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Diagonal<Eigen::Matrix<std::complex<float>, 8, 8, 1, 8, 8>, 0>; Eigen::DenseBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/CwiseNullaryOp.h:501:21:   required from 'Derived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Diagonal<Eigen::Matrix<std::complex<float>, 8, 8, 1, 8, 8>, 0>]'
..\Eigen/src/Core/products/TriangularMatrixMatrix.h:143:7:   required from 'static void Eigen::internal::product_triangular_matrix_matrix<Scalar, Index, Mode, true, LhsStorageOrder, ConjugateLhs, RhsStorageOrder, ConjugateRhs, 0, Version>::run(Index, Index, Index, const Scalar*, Index, const Scalar*, Index, Scalar*, Index, const Scalar&, Eigen::internal::level3_blocking<Scalar, Scalar>&) [with Scalar = std::complex<float>; Index = long long int; int Mode = 6; int LhsStorageOrder = 1; bool ConjugateLhs = true; int RhsStorageOrder = 0; bool ConjugateRhs = false; int Version = 0]'
..\Eigen/src/Core/products/TriangularMatrixMatrix.h:427:12:   required from 'static void Eigen::internal::triangular_product_impl<Mode, LhsIsTriangular, Lhs, false, Rhs, false>::run(Dest&, const Lhs&, const Rhs&, const typename Dest::Scalar&) [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; int Mode = 6; bool LhsIsTriangular = true; Lhs = const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> > >; Rhs = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; typename Dest::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:712:14:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::TriangularShape, Eigen::DenseShape, ProductTag>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Lhs = Eigen::TriangularView<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> > >, 6>; Rhs = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; int ProductTag = 8; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::TriangularShape, Eigen::DenseShape, ProductTag>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Lhs = Eigen::TriangularView<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> > >, 6>; Rhs = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::TriangularView<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> > >, 6>, Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, Eigen::TriangularShape, Eigen::DenseShape, 8>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Lhs = Eigen::TriangularView<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> > >, 6>; Rhs = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::TriangularView<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> > >, 6>, Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, Eigen::TriangularShape, Eigen::DenseShape, 8>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; Lhs = Eigen::TriangularView<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> > >, 6>; Rhs = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::TriangularView<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> > >, 6>, Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Product<Eigen::TriangularView<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> > >, 6>, Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::TriangularView<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> > >, 6>, Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 0>; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:537:19:   required from 'Eigen::PlainObjectBase<Derived>::PlainObjectBase(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::TriangularView<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> > >, 6>, Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 0>; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:379:29:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::TriangularView<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> > >, 6>, Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 0>; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Householder/BlockHouseholder.h:92:78:   required from 'void Eigen::internal::apply_block_householder_on_the_left(MatrixType&, const VectorsType&, const CoeffsType&, bool) [with MatrixType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; VectorsType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; CoeffsType = Eigen::VectorBlock<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, -1>]'
..\Eigen/src/Householder/HouseholderSequence.h:333:46:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::applyThisOnTheLeft(Dest&, Workspace&) const [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Workspace = Eigen::Matrix<std::complex<float>, 1, -1>; VectorsType = Eigen::Matrix<std::complex<float>, -1, -1>; CoeffsType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; int Side = 1]'
..\Eigen/src/SVD/JacobiSVD.h:237:9:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, 1, -1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, 1, -1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, 1, -1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, 1, -1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, 1, -1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, 1, -1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, 1, -1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> >; Derived = Eigen::Matrix<std::complex<float>, 1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 1, -1> >; _Scalar = std::complex<float>; int _Rows = 1; int _Cols = -1; int _Options = 1; int _MaxRows = 1; int _MaxCols = -1]'
..\Eigen/src/Core/CwiseNullaryOp.h:327:20:   required from 'Derived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Matrix<std::complex<float>, 1, -1>; Eigen::DenseBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/CwiseNullaryOp.h:501:21:   required from 'Derived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Matrix<std::complex<float>, 1, -1>]'
..\Eigen/src/Core/ProductEvaluators.h:349:5:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<float>, 1, -1>; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Rhs = Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, Eigen::DenseShape, Eigen::TriangularShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<float>, 1, -1>; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Rhs = Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, 1, -1>; Src = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; Derived = Eigen::Matrix<std::complex<float>, 1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; OtherDerived = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; Derived = Eigen::Matrix<std::complex<float>, 1, -1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; _Scalar = std::complex<float>; int _Rows = 1; int _Cols = -1; int _Options = 1; int _MaxRows = 1; int _MaxCols = -1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Src = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Src = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>]'
..\Eigen/src/Householder/BlockHouseholder.h:67:33:   required from 'void Eigen::internal::make_block_householder_triangular_factor(TriangularFactorType&, const VectorsType&, const CoeffsType&) [with TriangularFactorType = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; VectorsType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; CoeffsType = Eigen::VectorBlock<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, -1>]'
..\Eigen/src/Householder/BlockHouseholder.h:85:55:   required from 'void Eigen::internal::apply_block_householder_on_the_left(MatrixType&, const VectorsType&, const CoeffsType&, bool) [with MatrixType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; VectorsType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; CoeffsType = Eigen::VectorBlock<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, -1>]'
..\Eigen/src/Householder/HouseholderSequence.h:333:46:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::applyThisOnTheLeft(Dest&, Workspace&) const [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Workspace = Eigen::Matrix<std::complex<float>, 1, -1>; VectorsType = Eigen::Matrix<std::complex<float>, -1, -1>; CoeffsType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; int Side = 1]'
..\Eigen/src/SVD/JacobiSVD.h:237:9:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Transpose<Eigen::Matrix<std::complex<float>, 1, -1> > >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> > > >, Eigen::internal::add_assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Transpose<Eigen::Matrix<std::complex<float>, 1, -1> > >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> > > >, Eigen::internal::add_assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Transpose<Eigen::Matrix<std::complex<float>, 1, -1> >; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> > >; Functor = Eigen::internal::add_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Transpose<Eigen::Matrix<std::complex<float>, 1, -1> >; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> > >; Functor = Eigen::internal::add_assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Transpose<Eigen::Matrix<std::complex<float>, 1, -1> >; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> > >; Func = Eigen::internal::add_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Transpose<Eigen::Matrix<std::complex<float>, 1, -1> >; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> > >; Func = Eigen::internal::add_assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/CwiseBinaryOp.h:177:18:   required from 'Derived& Eigen::MatrixBase<Derived>::operator+=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> > >; Derived = Eigen::Transpose<Eigen::Matrix<std::complex<float>, 1, -1> >]'
..\Eigen/src/Core/products/TriangularMatrixVector.h:273:14:   required from 'static void Eigen::internal::trmv_selector<Mode, 0>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Transpose<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false> >; Rhs = Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false> >; Dest = Eigen::Transpose<Eigen::Matrix<std::complex<float>, 1, -1> >; int Mode = 1; typename Dest::Scalar = std::complex<float>]'
..\Eigen/src/Core/products/TriangularMatrixVector.h:194:18:   required from 'static void Eigen::internal::triangular_product_impl<Mode, false, Lhs, true, Rhs, false>::run(Dest&, const Lhs&, const Rhs&, const typename Dest::Scalar&) [with Dest = Eigen::Matrix<std::complex<float>, 1, -1>; int Mode = 2; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Rhs = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>; typename Dest::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:725:113:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::TriangularShape, ProductTag>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<std::complex<float>, 1, -1>; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Rhs = Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>; int ProductTag = 7; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::TriangularShape, ProductTag>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Matrix<std::complex<float>, 1, -1>; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Rhs = Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, Eigen::DenseShape, Eigen::TriangularShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<float>, 1, -1>; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Rhs = Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, Eigen::DenseShape, Eigen::TriangularShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<float>, 1, -1>; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Rhs = Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, 1, -1>; Src = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; Derived = Eigen::Matrix<std::complex<float>, 1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; OtherDerived = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; Derived = Eigen::Matrix<std::complex<float>, 1, -1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; _Scalar = std::complex<float>; int _Rows = 1; int _Cols = -1; int _Options = 1; int _MaxRows = 1; int _MaxCols = -1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Src = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Src = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>]'
..\Eigen/src/Householder/BlockHouseholder.h:67:33:   required from 'void Eigen::internal::make_block_householder_triangular_factor(TriangularFactorType&, const VectorsType&, const CoeffsType&) [with TriangularFactorType = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; VectorsType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; CoeffsType = Eigen::VectorBlock<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, -1>]'
..\Eigen/src/Householder/BlockHouseholder.h:85:55:   required from 'void Eigen::internal::apply_block_householder_on_the_left(MatrixType&, const VectorsType&, const CoeffsType&, bool) [with MatrixType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; VectorsType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; CoeffsType = Eigen::VectorBlock<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, -1>]'
..\Eigen/src/Householder/HouseholderSequence.h:333:46:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::applyThisOnTheLeft(Dest&, Workspace&) const [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Workspace = Eigen::Matrix<std::complex<float>, 1, -1>; VectorsType = Eigen::Matrix<std::complex<float>, -1, -1>; CoeffsType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; int Side = 1]'
..\Eigen/src/SVD/JacobiSVD.h:237:9:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, 8, 8, 1, 8, 8> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 8, 8, 1, 8, 8> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, 8, 8, 1, 8, 8> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 8, 8, 1, 8, 8> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, 8, 8, 1, 8, 8>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 8, 8, 1, 8, 8> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, 8, 8, 1, 8, 8>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 8, 8, 1, 8, 8> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, 8, 8, 1, 8, 8>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 8, 8, 1, 8, 8> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, 8, 8, 1, 8, 8>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 8, 8, 1, 8, 8> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, 8, 8, 1, 8, 8>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 8, 8, 1, 8, 8> >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 8, 8, 1, 8, 8> >; Derived = Eigen::Matrix<std::complex<float>, 8, 8, 1, 8, 8>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, 8, 8, 1, 8, 8> >; _Scalar = std::complex<float>; int _Rows = 8; int _Cols = 8; int _Options = 1; int _MaxRows = 8; int _MaxCols = 8]'
..\Eigen/src/Core/CwiseNullaryOp.h:327:20:   required from 'Derived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Matrix<std::complex<float>, 8, 8, 1, 8, 8>; Eigen::DenseBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/CwiseNullaryOp.h:501:21:   required from 'Derived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Matrix<std::complex<float>, 8, 8, 1, 8, 8>]'
..\Eigen/src/Core/products/TriangularMatrixMatrix.h:141:5:   required from 'static void Eigen::internal::product_triangular_matrix_matrix<Scalar, Index, Mode, true, LhsStorageOrder, ConjugateLhs, RhsStorageOrder, ConjugateRhs, 0, Version>::run(Index, Index, Index, const Scalar*, Index, const Scalar*, Index, Scalar*, Index, const Scalar&, Eigen::internal::level3_blocking<Scalar, Scalar>&) [with Scalar = std::complex<float>; Index = long long int; int Mode = 6; int LhsStorageOrder = 1; bool ConjugateLhs = true; int RhsStorageOrder = 0; bool ConjugateRhs = false; int Version = 0]'
..\Eigen/src/Core/products/TriangularMatrixMatrix.h:427:12:   required from 'static void Eigen::internal::triangular_product_impl<Mode, LhsIsTriangular, Lhs, false, Rhs, false>::run(Dest&, const Lhs&, const Rhs&, const typename Dest::Scalar&) [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; int Mode = 6; bool LhsIsTriangular = true; Lhs = const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> > >; Rhs = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; typename Dest::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:712:14:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::TriangularShape, Eigen::DenseShape, ProductTag>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Lhs = Eigen::TriangularView<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> > >, 6>; Rhs = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; int ProductTag = 8; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::TriangularShape, Eigen::DenseShape, ProductTag>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Lhs = Eigen::TriangularView<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> > >, 6>; Rhs = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::TriangularView<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> > >, 6>, Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, Eigen::TriangularShape, Eigen::DenseShape, 8>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Lhs = Eigen::TriangularView<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> > >, 6>; Rhs = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::TriangularView<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> > >, 6>, Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, Eigen::TriangularShape, Eigen::DenseShape, 8>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; Lhs = Eigen::TriangularView<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> > >, 6>; Rhs = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::TriangularView<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> > >, 6>, Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Product<Eigen::TriangularView<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> > >, 6>, Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::TriangularView<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> > >, 6>, Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 0>; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:537:19:   required from 'Eigen::PlainObjectBase<Derived>::PlainObjectBase(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::TriangularView<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> > >, 6>, Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 0>; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:379:29:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::TriangularView<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> > >, 6>, Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 0>; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Householder/BlockHouseholder.h:92:78:   required from 'void Eigen::internal::apply_block_householder_on_the_left(MatrixType&, const VectorsType&, const CoeffsType&, bool) [with MatrixType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; VectorsType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; CoeffsType = Eigen::VectorBlock<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, -1>]'
..\Eigen/src/Householder/HouseholderSequence.h:333:46:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::applyThisOnTheLeft(Dest&, Workspace&) const [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Workspace = Eigen::Matrix<std::complex<float>, 1, -1>; VectorsType = Eigen::Matrix<std::complex<float>, -1, -1>; CoeffsType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; int Side = 1]'
..\Eigen/src/SVD/JacobiSVD.h:237:9:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
In file included from ..\Eigen/Core:473:0,
                 from ..\binary_library.cpp:18:
..\Eigen/src/Core/products/GeneralMatrixVector.h: In instantiation of 'static void Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 1, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::run(Index, Index, const LhsMapper&, const RhsMapper&, Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 1, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::ResScalar*, Index, Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 1, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::ResScalar) [with Index = long long int; LhsScalar = std::complex<float>; LhsMapper = Eigen::internal::const_blas_data_mapper<std::complex<float>, long long int, 1>; bool ConjugateLhs = false; RhsScalar = std::complex<float>; RhsMapper = Eigen::internal::const_blas_data_mapper<std::complex<float>, long long int, 0>; bool ConjugateRhs = false; int Version = 0; Eigen::internal::general_matrix_vector_product<Index, LhsScalar, LhsMapper, 1, ConjugateLhs, RhsScalar, RhsMapper, ConjugateRhs, Version>::ResScalar = std::complex<float>]':
..\Eigen/src/Core/GeneralProduct.h:334:132:   required from 'static void Eigen::internal::gemv_dense_selector<2, 1, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false> >; Rhs = Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > > > >; Dest = Eigen::Transpose<Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> > >; typename Dest::Scalar = std::complex<float>]'
..\Eigen/src/Core/GeneralProduct.h:192:12:   required from 'static void Eigen::internal::gemv_dense_selector<1, StorageOrder, BlasCompatible>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > > >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Dest = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; int StorageOrder = 0; bool BlasCompatible = true; typename Dest::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > > >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > > >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > > >, Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > > >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > > >, Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > > >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > > >, Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > > >, Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/NoAlias.h:42:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > > >, Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 0>; ExpressionType = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:126:19:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheLeft(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > >; Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/QR/CompleteOrthogonalDecomposition.h:479:5:   required from 'void Eigen::CompleteOrthogonalDecomposition<MatrixType>::applyZAdjointOnTheLeftInPlace(Rhs&) const [with Rhs = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/QR/CompleteOrthogonalDecomposition.h:520:34:   required from 'void Eigen::CompleteOrthogonalDecomposition<MatrixType>::_solve_impl(const RhsType&, DstType&) const [with RhsType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; DstType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Solve.h:147:5:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Solve<DecType, RhsType>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; DecType = Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >; RhsType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Solve<DecType, RhsType>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense>::SrcXprType = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/QR/CompleteOrthogonalDecomposition.h:537:9:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<MatrixType> >, Eigen::internal::assign_op<typename DstXprType::Scalar, typename Eigen::CompleteOrthogonalDecomposition<MatrixType>::Scalar>, Eigen::internal::Dense2Dense>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<typename DstXprType::Scalar, typename Eigen::CompleteOrthogonalDecomposition<MatrixType>::Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; Eigen::internal::Assignment<DstXprType, Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<MatrixType> >, Eigen::internal::assign_op<typename DstXprType::Scalar, typename Eigen::CompleteOrthogonalDecomposition<MatrixType>::Scalar>, Eigen::internal::Dense2Dense>::SrcXprType = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >; typename Eigen::CompleteOrthogonalDecomposition<MatrixType>::Scalar = std::complex<float>; typename DstXprType::Scalar = std::complex<float>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:943:103:   required from here
..\Eigen/src/Core/products/GeneralMatrixVector.h:460:39: warning: enum constant in boolean context [-Wint-in-bool-context]
   const Index offset1 = (FirstAligned && alignmentStep==1)?3:1;
                         ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/products/GeneralMatrixVector.h:461:39: warning: enum constant in boolean context [-Wint-in-bool-context]
   const Index offset3 = (FirstAligned && alignmentStep==1)?1:3;
                         ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from ..\Eigen/Core:420:0,
                 from ..\binary_library.cpp:18:
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Matrix<double, -1, 1> >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Matrix<double, -1, 1> >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Matrix<double, -1, 1>; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Matrix<double, -1, 1>; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Matrix<double, -1, 1>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Matrix<double, -1, 1>; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Matrix<double, -1, 1>]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, -1, 1>; Derived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/GeneralProduct.h:328:87:   required from 'static void Eigen::internal::gemv_dense_selector<2, 1, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Transpose<Eigen::Matrix<double, -1, -1> >; Rhs = Eigen::Matrix<double, -1, 1>; Dest = Eigen::Matrix<double, -1, 1>; typename Dest::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<double, -1, 1>; Lhs = Eigen::Transpose<Eigen::Matrix<double, -1, -1> >; Rhs = Eigen::Matrix<double, -1, 1>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Matrix<double, -1, 1>; Lhs = Eigen::Transpose<Eigen::Matrix<double, -1, -1> >; Rhs = Eigen::Matrix<double, -1, 1>; Derived = Eigen::internal::generic_product_impl<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, 1>, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, 1>; Lhs = Eigen::Transpose<Eigen::Matrix<double, -1, -1> >; Rhs = Eigen::Matrix<double, -1, 1>; Derived = Eigen::internal::generic_product_impl<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, 1>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<double, -1, 1>; Lhs = Eigen::Transpose<Eigen::Matrix<double, -1, -1> >; Rhs = Eigen::Matrix<double, -1, 1>; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, 1>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, 1>; Src = Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, 1>, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, 1>, 0>; Derived = Eigen::Matrix<double, -1, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, 1>, 0>; OtherDerived = Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, 1>, 0>; Derived = Eigen::Matrix<double, -1, 1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, 1>, 0>; _Scalar = double; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Core/ProductEvaluators.h:379:15:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<double, -1, 1>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, 1>, 0>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Matrix<double, -1, 1>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, 1>, 0>; Derived = Eigen::internal::generic_product_impl<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, 1>, 0>, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, 1>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, 1>, 0>; Derived = Eigen::internal::generic_product_impl<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, 1>, 0>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<double, -1, 1>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, 1>, 0>; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, 1>, 0>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, 1>; Src = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, 1>, 0>, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, 1>, 0>, 0>; Derived = Eigen::Matrix<double, -1, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, 1>, 0>, 0>; OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, 1>, 0>, 0>; Derived = Eigen::Matrix<double, -1, 1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, 1>, 0>, 0>; _Scalar = double; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<double, -1, 1>; Src = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, 1>, 0>, 0>; Func = Eigen::internal::sub_assign_op<double, double>; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/CwiseBinaryOp.h:164:18:   required from 'Derived& Eigen::MatrixBase<Derived>::operator-=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, Eigen::Matrix<double, -1, 1>, 0>, 0>; Derived = Eigen::Matrix<double, -1, 1>]'
..\binary_library.cpp:153:37:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false> > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false> > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false> >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false> >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false> >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false> >; Derived = Eigen::Matrix<double, -1, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false> >; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false> >; Derived = Eigen::Matrix<double, -1, 1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false> >; _Scalar = double; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Core/ProductEvaluators.h:275:58:   required from 'void Eigen::internal::outer_product_selector_run(Dst&, const Lhs&, const Rhs&, const Func&, const Eigen::internal::false_type&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false> >; Rhs = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; Func = Eigen::internal::generic_product_impl<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::DenseShape, Eigen::DenseShape, 5>::sub]'
..\Eigen/src/Core/ProductEvaluators.h:329:41:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 5>::subTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false> >; Rhs = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/ProductEvaluators.h:178:42:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::sub_assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false> >; Rhs = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>; Src = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 0>; Func = Eigen::internal::sub_assign_op<double, double>]'
..\Eigen/src/Core/NoAlias.h:58:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator-=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, const Eigen::Matrix<double, -1, 1> >, const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false> >, Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >, 0>; ExpressionType = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:129:22:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheLeft(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false>; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = double]'
..\Eigen/src/Householder/HouseholderSequence.h:258:13:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::evalTo(Dest&, Workspace&) const [with Dest = Eigen::Matrix<double, -1, -1>; Workspace = Eigen::Matrix<double, -1, 1>; VectorsType = Eigen::Matrix<double, -1, -1>; CoeffsType = Eigen::Matrix<double, -1, 1>; int Side = 1]'
..\Eigen/src/Householder/HouseholderSequence.h:237:13:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::evalTo(DestType&) const [with DestType = Eigen::Matrix<double, -1, -1>; VectorsType = Eigen::Matrix<double, -1, -1>; CoeffsType = Eigen::Matrix<double, -1, 1>; int Side = 1]'
..\Eigen/src/Core/AssignEvaluator.h:932:3:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::EigenBase2EigenBase, Weak>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<typename DstXprType::Scalar, typename SrcXprType::Scalar>&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; Functor = Eigen::internal::assign_op<double, double>; Weak = void; typename SrcXprType::Scalar = double; typename DstXprType::Scalar = double]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>]'
..\Eigen/src/Core/Assign.h:75:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:571:22:   required from 'Derived& Eigen::PlainObjectBase<Derived>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:238:29:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Eigenvalues/RealSchur.h:288:12:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::computeFromHessenberg(const HessMatrixType&, const OrthMatrixType&, bool) [with HessMatrixType = Eigen::internal::HessenbergDecompositionMatrixHReturnType<Eigen::Matrix<double, -1, -1> >; OrthMatrixType = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:274:24:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Transpose<Eigen::Matrix<std::complex<float>, 1, -1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Transpose<Eigen::Matrix<std::complex<float>, 1, -1> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Transpose<Eigen::Matrix<std::complex<float>, 1, -1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Transpose<Eigen::Matrix<std::complex<float>, 1, -1> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> >; Src = Eigen::Transpose<Eigen::Matrix<std::complex<float>, 1, -1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> >; Src = Eigen::Transpose<Eigen::Matrix<std::complex<float>, 1, -1> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> >; Src = Eigen::Transpose<Eigen::Matrix<std::complex<float>, 1, -1> >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Transpose<Eigen::Matrix<std::complex<float>, 1, -1> >; Derived = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/products/TriangularMatrixVector.h:257:48:   required from 'static void Eigen::internal::trmv_selector<Mode, 0>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Transpose<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false> >; Rhs = Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false> >; Dest = Eigen::Transpose<Eigen::Matrix<std::complex<float>, 1, -1> >; int Mode = 1; typename Dest::Scalar = std::complex<float>]'
..\Eigen/src/Core/products/TriangularMatrixVector.h:194:18:   required from 'static void Eigen::internal::triangular_product_impl<Mode, false, Lhs, true, Rhs, false>::run(Dest&, const Lhs&, const Rhs&, const typename Dest::Scalar&) [with Dest = Eigen::Matrix<std::complex<float>, 1, -1>; int Mode = 2; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Rhs = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>; typename Dest::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:725:113:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::TriangularShape, ProductTag>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<std::complex<float>, 1, -1>; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Rhs = Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>; int ProductTag = 7; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::TriangularShape, ProductTag>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Matrix<std::complex<float>, 1, -1>; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Rhs = Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, Eigen::DenseShape, Eigen::TriangularShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<float>, 1, -1>; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Rhs = Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, Eigen::DenseShape, Eigen::TriangularShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<float>, 1, -1>; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Rhs = Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, 1, -1>; Src = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; Derived = Eigen::Matrix<std::complex<float>, 1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; OtherDerived = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; Derived = Eigen::Matrix<std::complex<float>, 1, -1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; _Scalar = std::complex<float>; int _Rows = 1; int _Cols = -1; int _Options = 1; int _MaxRows = 1; int _MaxCols = -1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Src = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Src = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>]'
..\Eigen/src/Householder/BlockHouseholder.h:67:33:   required from 'void Eigen::internal::make_block_householder_triangular_factor(TriangularFactorType&, const VectorsType&, const CoeffsType&) [with TriangularFactorType = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; VectorsType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; CoeffsType = Eigen::VectorBlock<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, -1>]'
..\Eigen/src/Householder/BlockHouseholder.h:85:55:   required from 'void Eigen::internal::apply_block_householder_on_the_left(MatrixType&, const VectorsType&, const CoeffsType&, bool) [with MatrixType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; VectorsType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; CoeffsType = Eigen::VectorBlock<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, -1>]'
..\Eigen/src/Householder/HouseholderSequence.h:333:46:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::applyThisOnTheLeft(Dest&, Workspace&) const [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Workspace = Eigen::Matrix<std::complex<float>, 1, -1>; VectorsType = Eigen::Matrix<std::complex<float>, -1, -1>; CoeffsType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; int Side = 1]'
..\Eigen/src/SVD/JacobiSVD.h:237:9:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >, -1, 1, false> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<const Eigen::Block<const Eigen::Map<const Eigen::Matrix<std::complex<float>, -1, -1>, 0, Eigen::OuterStride<> >, -1, 1, true>, -1, 1, false> > >, Eigen::internal::add_assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >, -1, 1, false> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<const Eigen::Block<const Eigen::Map<const Eigen::Matrix<std::complex<float>, -1, -1>, 0, Eigen::OuterStride<> >, -1, 1, true>, -1, 1, false> > >, Eigen::internal::add_assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >, -1, 1, false>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<const Eigen::Block<const Eigen::Map<const Eigen::Matrix<std::complex<float>, -1, -1>, 0, Eigen::OuterStride<> >, -1, 1, true>, -1, 1, false> >; Functor = Eigen::internal::add_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >, -1, 1, false>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<const Eigen::Block<const Eigen::Map<const Eigen::Matrix<std::complex<float>, -1, -1>, 0, Eigen::OuterStride<> >, -1, 1, true>, -1, 1, false> >; Functor = Eigen::internal::add_assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >, -1, 1, false>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<const Eigen::Block<const Eigen::Map<const Eigen::Matrix<std::complex<float>, -1, -1>, 0, Eigen::OuterStride<> >, -1, 1, true>, -1, 1, false> >; Func = Eigen::internal::add_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >, -1, 1, false>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<const Eigen::Block<const Eigen::Map<const Eigen::Matrix<std::complex<float>, -1, -1>, 0, Eigen::OuterStride<> >, -1, 1, true>, -1, 1, false> >; Func = Eigen::internal::add_assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/CwiseBinaryOp.h:177:18:   required from 'Derived& Eigen::MatrixBase<Derived>::operator+=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::Block<const Eigen::Block<const Eigen::Map<const Eigen::Matrix<std::complex<float>, -1, -1>, 0, Eigen::OuterStride<> >, -1, 1, true>, -1, 1, false> >; Derived = Eigen::Block<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >, -1, 1, false>]'
..\Eigen/src/Core/products/TriangularMatrixVector.h:66:28:   required from 'static void Eigen::internal::triangular_matrix_vector_product<Index, Mode, LhsScalar, ConjLhs, RhsScalar, ConjRhs, 0, Version>::run(Index, Index, const LhsScalar*, Index, const RhsScalar*, Index, Eigen::internal::triangular_matrix_vector_product<Index, Mode, LhsScalar, ConjLhs, RhsScalar, ConjRhs, 0, Version>::ResScalar*, Index, const RhsScalar&) [with Index = long long int; int Mode = 1; LhsScalar = std::complex<float>; bool ConjLhs = false; RhsScalar = std::complex<float>; bool ConjRhs = false; int Version = 0; Eigen::internal::triangular_matrix_vector_product<Index, Mode, LhsScalar, ConjLhs, RhsScalar, ConjRhs, 0, Version>::ResScalar = std::complex<float>]'
..\Eigen/src/Core/products/TriangularMatrixVector.h:265:12:   required from 'static void Eigen::internal::trmv_selector<Mode, 0>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Transpose<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false> >; Rhs = Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false> >; Dest = Eigen::Transpose<Eigen::Matrix<std::complex<float>, 1, -1> >; int Mode = 1; typename Dest::Scalar = std::complex<float>]'
..\Eigen/src/Core/products/TriangularMatrixVector.h:194:18:   required from 'static void Eigen::internal::triangular_product_impl<Mode, false, Lhs, true, Rhs, false>::run(Dest&, const Lhs&, const Rhs&, const typename Dest::Scalar&) [with Dest = Eigen::Matrix<std::complex<float>, 1, -1>; int Mode = 2; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Rhs = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>; typename Dest::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:725:113:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::TriangularShape, ProductTag>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<std::complex<float>, 1, -1>; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Rhs = Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>; int ProductTag = 7; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::TriangularShape, ProductTag>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Matrix<std::complex<float>, 1, -1>; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Rhs = Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, Eigen::DenseShape, Eigen::TriangularShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<float>, 1, -1>; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Rhs = Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, Eigen::DenseShape, Eigen::TriangularShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<float>, 1, -1>; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Rhs = Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, 1, -1>; Src = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; Derived = Eigen::Matrix<std::complex<float>, 1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; OtherDerived = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; Derived = Eigen::Matrix<std::complex<float>, 1, -1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; _Scalar = std::complex<float>; int _Rows = 1; int _Cols = -1; int _Options = 1; int _MaxRows = 1; int _MaxCols = -1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Src = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Src = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>]'
..\Eigen/src/Householder/BlockHouseholder.h:67:33:   required from 'void Eigen::internal::make_block_householder_triangular_factor(TriangularFactorType&, const VectorsType&, const CoeffsType&) [with TriangularFactorType = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; VectorsType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; CoeffsType = Eigen::VectorBlock<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, -1>]'
..\Eigen/src/Householder/BlockHouseholder.h:85:55:   required from 'void Eigen::internal::apply_block_householder_on_the_left(MatrixType&, const VectorsType&, const CoeffsType&, bool) [with MatrixType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; VectorsType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; CoeffsType = Eigen::VectorBlock<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, -1>]'
..\Eigen/src/Householder/HouseholderSequence.h:333:46:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::applyThisOnTheLeft(Dest&, Workspace&) const [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Workspace = Eigen::Matrix<std::complex<float>, 1, -1>; VectorsType = Eigen::Matrix<std::complex<float>, -1, -1>; CoeffsType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; int Side = 1]'
..\Eigen/src/SVD/JacobiSVD.h:237:9:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Transpose<Eigen::Matrix<std::complex<float>, 1, -1> > >, Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Transpose<Eigen::Matrix<std::complex<float>, 1, -1> > >, Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Transpose<Eigen::Matrix<std::complex<float>, 1, -1> >; SrcXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Transpose<Eigen::Matrix<std::complex<float>, 1, -1> >; SrcXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Transpose<Eigen::Matrix<std::complex<float>, 1, -1> >; Src = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Transpose<Eigen::Matrix<std::complex<float>, 1, -1> >; Src = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Transpose<Eigen::Matrix<std::complex<float>, 1, -1> >; Src = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 2, Eigen::Stride<0, 0> >; Derived = Eigen::Transpose<Eigen::Matrix<std::complex<float>, 1, -1> >]'
..\Eigen/src/Core/products/TriangularMatrixVector.h:275:14:   required from 'static void Eigen::internal::trmv_selector<Mode, 0>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Transpose<const Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false> >; Rhs = Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false> >; Dest = Eigen::Transpose<Eigen::Matrix<std::complex<float>, 1, -1> >; int Mode = 1; typename Dest::Scalar = std::complex<float>]'
..\Eigen/src/Core/products/TriangularMatrixVector.h:194:18:   required from 'static void Eigen::internal::triangular_product_impl<Mode, false, Lhs, true, Rhs, false>::run(Dest&, const Lhs&, const Rhs&, const typename Dest::Scalar&) [with Dest = Eigen::Matrix<std::complex<float>, 1, -1>; int Mode = 2; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Rhs = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>; typename Dest::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:725:113:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::TriangularShape, ProductTag>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<std::complex<float>, 1, -1>; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Rhs = Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>; int ProductTag = 7; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::TriangularShape, ProductTag>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Matrix<std::complex<float>, 1, -1>; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Rhs = Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, Eigen::DenseShape, Eigen::TriangularShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<std::complex<float>, 1, -1>; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Rhs = Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>; Derived = Eigen::internal::generic_product_impl<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, Eigen::DenseShape, Eigen::TriangularShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<float>, 1, -1>; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Rhs = Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, 1, -1>; Src = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; Derived = Eigen::Matrix<std::complex<float>, 1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; OtherDerived = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; Derived = Eigen::Matrix<std::complex<float>, 1, -1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; _Scalar = std::complex<float>; int _Rows = 1; int _Cols = -1; int _Options = 1; int _MaxRows = 1; int _MaxCols = -1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Src = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>; Src = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>, Eigen::TriangularView<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, -1, -1, false>, 2>, 0>; Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>, 1, -1, true>, 1, -1, false>]'
..\Eigen/src/Householder/BlockHouseholder.h:67:33:   required from 'void Eigen::internal::make_block_householder_triangular_factor(TriangularFactorType&, const VectorsType&, const CoeffsType&) [with TriangularFactorType = Eigen::Matrix<std::complex<float>, -1, -1, 1, -1, -1>; VectorsType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; CoeffsType = Eigen::VectorBlock<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, -1>]'
..\Eigen/src/Householder/BlockHouseholder.h:85:55:   required from 'void Eigen::internal::apply_block_householder_on_the_left(MatrixType&, const VectorsType&, const CoeffsType&, bool) [with MatrixType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; VectorsType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; CoeffsType = Eigen::VectorBlock<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, -1>]'
..\Eigen/src/Householder/HouseholderSequence.h:333:46:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::applyThisOnTheLeft(Dest&, Workspace&) const [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Workspace = Eigen::Matrix<std::complex<float>, 1, -1>; VectorsType = Eigen::Matrix<std::complex<float>, -1, -1>; CoeffsType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >; int Side = 1]'
..\Eigen/src/SVD/JacobiSVD.h:237:9:   required from 'bool Eigen::internal::qr_preconditioner_impl<MatrixType, 2, 0, true>::run(Eigen::JacobiSVD<MatrixType, 2>&, const MatrixType&) [with MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:684:5:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/SVD/JacobiSVD.h:548:14:   required from 'Eigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\binary_library.cpp:834:57:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1> >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1> >, Eigen::internal::evaluator<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1> >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:537:19:   required from 'Eigen::PlainObjectBase<Derived>::PlainObjectBase(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:379:29:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:464:69:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<double, -1, -1, 1, -1, -1>; Lhs = Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>; Rhs = Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::Scalar = double]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:435:20:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, -1, 1, -1, -1>; Lhs = Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>; Rhs = Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<double, -1, -1, 1, -1, -1>; Lhs = Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>; Rhs = Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1, 1, -1, -1>; Src = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; Derived = Eigen::Matrix<double, -1, -1, 1, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:537:19:   required from 'Eigen::PlainObjectBase<Derived>::PlainObjectBase(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; Derived = Eigen::Matrix<double, -1, -1, 1, -1, -1>]'
..\Eigen/src/Core/Matrix.h:379:29:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 1; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:465:69:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::Scalar = double]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:435:20:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/EigenBase.h:104:9:   required from 'void Eigen::EigenBase<Derived>::applyThisOnTheRight(Dest&) const [with Dest = Eigen::Matrix<double, -1, -1>; Derived = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>]'
..\Eigen/src/Core/MatrixBase.h:500:3:   required from 'Derived& Eigen::MatrixBase<Derived>::operator*=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:179:42:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1, 1, -1, -1> >, Eigen::internal::evaluator<Eigen::Transpose<const Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1, 1, -1, -1> >, Eigen::internal::evaluator<Eigen::Transpose<const Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1, 1, -1, -1>; SrcXprType = Eigen::Transpose<const Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1, 1, -1, -1>; SrcXprType = Eigen::Transpose<const Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1, 1, -1, -1>; Src = Eigen::Transpose<const Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Transpose<const Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >; Derived = Eigen::Matrix<double, -1, -1, 1, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:537:19:   required from 'Eigen::PlainObjectBase<Derived>::PlainObjectBase(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Transpose<const Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >; Derived = Eigen::Matrix<double, -1, -1, 1, -1, -1>]'
..\Eigen/src/Core/Matrix.h:379:29:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::Transpose<const Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 1; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:465:69:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<double, -1, -1, 1, -1, -1>; Lhs = Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>; Rhs = Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::Scalar = double]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:435:20:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, -1, 1, -1, -1>; Lhs = Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>; Rhs = Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<double, -1, -1, 1, -1, -1>; Lhs = Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>; Rhs = Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1, 1, -1, -1>; Src = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; Derived = Eigen::Matrix<double, -1, -1, 1, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:537:19:   required from 'Eigen::PlainObjectBase<Derived>::PlainObjectBase(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; Derived = Eigen::Matrix<double, -1, -1, 1, -1, -1>]'
..\Eigen/src/Core/Matrix.h:379:29:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 1; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:465:69:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::Scalar = double]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:435:20:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/EigenBase.h:104:9:   required from 'void Eigen::EigenBase<Derived>::applyThisOnTheRight(Dest&) const [with Dest = Eigen::Matrix<double, -1, -1>; Derived = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>]'
..\Eigen/src/Core/MatrixBase.h:500:3:   required from 'Derived& Eigen::MatrixBase<Derived>::operator*=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:179:42:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<std::complex<float>, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, 1>; SrcXprType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, 1>; Src = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > >; Derived = Eigen::Matrix<std::complex<float>, -1, 1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > >; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > >; Derived = Eigen::Matrix<std::complex<float>, -1, 1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > >; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Core/ProductEvaluators.h:275:58:   required from 'void Eigen::internal::outer_product_selector_run(Dst&, const Lhs&, const Rhs&, const Func&, const Eigen::internal::false_type&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > >; Rhs = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Func = Eigen::internal::generic_product_impl<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > >, Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >, Eigen::DenseShape, Eigen::DenseShape, 5>::sub]'
..\Eigen/src/Core/ProductEvaluators.h:329:41:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 5>::subTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > >; Rhs = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/ProductEvaluators.h:178:42:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::sub_assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Lhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > >; Rhs = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::sub_assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > >, Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Src = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > >, Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >, 0>; Func = Eigen::internal::sub_assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/NoAlias.h:58:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator-=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseBinaryOp<Eigen::internal::scalar_product_op<std::complex<float>, std::complex<float> >, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<std::complex<float> >, const Eigen::Matrix<std::complex<float>, -1, 1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > >, Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >, 0>; ExpressionType = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:129:22:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheLeft(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > >; Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/QR/CompleteOrthogonalDecomposition.h:479:5:   required from 'void Eigen::CompleteOrthogonalDecomposition<MatrixType>::applyZAdjointOnTheLeftInPlace(Rhs&) const [with Rhs = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/QR/CompleteOrthogonalDecomposition.h:520:34:   required from 'void Eigen::CompleteOrthogonalDecomposition<MatrixType>::_solve_impl(const RhsType&, DstType&) const [with RhsType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; DstType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Solve.h:147:5:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Solve<DecType, RhsType>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; DecType = Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >; RhsType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Solve<DecType, RhsType>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense>::SrcXprType = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/QR/CompleteOrthogonalDecomposition.h:537:9:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<MatrixType> >, Eigen::internal::assign_op<typename DstXprType::Scalar, typename Eigen::CompleteOrthogonalDecomposition<MatrixType>::Scalar>, Eigen::internal::Dense2Dense>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<typename DstXprType::Scalar, typename Eigen::CompleteOrthogonalDecomposition<MatrixType>::Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; Eigen::internal::Assignment<DstXprType, Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<MatrixType> >, Eigen::internal::assign_op<typename DstXprType::Scalar, typename Eigen::CompleteOrthogonalDecomposition<MatrixType>::Scalar>, Eigen::internal::Dense2Dense>::SrcXprType = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >; typename Eigen::CompleteOrthogonalDecomposition<MatrixType>::Scalar = std::complex<float>; typename DstXprType::Scalar = std::complex<float>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:943:103:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false> >, Eigen::internal::evaluator<Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false> >, Eigen::internal::evaluator<Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>; SrcXprType = Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>; SrcXprType = Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>; Src = Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>; Src = Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>; Src = Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>; Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>]'
..\Eigen/src/Core/ProductEvaluators.h:974:11:   required from 'static void Eigen::internal::permutation_matrix_product<ExpressionType, Side, Transposed, Eigen::DenseShape>::run(Dest&, const PermutationType&, const ExpressionType&) [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; PermutationType = Eigen::PermutationMatrix<-1, -1, int>; ExpressionType = Eigen::Matrix<std::complex<float>, -1, -1>; int Side = 1; bool Transposed = false]'
..\Eigen/src/Core/ProductEvaluators.h:989:72:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::PermutationShape, MatrixShape, ProductTag>::evalTo(Dest&, const Lhs&, const Rhs&) [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Lhs = Eigen::PermutationMatrix<-1, -1, int>; Rhs = Eigen::Matrix<std::complex<float>, -1, -1>; int ProductTag = 8; MatrixShape = Eigen::DenseShape]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; Lhs = Eigen::PermutationMatrix<-1, -1, int>; Rhs = Eigen::Matrix<std::complex<float>, -1, -1>; int Options = 2; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::PermutationMatrix<-1, -1, int>, Eigen::Matrix<std::complex<float>, -1, -1>, 2>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Product<Eigen::PermutationMatrix<-1, -1, int>, Eigen::Matrix<std::complex<float>, -1, -1>, 2>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Product<Eigen::PermutationMatrix<-1, -1, int>, Eigen::Matrix<std::complex<float>, -1, -1>, 2>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Product<Eigen::PermutationMatrix<-1, -1, int>, Eigen::Matrix<std::complex<float>, -1, -1>, 2>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::PermutationMatrix<-1, -1, int>, Eigen::Matrix<std::complex<float>, -1, -1>, 2>; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::PermutationMatrix<-1, -1, int>, Eigen::Matrix<std::complex<float>, -1, -1>, 2>; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/QR/CompleteOrthogonalDecomposition.h:524:7:   required from 'void Eigen::CompleteOrthogonalDecomposition<MatrixType>::_solve_impl(const RhsType&, DstType&) const [with RhsType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; DstType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Solve.h:147:5:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Solve<DecType, RhsType>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; DecType = Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >; RhsType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Solve<DecType, RhsType>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense>::SrcXprType = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/QR/CompleteOrthogonalDecomposition.h:537:9:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<MatrixType> >, Eigen::internal::assign_op<typename DstXprType::Scalar, typename Eigen::CompleteOrthogonalDecomposition<MatrixType>::Scalar>, Eigen::internal::Dense2Dense>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<typename DstXprType::Scalar, typename Eigen::CompleteOrthogonalDecomposition<MatrixType>::Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; Eigen::internal::Assignment<DstXprType, Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<MatrixType> >, Eigen::internal::assign_op<typename DstXprType::Scalar, typename Eigen::CompleteOrthogonalDecomposition<MatrixType>::Scalar>, Eigen::internal::Dense2Dense>::SrcXprType = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >; typename Eigen::CompleteOrthogonalDecomposition<MatrixType>::Scalar = std::complex<float>; typename DstXprType::Scalar = std::complex<float>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:943:103:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false> > > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false> > > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false> > >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false> > >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false> > >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false> > >; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false> > >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false> > >; Derived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/GeneralProduct.h:328:87:   required from 'static void Eigen::internal::gemv_dense_selector<2, 1, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false> >; Rhs = Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false> > >; Dest = Eigen::Transpose<Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> > >; typename Dest::Scalar = double]'
..\Eigen/src/Core/GeneralProduct.h:192:12:   required from 'static void Eigen::internal::gemv_dense_selector<1, StorageOrder, BlasCompatible>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false> >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>; Dest = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; int StorageOrder = 0; bool BlasCompatible = true; typename Dest::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false> >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false> >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = double]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false> >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false> >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/NoAlias.h:42:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>, -1, -1, false>, 0>; ExpressionType = Eigen::Map<Eigen::Matrix<double, 1, -1>, 0, Eigen::Stride<0, 0> >; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:126:19:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheLeft(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Block<const Eigen::Matrix<double, -1, -1>, -1, 1, false>; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = double]'
..\Eigen/src/Householder/HouseholderSequence.h:258:13:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::evalTo(Dest&, Workspace&) const [with Dest = Eigen::Matrix<double, -1, -1>; Workspace = Eigen::Matrix<double, -1, 1>; VectorsType = Eigen::Matrix<double, -1, -1>; CoeffsType = Eigen::Matrix<double, -1, 1>; int Side = 1]'
..\Eigen/src/Householder/HouseholderSequence.h:237:13:   required from 'void Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::evalTo(DestType&) const [with DestType = Eigen::Matrix<double, -1, -1>; VectorsType = Eigen::Matrix<double, -1, -1>; CoeffsType = Eigen::Matrix<double, -1, 1>; int Side = 1]'
..\Eigen/src/Core/AssignEvaluator.h:932:3:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::EigenBase2EigenBase, Weak>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<typename DstXprType::Scalar, typename SrcXprType::Scalar>&) [with DstXprType = Eigen::Matrix<double, -1, -1>; SrcXprType = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; Functor = Eigen::internal::assign_op<double, double>; Weak = void; typename SrcXprType::Scalar = double; typename DstXprType::Scalar = double]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>]'
..\Eigen/src/Core/Assign.h:75:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:571:22:   required from 'Derived& Eigen::PlainObjectBase<Derived>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:238:29:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Eigenvalues/RealSchur.h:288:12:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::computeFromHessenberg(const HessMatrixType&, const OrthMatrixType&, bool) [with HessMatrixType = Eigen::internal::HessenbergDecompositionMatrixHReturnType<Eigen::Matrix<double, -1, -1> >; OrthMatrixType = Eigen::HouseholderSequence<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, 1>, 1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/RealSchur.h:274:24:   required from 'Eigen::RealSchur<MatrixType>& Eigen::RealSchur<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:389:3:   required from 'Eigen::EigenSolver<MatrixType>& Eigen::EigenSolver<_MatrixType>::compute(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Eigenvalues/EigenSolver.h:156:14:   required from 'Eigen::EigenSolver<_MatrixType>::EigenSolver(const Eigen::EigenBase<OtherDerived>&, bool) [with InputType = Eigen::Matrix<double, -1, -1>; _MatrixType = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:176:29:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1, 1, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1, 1, -1, -1> > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1, 1, -1, -1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1, 1, -1, -1> > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1, 1, -1, -1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1, 1, -1, -1> >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1, 1, -1, -1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1, 1, -1, -1> >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1, 1, -1, -1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1, 1, -1, -1> >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<double, -1, -1, 1, -1, -1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1, 1, -1, -1> >; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, -1, -1, 1, -1, -1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1, 1, -1, -1> >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1, 1, -1, -1> >; Derived = Eigen::Matrix<double, -1, -1, 1, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1, 1, -1, -1> >; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 1; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/CwiseNullaryOp.h:327:20:   required from 'Derived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Matrix<double, -1, -1, 1, -1, -1>; Eigen::DenseBase<Derived>::Scalar = double]'
..\Eigen/src/Core/CwiseNullaryOp.h:501:21:   required from 'Derived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Matrix<double, -1, -1, 1, -1, -1>]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:434:7:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, -1, 1, -1, -1>; Lhs = Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>; Rhs = Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<double, -1, -1, 1, -1, -1>; Lhs = Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>; Rhs = Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1, 1, -1, -1>; Src = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; Derived = Eigen::Matrix<double, -1, -1, 1, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:537:19:   required from 'Eigen::PlainObjectBase<Derived>::PlainObjectBase(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; Derived = Eigen::Matrix<double, -1, -1, 1, -1, -1>]'
..\Eigen/src/Core/Matrix.h:379:29:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 1; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:465:69:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::Scalar = double]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:435:20:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/EigenBase.h:104:9:   required from 'void Eigen::EigenBase<Derived>::applyThisOnTheRight(Dest&) const [with Dest = Eigen::Matrix<double, -1, -1>; Derived = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>]'
..\Eigen/src/Core/MatrixBase.h:500:3:   required from 'Derived& Eigen::MatrixBase<Derived>::operator*=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:179:42:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> >, Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> >, Eigen::internal::evaluator<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; SrcXprType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; SrcXprType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Src = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Src = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Src = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>]'
..\Eigen/src/Core/Assign.h:57:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::MatrixBase<Derived>&) [with Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>]'
..\Eigen/src/Core/MapBase.h:286:39:   required from 'Derived& Eigen::MapBase<Derived, 1>::operator=(const Eigen::MapBase<Derived, 1>&) [with Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>]'
..\Eigen/src/Core/Block.h:341:5:   required from 'Eigen::internal::BlockImpl_dense<XprType, BlockRows, BlockCols, InnerPanel, true>& Eigen::internal::BlockImpl_dense<XprType, BlockRows, BlockCols, InnerPanel, true>::operator=(const Eigen::internal::BlockImpl_dense<XprType, BlockRows, BlockCols, InnerPanel, true>&) [with XprType = Eigen::Matrix<std::complex<float>, -1, -1>; int BlockRows = -1; int BlockCols = -1; bool InnerPanel = false]'
..\Eigen/src/Core/Block.h:161:5:   required from 'Eigen::BlockImpl<XprType, BlockRows, BlockCols, InnerPanel, Eigen::Dense>& Eigen::BlockImpl<XprType, BlockRows, BlockCols, InnerPanel, Eigen::Dense>::operator=(const Eigen::BlockImpl<XprType, BlockRows, BlockCols, InnerPanel, Eigen::Dense>&) [with XprType = Eigen::Matrix<std::complex<float>, -1, -1>; int BlockRows = -1; int BlockCols = -1; bool InnerPanel = false]'
..\Eigen/src/Core/Block.h:111:5:   required from 'Eigen::Block<XprType, BlockRows, BlockCols, InnerPanel>& Eigen::Block<XprType, BlockRows, BlockCols, InnerPanel>::operator=(const Eigen::Block<XprType, BlockRows, BlockCols, InnerPanel>&) [with XprType = Eigen::Matrix<std::complex<float>, -1, -1>; int BlockRows = -1; int BlockCols = -1; bool InnerPanel = false]'
..\Eigen/src/Core/TriangularMatrix.h:540:13:   required from 'void Eigen::TriangularViewImpl<_MatrixType, _Mode, Eigen::Dense>::_solve_impl(const RhsType&, DstType&) const [with RhsType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; DstType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; _MatrixType = const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; unsigned int _Mode = 2]'
..\Eigen/src/Core/Solve.h:147:5:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Solve<DecType, RhsType>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; DecType = Eigen::TriangularView<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 2>; RhsType = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Solve<DecType, RhsType>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense>::SrcXprType = Eigen::Solve<Eigen::TriangularView<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 2>, Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> >]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Src = Eigen::Solve<Eigen::TriangularView<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 2>, Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Src = Eigen::Solve<Eigen::TriangularView<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 2>, Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Src = Eigen::Solve<Eigen::TriangularView<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 2>, Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Solve<Eigen::TriangularView<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, 2>, Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false> >; Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>]'
..\Eigen/src/QR/CompleteOrthogonalDecomposition.h:510:21:   required from 'void Eigen::CompleteOrthogonalDecomposition<MatrixType>::_solve_impl(const RhsType&, DstType&) const [with RhsType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; DstType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Solve.h:147:5:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Solve<DecType, RhsType>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; DecType = Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >; RhsType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Solve<DecType, RhsType>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense>::SrcXprType = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/QR/CompleteOrthogonalDecomposition.h:537:9:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<MatrixType> >, Eigen::internal::assign_op<typename DstXprType::Scalar, typename Eigen::CompleteOrthogonalDecomposition<MatrixType>::Scalar>, Eigen::internal::Dense2Dense>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<typename DstXprType::Scalar, typename Eigen::CompleteOrthogonalDecomposition<MatrixType>::Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; Eigen::internal::Assignment<DstXprType, Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<MatrixType> >, Eigen::internal::assign_op<typename DstXprType::Scalar, typename Eigen::CompleteOrthogonalDecomposition<MatrixType>::Scalar>, Eigen::internal::Dense2Dense>::SrcXprType = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >; typename Eigen::CompleteOrthogonalDecomposition<MatrixType>::Scalar = std::complex<float>; typename DstXprType::Scalar = std::complex<float>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:943:103:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Transpose<const Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> > >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> > >, Eigen::internal::evaluator<Eigen::Transpose<const Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > > >, Eigen::internal::assign_op<std::complex<float>, std::complex<float> >, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Transpose<const Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; SrcXprType = Eigen::Transpose<const Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > >; Functor = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Transpose<const Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Transpose<const Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Transpose<const Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > >]'
..\Eigen/src/Core/Assign.h:66:28:   required from 'Derived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Transpose<const Eigen::Transpose<const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > >; Derived = Eigen::Map<Eigen::Matrix<std::complex<float>, -1, 1>, 0, Eigen::Stride<0, 0> >]'
..\Eigen/src/Core/GeneralProduct.h:328:87:   required from 'static void Eigen::internal::gemv_dense_selector<2, 1, true>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false> >; Rhs = Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > > > >; Dest = Eigen::Transpose<Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> > >; typename Dest::Scalar = std::complex<float>]'
..\Eigen/src/Core/GeneralProduct.h:192:12:   required from 'static void Eigen::internal::gemv_dense_selector<1, StorageOrder, BlasCompatible>::run(const Lhs&, const Rhs&, Dest&, const typename Dest::Scalar&) [with Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > > >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Dest = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; int StorageOrder = 0; bool BlasCompatible = true; typename Dest::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:383:34:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > > >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 7>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:361:27:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::scaleAndAddTo(Dst&, const Lhs&, const Rhs&, const Scalar&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > > >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > > >, Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::DenseShape, Eigen::DenseShape, 7>; Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::Scalar = std::complex<float>]'
..\Eigen/src/Core/ProductEvaluators.h:349:33:   required from 'static void Eigen::internal::generic_product_impl_base<Lhs, Rhs, Derived>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > > >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; Derived = Eigen::internal::generic_product_impl<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > > >, Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, Eigen::DenseShape, Eigen::DenseShape, 7>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > > >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>; int Options = 0; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > > >, Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; Src = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > > >, Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 0>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/NoAlias.h:42:31:   required from 'ExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > > > >, Eigen::Block<Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>, -1, -1, false>, 0>; ExpressionType = Eigen::Map<Eigen::Matrix<std::complex<float>, 1, -1>, 0, Eigen::Stride<0, 0> >; StorageBase = Eigen::MatrixBase]'
..\Eigen/src/Householder/Householder.h:126:19:   required from 'void Eigen::MatrixBase<Derived>::applyHouseholderOnTheLeft(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::Transpose<const Eigen::Block<const Eigen::Block<const Eigen::Matrix<std::complex<float>, -1, -1>, 1, -1, false>, 1, -1, false> > >; Derived = Eigen::Block<Eigen::Matrix<std::complex<float>, -1, -1>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = std::complex<float>]'
..\Eigen/src/QR/CompleteOrthogonalDecomposition.h:479:5:   required from 'void Eigen::CompleteOrthogonalDecomposition<MatrixType>::applyZAdjointOnTheLeftInPlace(Rhs&) const [with Rhs = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/QR/CompleteOrthogonalDecomposition.h:520:34:   required from 'void Eigen::CompleteOrthogonalDecomposition<MatrixType>::_solve_impl(const RhsType&, DstType&) const [with RhsType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; DstType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Solve.h:147:5:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Solve<DecType, RhsType>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; DecType = Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >; RhsType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Solve<DecType, RhsType>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense>::SrcXprType = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/QR/CompleteOrthogonalDecomposition.h:537:9:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<MatrixType> >, Eigen::internal::assign_op<typename DstXprType::Scalar, typename Eigen::CompleteOrthogonalDecomposition<MatrixType>::Scalar>, Eigen::internal::Dense2Dense>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<typename DstXprType::Scalar, typename Eigen::CompleteOrthogonalDecomposition<MatrixType>::Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; Eigen::internal::Assignment<DstXprType, Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<MatrixType> >, Eigen::internal::assign_op<typename DstXprType::Scalar, typename Eigen::CompleteOrthogonalDecomposition<MatrixType>::Scalar>, Eigen::internal::Dense2Dense>::SrcXprType = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >; typename Eigen::CompleteOrthogonalDecomposition<MatrixType>::Scalar = std::complex<float>; typename DstXprType::Scalar = std::complex<float>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:943:103:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<bool, -1, 1, 0, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<bool>, Eigen::Matrix<bool, -1, 1, 0, -1, 1> > >, Eigen::internal::assign_op<bool, bool> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<bool, -1, 1, 0, -1, 1> >, Eigen::internal::evaluator<Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<bool>, Eigen::Matrix<bool, -1, 1, 0, -1, 1> > >, Eigen::internal::assign_op<bool, bool>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<bool, -1, 1, 0, -1, 1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<bool>, Eigen::Matrix<bool, -1, 1, 0, -1, 1> >; Functor = Eigen::internal::assign_op<bool, bool>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<bool, -1, 1, 0, -1, 1>; SrcXprType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<bool>, Eigen::Matrix<bool, -1, 1, 0, -1, 1> >; Functor = Eigen::internal::assign_op<bool, bool>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<bool, -1, 1, 0, -1, 1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<bool>, Eigen::Matrix<bool, -1, 1, 0, -1, 1> >; Func = Eigen::internal::assign_op<bool, bool>]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<bool, -1, 1, 0, -1, 1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<bool>, Eigen::Matrix<bool, -1, 1, 0, -1, 1> >; Func = Eigen::internal::assign_op<bool, bool>; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<bool, -1, 1, 0, -1, 1>; Src = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<bool>, Eigen::Matrix<bool, -1, 1, 0, -1, 1> >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<bool>, Eigen::Matrix<bool, -1, 1, 0, -1, 1> >; Derived = Eigen::Matrix<bool, -1, 1, 0, -1, 1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<bool>, Eigen::Matrix<bool, -1, 1, 0, -1, 1> >; _Scalar = bool; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = -1; int _MaxCols = 1]'
..\Eigen/src/Core/CwiseNullaryOp.h:327:20:   required from 'Derived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Matrix<bool, -1, 1, 0, -1, 1>; Eigen::DenseBase<Derived>::Scalar = bool]'
..\Eigen/src/Core/CwiseNullaryOp.h:317:14:   required from 'void Eigen::DenseBase<Derived>::fill(const Scalar&) [with Derived = Eigen::Matrix<bool, -1, 1, 0, -1, 1>; Eigen::DenseBase<Derived>::Scalar = bool]'
..\Eigen/src/Core/ProductEvaluators.h:944:9:   required from 'static void Eigen::internal::permutation_matrix_product<ExpressionType, Side, Transposed, Eigen::DenseShape>::run(Dest&, const PermutationType&, const ExpressionType&) [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; PermutationType = Eigen::PermutationMatrix<-1, -1, int>; ExpressionType = Eigen::Matrix<std::complex<float>, -1, -1>; int Side = 1; bool Transposed = false]'
..\Eigen/src/Core/ProductEvaluators.h:989:72:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::PermutationShape, MatrixShape, ProductTag>::evalTo(Dest&, const Lhs&, const Rhs&) [with Dest = Eigen::Matrix<std::complex<float>, -1, -1>; Lhs = Eigen::PermutationMatrix<-1, -1, int>; Rhs = Eigen::Matrix<std::complex<float>, -1, -1>; int ProductTag = 8; MatrixShape = Eigen::DenseShape]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; Lhs = Eigen::PermutationMatrix<-1, -1, int>; Rhs = Eigen::Matrix<std::complex<float>, -1, -1>; int Options = 2; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::PermutationMatrix<-1, -1, int>, Eigen::Matrix<std::complex<float>, -1, -1>, 2>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Product<Eigen::PermutationMatrix<-1, -1, int>, Eigen::Matrix<std::complex<float>, -1, -1>, 2>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Product<Eigen::PermutationMatrix<-1, -1, int>, Eigen::Matrix<std::complex<float>, -1, -1>, 2>; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Product<Eigen::PermutationMatrix<-1, -1, int>, Eigen::Matrix<std::complex<float>, -1, -1>, 2>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::PermutationMatrix<-1, -1, int>, Eigen::Matrix<std::complex<float>, -1, -1>, 2>; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::PermutationMatrix<-1, -1, int>, Eigen::Matrix<std::complex<float>, -1, -1>, 2>; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/QR/CompleteOrthogonalDecomposition.h:524:7:   required from 'void Eigen::CompleteOrthogonalDecomposition<MatrixType>::_solve_impl(const RhsType&, DstType&) const [with RhsType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; DstType = Eigen::Matrix<std::complex<float>, -1, -1>; _MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Solve.h:147:5:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Solve<DecType, RhsType>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; DecType = Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >; RhsType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> >; Scalar = std::complex<float>; Eigen::internal::Assignment<DstXprType, Eigen::Solve<DecType, RhsType>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense>::SrcXprType = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Solve<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<std::complex<float> >, Eigen::Matrix<std::complex<float>, -1, -1> > >; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/QR/CompleteOrthogonalDecomposition.h:537:9:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<MatrixType> >, Eigen::internal::assign_op<typename DstXprType::Scalar, typename Eigen::CompleteOrthogonalDecomposition<MatrixType>::Scalar>, Eigen::internal::Dense2Dense>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<typename DstXprType::Scalar, typename Eigen::CompleteOrthogonalDecomposition<MatrixType>::Scalar>&) [with DstXprType = Eigen::Matrix<std::complex<float>, -1, -1>; MatrixType = Eigen::Matrix<std::complex<float>, -1, -1>; Eigen::internal::Assignment<DstXprType, Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<MatrixType> >, Eigen::internal::assign_op<typename DstXprType::Scalar, typename Eigen::CompleteOrthogonalDecomposition<MatrixType>::Scalar>, Eigen::internal::Dense2Dense>::SrcXprType = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >; typename Eigen::CompleteOrthogonalDecomposition<MatrixType>::Scalar = std::complex<float>; typename DstXprType::Scalar = std::complex<float>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >]'
..\Eigen/src/Core/AssignEvaluator.h:836:26:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >; Func = Eigen::internal::assign_op<std::complex<float>, std::complex<float> >; typename Eigen::internal::enable_if<(! Eigen::internal::evaluator_assume_aliasing<Src>::value), void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<std::complex<float>, -1, -1>; Src = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >; Derived = Eigen::Matrix<std::complex<float>, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Inverse<Eigen::CompleteOrthogonalDecomposition<Eigen::Matrix<std::complex<float>, -1, -1> > >; _Scalar = std::complex<float>; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\binary_library.cpp:943:103:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h: In instantiation of 'struct Eigen::internal::copy_using_evaluator_traits<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1, 1, -1, -1> >, Eigen::internal::evaluator<Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > > >, Eigen::internal::assign_op<double, double> >':
..\Eigen/src/Core/AssignEvaluator.h:607:48:   required from 'class Eigen::internal::generic_dense_assignment_kernel<Eigen::internal::evaluator<Eigen::Matrix<double, -1, -1, 1, -1, -1> >, Eigen::internal::evaluator<Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > > >, Eigen::internal::assign_op<double, double>, 0>'
..\Eigen/src/Core/AssignEvaluator.h:762:9:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1, 1, -1, -1>; SrcXprType = Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1, 1, -1, -1>; SrcXprType = Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1, 1, -1, -1>; Src = Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >; Derived = Eigen::Matrix<double, -1, -1, 1, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >; OtherDerived = Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >; Derived = Eigen::Matrix<double, -1, -1, 1, -1, -1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 1; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/ProductEvaluators.h:451:34:   required from 'Eigen::internal::product_evaluator<Eigen::Product<Lhs, Rhs, 1>, ProductTag, Eigen::DenseShape, Eigen::DenseShape>::product_evaluator(const XprType&) [with Lhs = Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>; Rhs = Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >; int ProductTag = 8; typename Eigen::internal::traits<typename Eigen::Product<Lhs, Rhs, 1>::Rhs>::Scalar = double; typename Eigen::internal::traits<typename Eigen::Product<Lhs, Rhs, 1>::Lhs>::Scalar = double; Eigen::internal::product_evaluator<Eigen::Product<Lhs, Rhs, 1>, ProductTag, Eigen::DenseShape, Eigen::DenseShape>::XprType = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 1>]'
..\Eigen/src/Core/ProductEvaluators.h:35:70:   required from 'Eigen::internal::evaluator<Eigen::Product<Lhs, Rhs, Option> >::evaluator(const XprType&) [with Lhs = Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>; Rhs = Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >; int Options = 1; Eigen::internal::evaluator<Eigen::Product<Lhs, Rhs, Option> >::XprType = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 1>]'
..\Eigen/src/Core/AssignEvaluator.h:753:19:   required from 'void Eigen::internal::call_dense_assignment_loop(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1, 1, -1, -1>; SrcXprType = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 1>; Functor = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/AssignEvaluator.h:912:29:   required from 'static void Eigen::internal::Assignment<DstXprType, SrcXprType, Functor, Eigen::internal::Dense2Dense, Weak>::run(DstXprType&, const SrcXprType&, const Functor&) [with DstXprType = Eigen::Matrix<double, -1, -1, 1, -1, -1>; SrcXprType = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 1>; Functor = Eigen::internal::assign_op<double, double>; Weak = void]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1, 1, -1, -1>; Src = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 1>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/ProductEvaluators.h:397:29:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 3>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, -1, 1, -1, -1>; Lhs = Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>; Rhs = Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:431:26:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, -1, 1, -1, -1>; Lhs = Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>; Rhs = Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<double, -1, -1, 1, -1, -1>; Lhs = Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>; Rhs = Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1, 1, -1, -1>; Src = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; Derived = Eigen::Matrix<double, -1, -1, 1, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:537:19:   required from 'Eigen::PlainObjectBase<Derived>::PlainObjectBase(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; Derived = Eigen::Matrix<double, -1, -1, 1, -1, -1>]'
..\Eigen/src/Core/Matrix.h:379:29:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 1; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:465:69:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::scaleAndAddTo(Dest&, const Lhs&, const Rhs&, const Scalar&) [with Dest = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::Scalar = double]'
..\Eigen/src/Core/products/GeneralMatrixMatrix.h:435:20:   required from 'static void Eigen::internal::generic_product_impl<Lhs, Rhs, Eigen::DenseShape, Eigen::DenseShape, 8>::evalTo(Dst&, const Lhs&, const Rhs&) [with Dst = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>]'
..\Eigen/src/Core/ProductEvaluators.h:148:43:   required from 'static void Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::run(DstXprType&, const SrcXprType&, const Eigen::internal::assign_op<Scalar, Scalar>&) [with DstXprType = Eigen::Matrix<double, -1, -1>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; int Options = 0; Scalar = double; Eigen::internal::Assignment<DstXprType, Eigen::Product<Lhs, Rhs, Options>, Eigen::internal::assign_op<Scalar, Scalar>, Eigen::internal::Dense2Dense, typename Eigen::internal::enable_if<((Options == DefaultProduct) || (Options == AliasFreeProduct))>::type>::SrcXprType = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>]'
..\Eigen/src/Core/AssignEvaluator.h:868:50:   required from 'void Eigen::internal::call_assignment_no_alias(Dst&, const Src&, const Func&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; Func = Eigen::internal::assign_op<double, double>]'
..\Eigen/src/Core/PlainObjectBase.h:728:41:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/PlainObjectBase.h:812:7:   required from 'void Eigen::PlainObjectBase<Derived>::_init1(const Eigen::DenseBase<ElseDerived>&) [with T = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:296:31:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const T&) [with T = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/AssignEvaluator.h:827:40:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&, const Func&, typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; Func = Eigen::internal::assign_op<double, double>; typename Eigen::internal::enable_if<Eigen::internal::evaluator_assume_aliasing<Src>::value, void*>::type = void*]'
..\Eigen/src/Core/AssignEvaluator.h:811:17:   required from 'void Eigen::internal::call_assignment(Dst&, const Src&) [with Dst = Eigen::Matrix<double, -1, -1>; Src = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>]'
..\Eigen/src/Core/PlainObjectBase.h:710:32:   required from 'Derived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\Eigen/src/Core/Matrix.h:225:24:   required from 'Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Matrix<double, -1, -1>, Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>, 0>; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1]'
..\Eigen/src/Core/EigenBase.h:104:9:   required from 'void Eigen::EigenBase<Derived>::applyThisOnTheRight(Dest&) const [with Dest = Eigen::Matrix<double, -1, -1>; Derived = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>]'
..\Eigen/src/Core/MatrixBase.h:500:3:   required from 'Derived& Eigen::MatrixBase<Derived>::operator*=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::Product<Eigen::Product<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> >, Eigen::DiagonalWrapper<const Eigen::MatrixWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_rsqrt_op<double>, const Eigen::ArrayWrapper<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<std::complex<double> >, const Eigen::Matrix<std::complex<double>, -1, 1> > > > > >, 1>, Eigen::Transpose<Eigen::CwiseUnaryView<Eigen::internal::scalar_real_ref_op<std::complex<double> >, Eigen::Matrix<std::complex<double>, -1, -1> > >, 0>; Derived = Eigen::Matrix<double, -1, -1>]'
..\binary_library.cpp:179:42:   required from here
..\Eigen/src/Core/AssignEvaluator.h:92:5: warning: enum constant in boolean context [-Wint-in-bool-context]
   MayLinearVectorize = bool(MightVectorize) && MayLinearize
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     && DstHasDirectAccess
     ^~~~~~~~~~~~~~~~~~~~~
..\Eigen/src/Core/AssignEvaluator.h:98:47: warning: enum constant in boolean context [-Wint-in-bool-context]
   MaySliceVectorize = bool(MightVectorize) && bool(DstHasDirectAccess)
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
..\binary_library.cpp: At global scope:
..\binary_library.cpp:104:13: warning: 'void matrix_mul(I2_VECTOR&, I2_VECTOR&, I2_VECTOR&)' defined but not used [-Wunused-function]
 static void matrix_mul(I2_VECTOR &z, I2_VECTOR &x, I2_VECTOR &y) {
             ^~~~~~~~~~
ar -r libeigens.a binary_library.o em_gmm.o 

16:51:53 Build Finished (took 1m:39s.621ms)

